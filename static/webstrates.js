const documentProxyObj={},documentProxy=new Proxy(document,documentProxyObj);!function(document,_document,documentProxyObj){!function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=49)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar coreUtilsModule = {};\n\nvar locationObject = void 0;\n/**\n * Parses a query string and returns a more friendly object.\n * @param  {Location} location Location object.\n * @return {object}            Object with webstrateId, tagOrVersion and parameters.\n */\ncoreUtilsModule.getLocationObject = function () {\n\tif (locationObject) {\n\t\treturn locationObject;\n\t}\n\n\tvar pathRegex = /^\\/([A-Z0-9._-]+)\\/(?:([A-Z0-9_-]+)\\/)?/i.exec(window.location.pathname);\n\n\tvar _pathRegex = _slicedToArray(pathRegex, 3),\n\t    webstrateId = _pathRegex[1],\n\t    tagOrVersion = _pathRegex[2];\n\n\tvar parameters = {};\n\tvar queryRegex = /([^&=]+)=?([^&]*)/g;\n\tvar query = window.location.search.substring(1);\n\n\tvar match = void 0;\n\twhile (match = queryRegex.exec(query)) {\n\t\tvar _match = match,\n\t\t    _match2 = _slicedToArray(_match, 3),\n\t\t    key = _match2[1],\n\t\t    value = _match2[2];\n\n\t\tparameters[key] = decodeURIComponent(value);\n\t}\n\n\tvar tag = void 0,\n\t    version = void 0;\n\tif (/^\\d/.test(tagOrVersion) && Number(tagOrVersion)) {\n\t\tversion = Number(tagOrVersion);\n\t} else {\n\t\ttag = tagOrVersion;\n\t}\n\n\tlocationObject = {\n\t\twebstrateId: webstrateId,\n\t\tstaticMode: !!tagOrVersion,\n\t\ttagOrVersion: tagOrVersion,\n\t\ttag: tag, version: version, // Only one of tag/version will be set\n\t\tparameters: parameters\n\t};\n\n\treturn locationObject;\n};\n\n/**\n * Creates a throttled version of a function, i.e. one that only runs at most once every N\n * milliseconds.\n * @param  {Function} fn         Source function.\n * @param  {Number}   limit      Execution delay in milliseconds.\n * @return {Function}            Throttled source function.\n * @public\n */\ncoreUtilsModule.throttleFn = function (fn, limit) {\n\tvar timeout = void 0,\n\t    lastCall = 0;\n\treturn function () {\n\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\targs[_key] = arguments[_key];\n\t\t}\n\n\t\tvar now = Date.now();\n\t\tvar delay = lastCall + limit - now;\n\t\tif (delay <= 0) {\n\t\t\tfn.apply(undefined, args);\n\t\t\tlastCall = now;\n\t\t} else {\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(function () {\n\t\t\t\tfn.apply(undefined, args);\n\t\t\t\tlastCall = now;\n\t\t\t}, delay);\n\t\t}\n\t};\n};\n\n/**\n * Checks for literal equality of objects. This is a stupid way, but it works.\n * @param  {obj} a First object to compare.\n * @param  {obj} b Second object to compare.\n * @return {bool}  True if objects are equal.\n * @public\n */\ncoreUtilsModule.objectEquals = function (a, b) {\n\treturn JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Shallow clones an object.\n * @param  {obj} obj Object to be copied.\n * @return {obj}     Shallow clone.\n * @public\n */\ncoreUtilsModule.objectClone = function (obj) {\n\treturn Array.isArray(obj) ? obj.slice(0) : Object.assign({}, obj);\n};\n\n/**\n * Returns a locked, shallow clone of an object.\n * @param  {obj} obj Object to lock and clone.\n * @return {obj}     Cloned object.\n * @public\n */\ncoreUtilsModule.objectCloneAndLock = function (obj) {\n\treturn Object.freeze(coreUtilsModule.objectClone(obj));\n};\n\n/**\n * Get random integer from interval [min, max). Unbiased and evenly distributed (or close to).\n * @param  {int} min Minimum number, inclusive.\n * @param  {int} max Maximum number, exclusive.\n * @return {int}     Random number in interval [min, max)\n * @public\n */\ncoreUtilsModule.random = function (min, max) {\n\treturn Math.floor(min + Math.random() * (max - min));\n};\n\n/**\n * Get random string of size.\n * @param  {int}    size     Expected length of string (optional).\n * @param  {string} alphabet List of characters to be used in string (optional).\n * @return {string}          Generated string.\n * @public\n */\ncoreUtilsModule.randomString = function () {\n\tvar size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n\tvar alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';\n\n\tvar len = alphabet.length;\n\tvar str = '';\n\twhile (size--) {\n\t\tstr += alphabet[coreUtilsModule.random(0, len)];\n\t}\n\treturn str;\n};\n\n/**\n * Get child nodes of an element. If the element is a fragment, get the content's child nodes.\n * @param  {DOMElement} parentElement Element to get child nodes of.\n * @return {array}                    List of child nodes.\n */\ncoreUtilsModule.getChildNodes = function (parentElement) {\n\t// This will be the case for <template> tags.\n\tif (parentElement.content && parentElement.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\tparentElement = parentElement.content;\n\t}\n\treturn parentElement.childNodes;\n};\n\n/**\n * Traverses a node tree and applies a callback to each node.\n * @param {DOMNode}  node     Node tree to traverse.\n * @param {DOMNode}  parent   Initial parent node.\n * @param {Function} callback Callback.\n * @public\n */\ncoreUtilsModule.recursiveForEach = function (node, callback) {\n\tvar parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\tcallback(node, parent);\n\n\tArray.from(coreUtilsModule.getChildNodes(node)).forEach(function (child) {\n\t\tcoreUtilsModule.recursiveForEach(child, callback, node);\n\t});\n};\n\n/**\n * Append a DOM element childElement to another DOM element parentElement. If the DOM element to\n * be appended is a script, prevent the execution of the script. If the parentElement is a\n * <template>, add the child to the parentElement's documentFragment instead. If a referenceNode\n * is specified, the element is inserted before the referenceNode.\n * @param {DOMNode} parentElement Parent element.\n * @param {DOMNode} childElement  Child element.\n * @param {DOMNode} referenceNode Node to insert before.\n * @public\n */\ncoreUtilsModule.appendChildWithoutScriptExecution = function (parentElement, childElement, referenceNode) {\n\t// We just insert text nodes right away, we're only interested in doing fancy stuff with elements\n\t// that may have scripts as children.\n\tif (!(childElement instanceof HTMLElement)) {\n\t\treturn parentElement.insertBefore(childElement, referenceNode || null);\n\t}\n\n\t// To prevent scripts from being executed when inserted, we use a little hack. Before inserting\n\t// the script, we replace the actual script with dummy content, causing that to be executed\n\t// instead of the actual script. If it's an inline script, we insert a script with dummy content\n\t// ('// Execution prevention'), and then replace the innerHTML afterwards.\n\t// To prevent issues with any other attributes (e.g. crossorigin and integrity), we also remove\n\t// all those attributes and insert them later.\n\tvar scriptMap = new Map();\n\tvar scripts = childElement instanceof HTMLScriptElement ? [childElement] : [].concat(_toConsumableArray(childElement.querySelectorAll('script')));\n\n\tscripts.forEach(function (script) {\n\t\tvar attrs = [];\n\t\tArray.from(script.attributes).forEach(function (attr) {\n\t\t\tattrs.push([attr.nodeName, attr.nodeValue]);\n\t\t\tscript.removeAttribute(attr.nodeName);\n\t\t});\n\t\tvar text = script.innerHTML;\n\t\tscript.innerHTML = '// Execution prevention';\n\t\tscriptMap.set(script, [attrs, text]);\n\t});\n\n\tparentElement.insertBefore(childElement, referenceNode || null);\n\n\tscripts.forEach(function (script) {\n\t\tvar _scriptMap$get = scriptMap.get(script),\n\t\t    _scriptMap$get2 = _slicedToArray(_scriptMap$get, 2),\n\t\t    attrs = _scriptMap$get2[0],\n\t\t    text = _scriptMap$get2[1];\n\n\t\tattrs.forEach(function (attr) {\n\t\t\tvar _attr = _slicedToArray(attr, 2),\n\t\t\t    nodeName = _attr[0],\n\t\t\t    nodeValue = _attr[1];\n\n\t\t\tscript.setAttribute(nodeName, nodeValue);\n\t\t});\n\t\tscript.innerHTML = text;\n\t});\n};\n\n/**\n * Reinsert and execute an array of scripts in order.\n * @param {array}    scripts  Array of script DOM elements.\n * @param {Function} callback Function to call once all scripts have been executed.\n * @public\n */\ncoreUtilsModule.executeScripts = function (scripts, callback) {\n\tvar script = scripts.shift();\n\tif (!script) {\n\t\treturn callback();\n\t}\n\n\t// Scripts in templates shouldn't get executed. If we didn't do this, we could also run into\n\t// issues a little later in the function when we'd attempt to reinsert the element into its\n\t// parent if the script is a direct child of the template, as such children don't actually have\n\t// parents.\n\tif (coreUtilsModule.elementIsTemplateDescendant(script)) {\n\t\treturn coreUtilsModule.executeScripts(scripts, callback);\n\t}\n\n\tvar executeImmediately = !script.src;\n\tvar newScript = document.createElementNS(script.namespaceURI, 'script');\n\tif (!executeImmediately) {\n\t\tnewScript.onload = newScript.onerror = function () {\n\t\t\tcoreUtilsModule.executeScripts(scripts, callback);\n\t\t};\n\t}\n\n\t// Copy over all attribtues.\n\tfor (var i = 0; i < script.attributes.length; i++) {\n\t\tvar attr = script.attributes[i];\n\t\tnewScript.setAttribute(attr.nodeName, attr.nodeValue);\n\t}\n\n\t// Copy over all other properties.\n\tObject.assign(newScript, script);\n\n\t// We're defining the wid with defineProperty to make it non-modifiable, but assign will just copy\n\t// over the value, leaving it modifiable otherwise.\n\tcoreUtilsModule.setWidOnElement(newScript, script.__wid);\n\n\tnewScript.innerHTML = script.innerHTML;\n\n\tscript.parentElement.insertBefore(newScript, script);\n\tscript.remove();\n\n\tif (executeImmediately) {\n\t\tcoreUtilsModule.executeScripts(scripts, callback);\n\t}\n};\n\n/**\n * Check whether a DOM Node is a descendant of a template tag (or actually a documentFragment).\n * One might assume this could be done with `element.closest(\"template\")`, but that won't be the\n * case, because a documentFragment technically isn't a parent (and also doesn't have any parent),\n * so there will be no tree to search upwards through after we reach the documentFragment.\n * @param  {DOMNode} DOMNode DOM Node to check.\n * @return {boolean}         True if the DOM Node is a descendant of a template.\n * @private\n */\ncoreUtilsModule.elementIsTemplateDescendant = function (element) {\n\treturn document.documentElement.ownerDocument !== element.ownerDocument;\n};\n\n/**\n * Check if the current page has been transcluded (i.e. is an iframe)\n * @return {bool} True if this frame is transcluded.\n * @public\n */\ncoreUtilsModule.isTranscluded = function () {\n\treturn window.frameElement && window.parent !== window;\n};\n\n/**\n * Check whether the current frame shares domain with the outer frame. Only useful when called\n * when transcluded (i.e. called from an iframe). This is used to determine whether accessing the\n * outer frame will cause CORS errors.\n * @return {bool} True if current and outer frame share domain.\n * @public\n */\ncoreUtilsModule.sameParentDomain = function () {\n\tvar a = document.createElement('a');\n\ta.href = document.referrer;\n\treturn a.host === location.host;\n};\n\n/**\n * Removes characters that are illegal in attributes and tag names.\n * @param  {string} tagName Unsanitized string.\n * @return {string}         Sanitized string.\n * @public\n */\ncoreUtilsModule.sanitizeString = function (string) {\n\t// See https://www.w3.org/TR/html5/syntax.html#tag-name and\n\t// https://www.w3.org/TR/html5/syntax.html#elements-attributes\n\t// These regex test does not fully adhere to either, but is more stringent to avoid serialization\n\t// issues.\n\tvar NAME_START_CHAR_REGEX = /:|[A-Z]|_|[a-z]/;\n\tvar NAME_CHAR_REGEX = /-|\\.|[0-9]/;\n\n\treturn string.split('').map(function (char, index) {\n\t\tif (NAME_START_CHAR_REGEX.test(char) || index > 0 && NAME_CHAR_REGEX.test(char)) {\n\t\t\treturn char;\n\t\t}\n\t\treturn '_';\n\t}).join('');\n};\n\n/**\n * Replaces ampersands (&) and double-quotes (\") with their respective HTML entities.\n * @param  {string} value Unescaped string.\n * @return {string}       Escaped string.\n * @public\n */\ncoreUtilsModule.escape = function (value) {\n\treturn value && value.replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n};\n\n/**\n * Replaces &amp; and &quot; with their respective characters (& and \").\n * @param  {string} value Escaped string.\n * @return {string}       Unescaped string.\n * @public\n */\ncoreUtilsModule.unescape = function (value) {\n\treturn value && value.replace(/&amp;/g, '&').replace(/&quot;/g, '\"');\n};\n\n/**\n * Replaces \".\" with &dot;.\n * @param  {string} value Unescaped string.\n * @return {string}       Escaped string.\n * @public\n */\ncoreUtilsModule.escapeDots = function (value) {\n\treturn value && value.replace(/\\./g, '&dot;');\n};\n\n/**\n * Replaces &dot; with \".\".\n * @param  {string} value Escaped string.\n * @return {string}       Unescaped string.\n * @public\n */\ncoreUtilsModule.unescapeDots = function (value) {\n\treturn value && value.replace(/&dot;/g, '.');\n};\n\nvar widMap = new Map();\n/**\n * Add a wid to a node and make it (easily) non-modifiable.\n * @param  {DOMNode} node Node to set wid on.\n * @param  {string} wid  wid.\n * @public\n */\ncoreUtilsModule.setWidOnElement = function (node, wid) {\n\twidMap.set(wid, node);\n\tObject.defineProperty(node, '__wid', {\n\t\tvalue: wid,\n\t\twritable: false, // No overwriting\n\t\tenumerable: true, // Let iterators and Object.assign see the wid.\n\t\tconfigurable: true // Allow us to redefine it in rare race condition scenarios.\n\t});\n};\n\n/**\n * Remove element from wid map. Bye, bye, memory leak!\n * @param  {string} wid wid.\n * @public\n */\ncoreUtilsModule.removeWidFromElement = function (wid) {\n\treturn widMap.delete(wid);\n};\n\n/**\n * Get element by wid.\n * @param  {string} wid wid.\n * @return {DOMNode}     DOM Element with given wid.\n * @public\n */\ncoreUtilsModule.getElementByWid = function (wid) {\n\treturn widMap.get(wid);\n};\n\nmodule.exports = coreUtilsModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreUtils.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreUtils.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar coreEventsModule = {};\n\n// Map from event names to a set of the actual listeners: string -> set of listeners.\nvar eventListeners = {};\n// Map from event names to actual listeners: string -> function.\nvar addEventListenerListeners = {};\n// Map from event names to actual listeners: string -> function.\nvar removeEventListenerListeners = {};\n\nvar priorities = {\n\tIMMEDIATE: 0,\n\tHIGH: 1,\n\tMEDIUM: 2,\n\tLOW: 3,\n\tLAST: 4\n};\n\ncoreEventsModule.PRIORITY = new Proxy(priorities, {\n\tget: function get(target, name) {\n\t\tif (name in target) return target[name];\n\t\tthrow new Error('Invalid priority ' + name);\n\t}\n});\n\n/**\n* Create new event.\n* @param  {string}  eventName  Event name.\n* @param  {object} options     An object of options:\n*                              idempotent:      Whether we allow the same event to be created\n*                                               multiple times without throwing an error.\n*                              addListener:     A callback to be triggered when an eventListener\n*                                               gets added.\n*                              removeListener:  A callback to be triggered when an eventListener\n*                                               gets added.\n\n* @public\n*/\ncoreEventsModule.createEvent = function (eventName) {\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\tif (coreEventsModule.eventExists(eventName) && !options.idempotent) {\n\t\tthrow new Error('Event ' + eventName + ' already exists.');\n\t}\n\n\tif (typeof options.addListener !== 'undefined') {\n\t\tif (typeof options.addListener !== 'function') {\n\t\t\tthrow new Error('addListener must be a function, received: ' + options.addListener + '.');\n\t\t}\n\t\taddEventListenerListeners[eventName] = options.addListener;\n\t}\n\n\tif (typeof options.removeListener !== 'undefined') {\n\t\tif (typeof options.removeListener !== 'function') {\n\t\t\tthrow new Error('removeListener must be a function, received: ' + options.removeListener + '.');\n\t\t}\n\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t}\n\n\tif (!eventListeners[eventName]) {\n\t\teventListeners[eventName] = new Set();\n\t}\n};\n\ncoreEventsModule.eventExists = function (eventName) {\n\treturn eventListeners.hasOwnProperty(eventName);\n};\n\ncoreEventsModule.addEventListener = function (eventName, eventListener) {\n\tvar priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coreEventsModule.PRIORITY.LOW;\n\tvar options = arguments[3];\n\n\n\teventListener.priority = priority;\n\tif (!coreEventsModule.eventExists(eventName)) {\n\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t}\n\n\tif (eventListeners[eventName].has(eventListener)) {\n\t\tthrow new Error('EventListener already attacehd to ' + eventName + '.');\n\t}\n\teventListeners[eventName].add(eventListener);\n\tif (addEventListenerListeners[eventName]) {\n\t\taddEventListenerListeners[eventName](eventListener);\n\t}\n};\n\ncoreEventsModule.removeEventListener = function (eventName, eventListener) {\n\tif (!coreEventsModule.eventExists(eventName)) {\n\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t}\n\teventListeners[eventName].delete(eventListener);\n\tif (removeEventListenerListeners[eventName]) {\n\t\tremoveEventListenerListeners[eventName](eventListener);\n\t}\n};\n\ncoreEventsModule.triggerEvent = function (eventName) {\n\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\targs[_key - 1] = arguments[_key];\n\t}\n\n\tif (!coreEventsModule.eventExists(eventName)) {\n\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t}\n\n\t// Convert set of event listeners to array, so we can sort them.\n\tvar arrEventListeners = Array.from(eventListeners[eventName]);\n\n\t// Sort all events by priority (IMMEDIATE, HIGH, MEDIUM, ... ).\n\tarrEventListeners.sort(function (e, f) {\n\t\treturn e.priority - f.priority;\n\t});\n\n\t// Execute events (in proper order).\n\tarrEventListeners.forEach(function (eventListener) {\n\t\ttry {\n\t\t\t// IMMEDIATE listeners get triggered right now, everything else happens on the next tick.\n\t\t\tif (eventListener.priority === coreEventsModule.PRIORITY.IMMEDIATE) {\n\t\t\t\teventListener.apply(undefined, args);\n\t\t\t} else {\n\t\t\t\t// It is somewhat counter-intuitive that non-IMMEDIATE listeners gets triggered by\n\t\t\t\t// setImmediate. setImmediate means \"immediately after we're done with everything else\".\n\t\t\t\tsetImmediate.apply(undefined, [eventListener].concat(args));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t}\n\t});\n};\n\nmodule.exports = coreEventsModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreEvents.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreEvents.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar coreConfig = __webpack_require__(16);\nvar coreDatabase = __webpack_require__(7);\nvar corePopulator = __webpack_require__(15);\nvar coreUtils = __webpack_require__(0);\n\nvar globalObjectModule = {};\n\n// Public webstrate object\nvar publicObject = {};\n\n// Expose our internal, proxied window and document objects.\nObject.defineProperty(publicObject, 'window', {\n\tget: function get() {\n\t\treturn window;\n\t},\n\tset: function set() {\n\t\tthrow new Error('Internal window object should not be modified');\n\t},\n\t// If enumerable is 'true', Puppeteer tests fail as `window.webstrate` is suddenly undefined\n\t// due to the circular reference.\n\tenumerable: false\n});\n\nObject.defineProperty(publicObject, 'document', {\n\tget: function get() {\n\t\treturn document;\n\t},\n\tset: function set() {\n\t\tthrow new Error('Internal document object should not be modified');\n\t},\n\tenumerable: true\n});\n\nObject.defineProperty(publicObject, 'webstrateId', {\n\tget: function get() {\n\t\treturn coreUtils.getLocationObject().webstrateId;\n\t},\n\tset: function set() {\n\t\tthrow new Error('webstrate ID should not be modified');\n\t},\n\tenumerable: true\n});\n\n// Every webstrate object needs a unique ID. Let's just go with 'document' for the global object.\nObject.defineProperty(publicObject, 'id', {\n\tget: function get() {\n\t\treturn 'document';\n\t},\n\tset: function set() {\n\t\tthrow new Error('node ID should not be modified');\n\t},\n\tenumerable: true\n});\n\nObject.defineProperty(publicObject, 'isStatic', {\n\tget: function get() {\n\t\treturn coreUtils.getLocationObject().staticMode;\n\t},\n\tset: function set() {\n\t\tthrow new Error('isStatic cannot be modified.');\n\t},\n\tenumerable: true\n});\n\nObject.defineProperty(publicObject, 'config', { value: coreConfig });\n\nglobalObjectModule.publicObject = publicObject;\n\n// Map from event names to a set of the actual listeners: string -> set of listeners.\nvar eventListeners = {};\n// Map from event names to actual listeners: string -> function.\nvar addEventListenerListeners = {};\n// Map from event names to actual listeners: string -> function.\nvar removeEventListenerListeners = {};\n\nfunction eventExists(eventName) {\n\treturn eventListeners.hasOwnProperty(eventName);\n}\n\nglobalObjectModule.createEvent = function (eventName) {\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\tif (eventExists(eventName) && !options.idempotent) {\n\t\tthrow new Error('Event ' + eventName + ' already exists.');\n\t}\n\n\tif (typeof options.addListener !== 'undefined') {\n\t\tif (typeof options.addListener !== 'function') {\n\t\t\tthrow new Error('addListener must be a function, received: ' + options.addListener);\n\t\t}\n\t\taddEventListenerListeners[eventName] = options.addListener;\n\t}\n\n\tif (typeof options.removeListener !== 'undefined') {\n\t\tif (typeof options.removeListener !== 'function') {\n\t\t\tthrow new Error('removeListener must be a function, received: ' + options.removeListener);\n\t\t}\n\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t}\n\n\tif (!eventExists(eventName)) {\n\t\teventListeners[eventName] = new Set();\n\t}\n};\n\nglobalObjectModule.triggerEvent = function (eventName) {\n\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\targs[_key - 1] = arguments[_key];\n\t}\n\n\tif (!eventExists(eventName)) {\n\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t}\n\teventListeners[eventName].forEach(function (eventListener) {\n\t\tsetImmediate.apply(undefined, [eventListener].concat(args));\n\t});\n};\n\npublicObject.on = function (eventName, eventListener) {\n\tif (!eventExists(eventName)) {\n\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t}\n\teventListeners[eventName].add(eventListener);\n\tif (addEventListenerListeners[eventName]) {\n\t\taddEventListenerListeners[eventName](eventListener);\n\t}\n};\n\npublicObject.off = function (eventName, eventListener) {\n\tif (!eventExists(eventName)) {\n\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t}\n\teventListeners[eventName].delete(eventListener);\n\tif (removeEventListenerListeners[eventName]) {\n\t\tremoveEventListenerListeners[eventName](eventListener);\n\t}\n};\n\n/**\n * Restore document to a previous version, either by version number or tag label.\n * Labels cannot begin with a digit whereas versions consist only of digits, so distinguishing\n * is easy.\n * @param  {string} tagOrVersion Tag label or version number.\n */\npublicObject.restore = function (tagOrVersion, callback) {\n\tif (publicObject.isStatic) {\n\t\tcoreDatabase.fetch(publicObject.webstrateId, tagOrVersion).then(function (doc) {\n\t\t\tcorePopulator.populate(document, doc);\n\t\t\tcallback();\n\t\t});\n\t} else {\n\t\tcoreDatabase.restore(publicObject.webstrateId, tagOrVersion, callback);\n\t}\n};\n\n/**\n * Get a range of ops from the document.\n * @param  {Number}   fromVersion Version to start the op range from (inclusive).\n * @param  {Number}   toVersion   Version to end the op range at (exclusive).\n * @param  {Function} callback    Callback.\n * @return {Array}                (async) Array of ops in the range.\n */\npublicObject.getOps = function (fromVersion, toVersion, callback) {\n\tcoreDatabase.getOps(publicObject.webstrateId, fromVersion, toVersion, callback);\n};\n\nwindow.webstrate = publicObject;\nmodule.exports = globalObjectModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/globalObject.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/globalObject.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar coreUtils = __webpack_require__(0);\nvar globalObject = __webpack_require__(2);\n\nvar coreWebsocketModule = {};\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\nvar url = void 0,\n    protocols = void 0,\n    websocket = void 0,\n    forceClose = void 0,\n    reconnectAttempts = void 0;\nvar copies = [];\n\n// If somebody tries to send a message with websocket.sendWhenReady while we're not connected, we\n// queue the message to be sent once connected. This is that queue. Once a queue has been drained,\n// we reinitialize it to a new list, so we can't use const.\nvar queue = [];\n\n// A map from tokens to callback functions: str -> fn.\nvar callbacks = new Map();\n\n/**\n * Calculates increasing reconnection delay based on number of reconnection attempts:\n * Starting with: 1s, 1.5s, 2.3s, 3.4s, 5.0s, 7.6s, 11.4s, 17.0s, 25.6s, 38.4s, 57.7s, etc.\n * @return {Number} Next reconnection interval in seconds.\n * @private\n */\nfunction reconnectDelay() {\n\treturn 1000 * Math.pow(1.5, reconnectAttempts++);\n}\n\n// Having multiple subscriptions to the same webstrate causes ShareDB to behave oddly and cut\n// off parts of operations for (so far) unknown reasons. As a result, getDocument() above will\n// return nothing if a subcription to the document already exists.\nvar subscriptions = new Set();\nObject.defineProperty(globalObject.publicObject, 'getWebsocket', {\n\tvalue: function value(filter, webstrateId) {\n\t\tif (typeof filter === 'string') {\n\t\t\twebstrateId = filter;\n\t\t}\n\t\tif (subscriptions.has(webstrateId)) return;\n\t\tsubscriptions.add(webstrateId);\n\t\treturn coreWebsocketModule.copy();\n\t}\n});\n\ncoreWebsocketModule.setup = function (_url, _protocols) {\n\n\turl = _url;\n\tprotocols = _protocols;\n\n\tif (coreUtils.isTranscluded() && coreUtils.sameParentDomain() && config.reuseWebsocket) {\n\t\twebsocket = window.parent.window.webstrate.getWebsocket(webstrateId);\n\t}\n\n\t// Even if we're transcluded, we won't succeed in getting a websocket from our parent if another\n\t// subscription on the same webstrate already exists.\n\tif (!websocket || websocket.readyState === WebSocket.CLOSED) {\n\t\twebsocket = new WebSocket(url, protocols);\n\t}\n\n\tforceClose = false;\n\n\twebsocket.onopen = function (event) {\n\t\t// Drain queue and empty it.\n\t\tqueue.forEach(function (data) {\n\t\t\treturn websocket.send(data);\n\t\t});\n\t\tqueue = [];\n\n\t\treconnectAttempts = 0;\n\t\tcopies.forEach(function (_ref) {\n\t\t\tvar websocket = _ref.websocket;\n\t\t\treturn typeof websocket.onopen === 'function' && websocket.onopen(event);\n\t\t});\n\t};\n\n\twebsocket.onclose = function (event) {\n\t\tcopies.forEach(function (_ref2) {\n\t\t\tvar websocket = _ref2.websocket;\n\t\t\treturn typeof websocket.onclose === 'function' && websocket.onclose(event);\n\t\t});\n\n\t\tif (!forceClose) {\n\t\t\treconnectAttempts++;\n\t\t\tsetTimeout(function () {\n\t\t\t\tcoreWebsocketModule.setup(url, protocols);\n\t\t\t}, reconnectDelay());\n\t\t}\n\t};\n\n\twebsocket.onconnecting = function (event) {\n\t\tcopies.forEach(function (_ref3) {\n\t\t\tvar websocket = _ref3.websocket;\n\t\t\treturn typeof websocket.onconnecting === 'function' && websocket.onconnecting(event);\n\t\t});\n\t};\n\n\twebsocket.onmessage = function (event) {\n\t\tvar parsedData = void 0;\n\n\t\t// If the message has a reply attached, it means it's an answer to a specific request, and not\n\t\t// something that should just be sent to everybody. Therefore, we find the requester in the\n\t\t// callback map, call the callback function, and then terminate.\n\t\tif (event.data.startsWith('{\"wa\":\"reply\"')) {\n\t\t\tparsedData = JSON.parse(event.data);\n\t\t\tvar token = parsedData.token;\n\t\t\tif (token && callbacks.has(token)) {\n\t\t\t\tvar callback = callbacks.get(token);\n\t\t\t\tcallbacks.delete(token);\n\t\t\t\tcallback(parsedData.error, parsedData.reply);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tcopies.forEach(function (_ref4) {\n\t\t\tvar websocket = _ref4.websocket,\n\t\t\t    filter = _ref4.filter;\n\n\t\t\tif (!filter || filter(event)) {\n\t\t\t\tif (typeof websocket.onmessage === 'function') {\n\t\t\t\t\twebsocket.onmessage(event);\n\t\t\t\t}\n\t\t\t\t// As an optimization, we add a custom onjsonmessage event to websockets, so every websocket\n\t\t\t\t// copy doesn't have to parse the same data.\n\t\t\t\tif (typeof websocket.onjsonmessage === 'function') {\n\t\t\t\t\tif (parsedData === undefined) {\n\t\t\t\t\t\tparsedData = Object.freeze(JSON.parse(event.data));\n\t\t\t\t\t}\n\t\t\t\t\twebsocket.onjsonmessage(parsedData);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\twebsocket.onerror = function (event) {\n\t\tcopies.forEach(function (_ref5) {\n\t\t\tvar websocket = _ref5.websocket;\n\t\t\treturn typeof websocket.onerror === 'function' && websocket.onerror(event);\n\t\t});\n\t};\n};\n\n/**\n * Get a copy of the websocket, allowing modules to treat it like their own and overwrite onopen,\n * onmessage, etc. without fear of overwriting other modules' callbacks.\n * @param  {function} filter A filter function, allowing users to filter messages before receiving\n *                           them.\n * @return {WebSocket}       A WebSocket (almost up to specification).\n * @public\n */\ncoreWebsocketModule.copy = function (filter) {\n\n\tvar copy = {\n\t\tsend: coreWebsocketModule.send,\n\t\tclose: function close() {\n\t\t\tforceClose = true;\n\t\t\twebsocket.close();\n\t\t},\n\t\trefresh: function refresh() {\n\t\t\twebsocket.close();\n\t\t},\n\t\turl: url,\n\t\tURL: url,\n\t\tprotocols: protocols,\n\t\tget readyState() {\n\t\t\treturn websocket.readyState;\n\t\t}\n\t};\n\n\tcopies.push({ websocket: copy, filter: filter });\n\treturn copy;\n};\n\n/**\n * Send messages through the websocket. This is possible both directly through coreWebsocket.send\n * (as defined here) or through a websocket copy. Some modules may not need the websocket for more\n * than sending a message, in which case there's no reason to create a copy.\n * The method signature does not exactly adhere to the specification.\n * @param  {mixed}   data      The data to be sent. According to the specification, this should be\n *                             string, but we allow objects as well, which we then stringify.\n * @param  {Function} callback A callback function to be called when the server replies to the\n *                             message. This is done by attaching a token to the message and having\n *                             the server reply with the same token.\n * @param  {Object}   options  Allows setting certain properties. Currently only `waitForOpen`.\n *                             When set, if somebody tries to send a message over the websocket\n *                             before it has been opened, the message gets queued to be sent once\n *                             connected.\n * @public\n */\ncoreWebsocketModule.send = function (data, callback) {\n\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t// Allow the user to specify a callback to be called when the server replies. This requires\n\t// the server to implment the token functionality as well, so it must be used with care, as\n\t// not all type of messages can handle callbacks.\n\tif (typeof callback === 'function') {\n\t\tif (typeof data === 'string') {\n\t\t\tdata = JSON.parse(data);\n\t\t}\n\t\tvar token = coreUtils.randomString();\n\t\tdata.token = token;\n\t\tcallbacks.set(token, callback);\n\t}\n\n\t// If we attempt to send an object, we convert it to JSON first. This isn't part of the\n\t// WebSocket specification, but it's nice to have.\n\tif ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n\t\tdata = JSON.stringify(data);\n\t}\n\n\t// Always send the message if we can. If we can't, try anyway, or if waitForOpen is specified,\n\t// add it to a queue for it to be sent later.\n\tif (websocket.readyState === WebSocket.OPEN || !options.waitForOpen) {\n\t\twebsocket.send(data);\n\t} else {\n\t\tqueue.push(data);\n\t}\n};\n\nmodule.exports = coreWebsocketModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreWebsocket.js\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreWebsocket.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = {\n\tVERBOSE_MODE: false,\n\tmodules: ['globalObject', 'loadedEvent', 'userObject', 'cookies', 'nodeObjects', 'protectedMode', 'databaseErrors', 'dataSavedEvent', 'domEvents', 'transclusionEvent', 'connectionEvents', 'permissions', 'tagging', 'clientManager', 'newWebstrates', 'signaling', 'signalStream', 'userObjectSignaling', 'userHistory', 'assets', 'messages', 'keepAlive'],\n\t// Reuse the parent's websocket when doing transclusion. Very experimental.\n\treuseWebsocket: false,\n\t// Keep alive message interval in seconds. A falsy value disables keep alive.\n\tkeepAliveInterval: 25,\n\t// Supports selector syntax, i.e. 'div.not-persisted' to not persist all DIV elements with the\n\t// class 'not-persisted'.\n\tisTransientElement: function isTransientElement(DOMNode) {\n\t\treturn DOMNode.matches('transient');\n\t},\n\t// Any attributeName starting with 'transient-' should be transient.\n\tisTransientAttribute: function isTransientAttribute(DOMNode, attributeName) {\n\t\treturn attributeName.startsWith('transient-');\n\t},\n\t// Peer Connection configuration used for the WebRTC-based signal streaming.\n\tpeerConnectionConfig: {\n\t\t'iceServers': [{ urls: 'stun:stun.services.mozilla.com' }, { urls: 'stun:stun.l.google.com:19302' }]\n\t}\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/config.js\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/config.js?")},function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(55);\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || undefined && undefined.setImmediate;\nexports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || undefined && undefined.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 5\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/timers-browserify/main.js?')},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * This modules allows other modules a more convenient way of overriding certain document\n * properties, specifically by preventing accidental infinite recursive calls and scope-binding\n * issues. On top of that, it allows modules  to override certain properties only internally, i.e.\n * so other modules will use some overriden property (e.g. document.createElement), while code\n * written in userland still will use the \"regular\" document.createElement.\n *\n * This module was particularly written to be used with protected mode, so elements created by\n * other modules automatically will be pre-approved while elements created in userland will not.\n */\n\n// Directives to ESLint, so it'll allow us to use documentProxyObj and _document, which appears to\n// be undefined, as they rather unorthodoxly is defined in wrapper-header.js. Also prevent ESLint\n// from complaining that documentProxyObj is never used.\n/* global _document documentProxyObj */\n/* exported documentProxyObj */\n\nvar coreDOMModule = {};\n\n// This object should be passed in as the last parameter by all other modules to Element\n// prototype methods, so all modules can detect when a call to one of these comes from another\n// module rather than from userland. It would be better to override the Element object like we\n// override the document object, but it seems to be impossible to do this meaningfully.\ncoreDOMModule.elementOptions = {};\n\ncoreDOMModule.internalDocument = document;\ncoreDOMModule.externalDocument = _document;\n\nvar contexts = {\n\tINTERNAL: 0,\n\tBOTH: 1\n};\n\ncoreDOMModule.CONTEXT = new Proxy(contexts, {\n\tget: function get(target, name) {\n\t\tif (name in target) return target[name];\n\t\tthrow new Error('Invalid context ' + name + ', must be INTERNAL or BOTH');\n\t}\n});\n\nvar internalDocumentOverrides = new Map();\n\n/**\n * Override a property on the document object, either internally or internally and externally.\n * @param  {string} property Name of property to override on document.\n * @param  {enum} context    Context, either CONTEXT.INTERNAL or CONTEXT.BOTH.\n * @param  {any} value       Any value.\n * @public\n */\ncoreDOMModule.overrideDocument = function (property, context, value) {\n\t// If the user is trying to override a property on the internal document, we save the property to\n\t// a map, so we can find it when it's being requested on the proxy document. If we did a\n\t// 'primitive' override on the document object, the override would also be active\n\tif (context === coreDOMModule.CONTEXT.INTERNAL) {\n\t\tif (internalDocumentOverrides.has(property)) throw new Error('Property has already been overriden');\n\n\t\treturn internalDocumentOverrides.set(property, value);\n\t}\n\n\tif (context === coreDOMModule.CONTEXT.BOTH) {\n\t\tif (typeof value === 'function') {\n\t\t\t// If the requested value is a function, bind the document's context to it and bind the\n\t\t\t// original function as the first argument. This, for instance, allows somebody to override\n\t\t\t// document.createElement and still have access to the original createElement function from\n\t\t\t// within the new implementation.\n\t\t\tvar originalProperty = coreDOMModule.externalDocument[property].bind(coreDOMModule.externalDocument);\n\t\t\tcoreDOMModule.externalDocument[property] = value.bind(coreDOMModule.externalDocument, originalProperty);\n\t\t} else {\n\t\t\tcoreDOMModule.externalDocument[property] = value;\n\t\t}\n\t\treturn;\n\t}\n\n\tthrow new Error('Invalid context', context);\n};\n\n/**\n * Proxy object for document. The proxy is actually defined in wrapper-header.js using an empty\n * object (documentProxyObj), which we now override with our own get trap.\n * @param  {Object} obj  Object the property is to be accessed on. Will always be document.\n * @param  {string} prop Name of property.\n * @return {mixed}       The property's value. Can be anything.\n */\ndocumentProxyObj.get = function (obj, prop) {\n\tif (prop === 'PROXY_DOCUMENT') return true;\n\n\tif (internalDocumentOverrides.has(prop)) {\n\t\t// If the requested value is a function, bind the document's context to it and bind the\n\t\t// original function as the first argument. This, for instance, allows somebody to override\n\t\t// document.createElement and still have access to the original createElement function from\n\t\t// within the new implementation.\n\t\treturn typeof internalDocumentOverrides.get(prop) === 'function' ? internalDocumentOverrides.get(prop).bind(obj, coreDOMModule.externalDocument[prop]) : internalDocumentOverrides.get(prop);\n\t}\n\n\t// If the requested value is a function, bind the document's context to it.\n\treturn typeof obj[prop] === 'function' ? obj[prop].bind(obj) : obj[prop];\n};\n\nmodule.exports = coreDOMModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreDOM.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreDOM.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\nvar sharedb = __webpack_require__(57);\nvar COLLECTION_NAME = 'webstrates';\n\ncoreEvents.createEvent('receivedDocument');\ncoreEvents.createEvent('receivedOps');\ncoreEvents.createEvent('databaseError');\ncoreEvents.createEvent('opsAcknowledged');\n\nvar doc = void 0,\n    conn = void 0;\n\n/**\n * Get the ShareDB document, or get an element at a certain path in the document if a path is\n * provided.\n * @param  {Array} path  (optional) Path into the ShareDB document.\n * @return {mixed}       ShareDB document object or a path into the document.\n * @public\n */\nexports.getDocument = function (path) {\n\tif (!path || !Array.isArray(path)) return doc;\n\treturn path.reduce(function (doc, path) {\n\t\treturn doc && doc[path];\n\t}, doc.data);\n};\n\n/**\n * Get the element at a given path in a JsonML document.\n * @param  {JsonMLPath} path Path to follow in snapshot.\n * @return {JsonML}          Element at path in snapshot.\n * @public\n */\nexports.elementAtPath = function (snapshot, path) {\n\t// Snapshot is optional (and only used in the internal recursion).\n\tif (!path) {\n\t\tpath = snapshot;\n\t\tsnapshot = doc.data;\n\t}\n\n\tif (path.length > 0 && typeof path[path.length - 1] === 'string') {\n\t\treturn null;\n\t}\n\n\tvar _path = path,\n\t    _path2 = _toArray(_path),\n\t    head = _path2[0],\n\t    tail = _path2.slice(1);\n\n\tif (!head || !snapshot[head]) {\n\t\treturn snapshot;\n\t}\n\n\treturn exports.elementAtPath(snapshot[head], tail);\n};\n\n// Having multiple subscriptions to the same webstrate causes ShareDB to behave oddly and cut\n// off parts of operations for (so far) unknown reasons. As a result, getDocument will return\n// nothing if a subcription to the document already exists.\nvar subscriptions = new Set();\nObject.defineProperty(globalObject.publicObject, 'getDocument', {\n\tvalue: function value(webstrateId) {\n\t\t// In case this document is transcluded as well, we recursively ask the parent for the document.\n\t\tif (!conn) {\n\t\t\treturn window.parent.window.webstrate.getDocument(webstrateId);\n\t\t}\n\n\t\tif (subscriptions.has(webstrateId)) return;\n\t\tsubscriptions.add(webstrateId);\n\t\treturn conn.get(COLLECTION_NAME, webstrateId);\n\t}\n});\n\nexports.subscribe = function (webstrateId) {\n\treturn new Promise(function (resolve, reject) {\n\t\t// Check if we can reuse the ShareDB Database connection from a parent if we're in an iframe.\n\t\tif (coreUtils.isTranscluded() && coreUtils.sameParentDomain() && config.reuseWebsocket) {\n\t\t\tdoc = window.parent.window.webstrate.getDocument(webstrateId);\n\t\t}\n\n\t\t// Even if we're transcluded, we won't succeed in getting a document from our parent if another\n\t\t// subscription on the same webstrate already exists.\n\t\tif (!doc) {\n\t\t\t// Filter out our own messages. This could be done more elegantly by parsing the JSON object\n\t\t\t//  and\n\t\t\t// then checking if the \"wa\" property exists, but this is a lot faster.\n\t\t\t// This filter is passed to coreWebsocket.copy() when getting a copy of a websocket.\n\t\t\t// @param  {obj} event  Websocket onmessage event.\n\t\t\t// @return {bool}       Whether the message should be let through to ShareDB.\n\t\t\tvar websocket = coreWebsocket.copy(function (event) {\n\t\t\t\treturn !event.data.startsWith('{\"wa\":');\n\t\t\t});\n\n\t\t\t// Create a new ShareDB connection.\n\t\t\tconn = new sharedb.Connection(websocket);\n\n\t\t\t// Get ShareDB document for webstrateId.\n\t\t\tdoc = conn.get(COLLECTION_NAME, webstrateId);\n\t\t}\n\n\t\t// Subscribe to remote operations (changes to the ShareDB document).\n\t\tdoc.subscribe(function (error) {\n\t\t\tif (error) {\n\t\t\t\treturn reject(error);\n\t\t\t}\n\n\t\t\tcoreEvents.triggerEvent('receivedDocument', doc, { static: false });\n\n\t\t\t// Generate a unique ID for this document client.\n\t\t\tvar source = coreUtils.randomString();\n\n\t\t\tcoreEvents.addEventListener('createdOps', function (ops) {\n\t\t\t\tdoc.submitOp(ops, { source: source });\n\t\t\t}, coreEvents.PRIORITY.IMMEDIATE);\n\n\t\t\tdoc.on('op', function (ops, opsSource) {\n\t\t\t\t// We don't broadcast a 'receivedOps' event for ops we create ourselves, as we haven't\n\t\t\t\t// received them from anybody.\n\t\t\t\tif (opsSource !== source) {\n\t\t\t\t\tcoreEvents.triggerEvent('receivedOps', ops);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// This event gets triggered after all ops have been successfully been received by the\n\t\t\t// server and submitted to the database. There's 'nothing pending' in the submission queue.\n\t\t\t// If a user is making changes to the DOM, we can't guarantee that they have been recorded\n\t\t\t// after this event has happened.\n\t\t\tdoc.on('nothing pending', function () {\n\t\t\t\tcoreEvents.triggerEvent('opsAcknowledged');\n\t\t\t});\n\n\t\t\tdoc.on('error', function (error) {\n\t\t\t\t// ShareDB error code 4018 (Document was created remotely) triggers happens when multiple\n\t\t\t\t// clients try to create the same webstrate at the same time. It doesn't matter, so we\n\t\t\t\t// suppress it.\n\t\t\t\tif (error.code === 4018) return;\n\t\t\t\tconsole.error(error);\n\t\t\t\tcoreEvents.triggerEvent('databaseError', error);\n\t\t\t});\n\n\t\t\tresolve(doc);\n\t\t});\n\t});\n};\n\nexports.fetch = function (webstrateId, tagOrVersion) {\n\treturn new Promise(function (resolve, reject) {\n\t\tvar msgObj = {\n\t\t\twa: 'fetchdoc',\n\t\t\td: webstrateId\n\t\t};\n\n\t\tif (/^\\d/.test(tagOrVersion) && Number(tagOrVersion)) {\n\t\t\tmsgObj.v = Number(tagOrVersion);\n\t\t} else {\n\t\t\tmsgObj.l = tagOrVersion;\n\t\t}\n\n\t\t// The second parameter is `sendWhenReady` and true means to queue the message until the\n\t\t// websocket is open rather than to throw and error if the websocket isn't ready. This is not\n\t\t// part of the WebSocket specification, but has been implemented in coreWebsocket anyway.\n\t\tcoreWebsocket.send(msgObj, function (err, doc) {\n\t\t\tif (err) return reject(err);\n\t\t\tcoreEvents.triggerEvent('receivedDocument', doc, { static: true });\n\t\t\tresolve(doc);\n\t\t}, { waitForOpen: true });\n\t});\n};\n\n/**\n * Restore document to a previous version, either by version number or tag label.\n * Labels cannot begin with a digit whereas versions consist only of digits, so distinguishing\n * is easy.\n * This does not return a promise, as we do not have control over exactly when the document gets\n * reverted as this is ShareDB's job.\n * @param  {string} tagOrVersion Tag label or version number.\n */\nexports.restore = function (webstrateId, tagOrVersion) {\n\tvar msgObj = {\n\t\twa: 'restore',\n\t\td: webstrateId\n\t};\n\n\tif (/^\\d/.test(tagOrVersion)) {\n\t\tmsgObj.v = tagOrVersion;\n\t} else {\n\t\tmsgObj.l = tagOrVersion;\n\t}\n\n\tcoreWebsocket.send(msgObj);\n};\n\n/**\n * Get a range of ops from a specific webstrate.\n * @param  {string}   webstrateId Webstrate to get ops from .\n * @param  {Number}   fromVersion Version to start the op range from (inclusive).\n * @param  {Number}   toVersion   Version to end the op range at (exclusive).\n * @param  {Function} callback    Callback.\n * @return {Array}                (async) Array of ops in the range.\n */\nexports.getOps = function (webstrateId, fromVersion, toVersion, callback) {\n\tcoreWebsocket.send({\n\t\twa: 'getOps',\n\t\td: webstrateId,\n\t\tfrom: fromVersion,\n\t\tto: toVersion\n\t}, callback);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreDatabase.js\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreDatabase.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar coreUtils = __webpack_require__(0);\n/*\nWebstrates PathTree (webstrates.pathree.js)\n\nPathTree is a tree data structure mapping to the DOM, but with some extended attributes. Each node\nin a PathTree consists of a unique id, a list of children, a parent, and the node's mapped DOM\nelement.\n\nThe primary purposes of the PathTree are to:\n  1) Maintain a copy of the DOM tree's structure pre-mutation, so operations on the pre-mutation DOM\n     tree can be rewritten to work on the post-mutation DOM tree.\n  2) Facilitate lightweight creation of JsonML which is used when creating operations that are to be\n     sent to the Webstrates server.\n  3) Allow for verifying the integrity of the document by comparing every DOM node to its respective\n     PathTree node.\n*/\n\n/**\n * Generate a unique identifier (UUID4).\n * @return {UUID}\n */\nfunction generateUUID() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\tvar r = Math.random() * 16 | 0;\n\t\tvar v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Create a PathTree from a DOM element. If a parentPathTree is provided, the created\n * PathTree will be a subtree of the parent.\n * @param {DOMNode} DOMNode\tDOMNode to create PathTree from.\n * @param {PathTree} parentPathTree\tPathTree to add as parent.\n * @param {bool} overwrite\tWhether existing PathTree on the DOMNode should be overwritten by the\n * new PathTree or just appended to it.\n * @return {PathTree} Created PathTree.\n */\nfunction PathTree(DOMNode, parentPathTree, overwrite) {\n\tthis.id = generateUUID();\n\tthis.children = [];\n\tthis.parent = parentPathTree;\n\tthis.DOMNode = DOMNode;\n\n\t// When moving an element around, a node may exist in two places at once for a brief moment.\n\t// __pathNodes therefore has to be a list.\n\tif (overwrite || !DOMNode.__pathNodes || DOMNode.__pathNodes.length === 0) {\n\t\tDOMNode.__pathNodes = [this];\n\t} else {\n\t\tDOMNode.__pathNodes.push(this);\n\t}\n\n\tvar childNodes = DOMNode.hasChildNodes() ? DOMNode.childNodes : DOMNode.content && DOMNode.content.childNodes || [];\n\tArray.from(childNodes).forEach(function (childNode) {\n\t\tvar childPathNode = PathTree.create(childNode, this, overwrite);\n\t\tif (childPathNode) {\n\t\t\tthis.children.push(childPathNode);\n\t\t}\n\t}.bind(this));\n}\n\n/**\n * Check whether a DOM Node should be persisted on the server (i.e. whether it's transient or not).\n * For a DOM Node to be transient, it has to be an element (i.e. not a text node), exist outside of\n * a template tag, as well as not be in the list of transient elements (config.transientElements).\n * @param  {DOMNode} DOMNode DOM Node to check.\n * @return {boolean}         True if the DOM Node is transient.\n * @private\n */\nfunction isTransientElement(DOMNode) {\n\t// Only elements can be transient\n\treturn DOMNode.nodeType === document.ELEMENT_NODE\n\t// Nothing in templates can be transient\n\t&& !coreUtils.elementIsTemplateDescendant(DOMNode)\n\t// Only elements passing a function defined in config.isTransientElement are transient.\n\t&& config.isTransientElement && config.isTransientElement(DOMNode);\n}\n\n/**\n * Add PathNode to node if the node isn't a <transient> element.\n * @param  {[type]} DOMNode        [description]\n * @param  {[type]} parentPathTree [description]\n * @param  {[type]} overwrite      [description]\n * @return {[type]}                [description]\n */\nPathTree.create = function (DOMNode, parentPathTree, overwrite) {\n\t// Transient elements are not supposed to be persisted, and should thus not be part of the\n\t// PathTree. Unless the transient element is in a <template>.\n\tif (isTransientElement(DOMNode) || !parentPathTree && DOMNode !== document.documentElement) {\n\t\treturn;\n\t}\n\n\treturn new PathTree(DOMNode, parentPathTree, overwrite);\n};\n/**\n * Creates a JsonML representation of the PathTree.\n * @return {JsonML} JsonML representation of PathTree.\n */\nPathTree.prototype.toPath = function () {\n\tif (!this.parent) {\n\t\treturn [];\n\t}\n\n\tvar childIndex = this.parent.children.findIndex(function (sibling) {\n\t\treturn sibling.id === this.id;\n\t}.bind(this));\n\n\t// In the JsonML representation, the list elements start at position 2 in the object:\n\t//   [tag-name, attributes, ...element-list]\n\tvar ELEMENT_LIST_OFFSET = 2;\n\treturn [].concat(_toConsumableArray(this.parent.toPath()), [ELEMENT_LIST_OFFSET + childIndex]);\n};\n\n/**\n * Remove a PathTree by removing itself from parent as well as removing all children.\n * @param {bool} shallow Does not remove itself from parent if true (deletion if shallow).\n * @return {PathTree}    The deleted PathTree, consisting only of an object with an id.\n */\nPathTree.prototype.remove = function (shallow) {\n\t// TODO: Why can't we do this EVERY time? If we do this on the children as well, the integrity\n\t// check fails.\n\tif (!shallow) {\n\t\t// Remove ourselves from our parent.\n\t\tthis.parent.children.splice(this.parent.children.indexOf(this), 1);\n\t}\n\tthis.parent = null;\n\n\t// Remove ourselves from our DOMNode.\n\tthis.DOMNode.__pathNodes.splice(this.DOMNode.__pathNodes.indexOf(this), 1);\n\tthis.DOMNode = null;\n\n\t// Remove all our children.\n\tthis.children.forEach(function (child) {\n\t\tchild.remove(true);\n\t});\n\tthis.children = null;\n};\n\n/**\n * Checks the integrity of the document by recursively comparing the elements of the PathTree to\n * that of the DOM node.\n * @return {Array of results}\n */\nPathTree.prototype.check = function () {\n\tif (this.DOMNode.__pathNodes.length > 1) {\n\t\tconsole.log(this.DOMNode, this.DOMNode.__pathNodes);\n\t\twindow.alert('Webstrates has encountered an error. Please reload the page.');\n\t\tthrow 'Node has multiple paths';\n\t}\n\n\tvar domNodePathNode = this.DOMNode.__pathNodes[0];\n\tif (domNodePathNode.id !== this.id) {\n\t\tconsole.log(this.DOMNode, this);\n\t\twindow.alert('Webstrates has encountered an error. Please reload the page.');\n\t\tthrow 'No id match';\n\t}\n\n\tvar definedChildNodesInDom = function () {\n\t\tvar ref, ref1;\n\t\tref = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes : this.DOMNode.content && this.DOMNode.content.childNodes || [];\n\t\tvar results = [];\n\t\tfor (var j = 0, len = ref.length; j < len; j++) {\n\t\t\tvar childNode = ref[j];\n\t\t\tif (((ref1 = childNode.__pathNodes) != null ? ref1.length : void 0) > 0) {\n\t\t\t\tresults.push(childNode);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}.bind(this)();\n\n\tif (definedChildNodesInDom.length !== this.children.length) {\n\t\tconsole.log(definedChildNodesInDom, this.children, this);\n\t\twindow.alert('Webstrates has encountered an error. Please reload the page.');\n\t\tthrow 'Different amount of children';\n\t}\n\n\tvar childNodes = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes : this.DOMNode.content && this.DOMNode.content.childNodes || [];\n\tchildNodes = Array.from(childNodes).filter(function (childNode) {\n\t\treturn !childNode.tagName || childNode.tagName.toLowerCase() !== 'transient' || coreUtils.elementIsTemplateDescendant(childNode);\n\t});\n\tif (definedChildNodesInDom.length !== childNodes.length) {\n\t\tconsole.log(definedChildNodesInDom, childNodes);\n\t\tconsole.warn('Warning: Found zombie nodes in DOM.');\n\t}\n\n\tvar results = [];\n\tfor (var i = 0, j = 0, len = definedChildNodesInDom.length; j < len; i = ++j) {\n\t\tresults.push(this.children[i].check());\n\t}\n\n\treturn results;\n};\n\n/**\n * Returns the last added pathNode of an element. If a parent DOM element is provided, we search\n * for the pathNode that matches on parent.\n * @param  {DOMNode} elem       Element to get pathNode of.\n * @param  {DOMNode} parentElem Parent of Element (optional).\n * @return {PathTree}           PathNode found or null.\n */\nPathTree.getPathNode = function (elem, parentElem) {\n\tif (!elem || !elem.__pathNodes) {\n\t\treturn null;\n\t}\n\n\tif (!parentElem || !parentElem.__pathNodes) {\n\t\treturn elem.__pathNodes[elem.__pathNodes.length - 1];\n\t}\n\n\tvar matchingElement = null;\n\tparentElem.__pathNodes.some(function (parentPathNode) {\n\t\treturn matchingElement = elem.__pathNodes.find(function (pathNode) {\n\t\t\treturn pathNode.parent.id === parentPathNode.id;\n\t\t});\n\t});\n\n\treturn matchingElement;\n};\n\nvar jsonml = {\n\tTAG_NAME_INDEX: 0,\n\tATTRIBUTE_INDEX: 1,\n\tELEMENT_LIST_OFFSET: 2\n};\n\n/**\n * Returns the DOM element at the end of the path.\n * @param  {HTMLElement|PathTree} parentElement The element used to nagivate to the path from. May\n *                                              be either a DOM element or a PathTree.\n * @param  {JsonMLPath} path                    Path to follow on parentElement.\n * @return {[DOMElement, int, DOMElement, int]} The DOM element found, including its index on its\n *                                              parent, the parent DOM element, as possibly a\n *                                              JsonML index in case the path doesn't at a DOM\n *                                              element (it may end at a tag name or attribute\n *                                              object).\n */\nPathTree.elementAtPath = function (parentElement, path) {\n\tvar parentPathNode = parentElement instanceof PathTree ? parentElement : PathTree.getPathNode(parentElement);\n\n\tvar jsonmlIndex = path[0];\n\tif (jsonmlIndex === jsonml.ATTRIBUTE_INDEX) {\n\t\t// An attribute's parent could arguably be the element it's defined on, so the childElement\n\t\t// and parentElement are the same. Therefore, there also can't be a childIndex.\n\t\treturn [parentElement, undefined, parentElement, jsonmlIndex];\n\t}\n\n\tvar childIndex = jsonmlIndex - jsonml.ELEMENT_LIST_OFFSET;\n\tvar childPathNode = parentPathNode && parentPathNode.children[childIndex];\n\n\tvar nextJsonmlIndex = path[1];\n\tif (path.length === 1 || nextJsonmlIndex === jsonml.TAG_NAME_INDEX || nextJsonmlIndex === jsonml.ATTRIBUTE_INDEX) {\n\t\tvar childElement = childPathNode && childPathNode.DOMNode;\n\t\tparentElement = parentPathNode.DOMNode;\n\t\treturn [childElement, childIndex, parentElement, nextJsonmlIndex];\n\t}\n\treturn PathTree.elementAtPath(childPathNode, path.slice(1));\n};\n\nmodule.exports = PathTree;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/corePathTree.js\n// module id = 8\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/corePathTree.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar coreEvents = __webpack_require__(1);\nvar globalObject = __webpack_require__(2);\n\nvar loadedEventModule = {};\n\nvar loadedTriggered = false;\n\nObject.defineProperty(globalObject.publicObject, 'loaded', {\n\tget: function get() {\n\t\treturn loadedTriggered;\n\t}\n});\n\n// List of events that has to be resolved before the loaded event gets triggered.\nvar delayLoadedUntilPromises = [];\n\n/**\n * Add event to list of events that has to be resolved, before the loaded event gets triggered.\n * This allows other modules to postpone the loaded event until they're ready.\n * @param  {...string} eventNames List of event names.\n * @public\n */\nloadedEventModule.delayUntil = function () {\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tvar eventName = args[0],\n\t    eventNames = args.slice(1);\n\n\tif (!eventName) return;\n\n\tdelayLoadedUntilPromises.push(new Promise(function (accept) {\n\t\t// Low priority, because want need to ensure that this gets triggered after the webstrateId\n\t\t// has been set on the wet publicObject (which we do below at medium priority).\n\t\tcoreEvents.addEventListener(eventName, accept, coreEvents.PRIORITY.LOW);\n\t}));\n\n\tloadedEventModule.delayUntil.apply(loadedEventModule, _toConsumableArray(eventNames));\n};\n\n// Initially delay the loaded event until the document has been populated.\nloadedEventModule.delayUntil('populated');\n\n// Create loaded event: The event to be triggered when the webstrate has finished.\nglobalObject.createEvent('loaded', {\n\t// If anybody adds a 'loaded' event listener after it has already been triggered, we run the\n\t// callback immediately.\n\taddListener: function addListener(callback) {\n\t\tif (loadedTriggered) {\n\t\t\tsetImmediate(callback, globalObject.publicObject.webstrateId, globalObject.publicObject.clientId, globalObject.publicObject.user);\n\t\t}\n\t}\n});\n\n// Also create an internal event.\ncoreEvents.createEvent('loadedTriggered', {\n\t// Same goes for the internal 'loadedTriggered' event.\n\taddListener: function addListener(callback) {\n\t\tif (loadedTriggered) {\n\t\t\tsetImmediate(callback, globalObject.publicObject.webstrateId, globalObject.publicObject.clientId, globalObject.publicObject.user);\n\t\t}\n\t}\n});\n\n// Wait for all events to have been triggered, before firing the loaded event.\ncoreEvents.addEventListener('allModulesLoaded', function () {\n\n\tPromise.all(delayLoadedUntilPromises).then(function () {\n\t\tloadedTriggered = true;\n\n\t\tglobalObject.triggerEvent('loaded', globalObject.publicObject.webstrateId,\n\t\t// These last two arguments depend on the existance of the clientManager and userObject\n\t\t// modules, respectively, which aren't a part of the core. It may be bad style to have them\n\t\t// here anyway, but luckily it won't break anything if these two modules aren't present.\n\t\tglobalObject.publicObject.clientId, globalObject.publicObject.user);\n\t\tcoreEvents.triggerEvent('loadedTriggered', globalObject.publicObject.webstrateId, globalObject.publicObject.clientId, globalObject.publicObject.user);\n\t});\n});\n\nmodule.exports = loadedEventModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/loadedEvent.js\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/loadedEvent.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar coreEvents = __webpack_require__(1);\nvar coreDOM = __webpack_require__(6);\nvar coreOpCreator = __webpack_require__(14);\nvar coreUtils = __webpack_require__(0);\nvar loadedEvent = __webpack_require__(9);\n\nvar nodeObjectsModule = {};\n\nnodeObjectsModule.getEventObject = function (node) {\n\treturn node && node.__eventObject;\n};\nnodeObjectsModule.setEventObject = function (node, eventObject) {\n\treturn node.__eventObject = eventObject;\n};\n\ncoreEvents.createEvent('webstrateObjectsAdded');\ncoreEvents.createEvent('webstrateObjectAdded');\n\n// Delay the loaded event, until the 'clientsReceived' event has been triggered.\nloadedEvent.delayUntil('webstrateObjectsAdded');\n\n/**\n * Attach webstrate object to node if it doesn't exist.\n * @param  {DOMNode} node        DOM Node to add webstrate object to.\n * @param  {bool} triggerEvent   Whether to trigger the webstrateObjectAdded event.\n * @private\n */\nfunction attachWebstrateObjectToNode(node, triggerEvent) {\n\tvar eventObjectExists = nodeObjectsModule.getEventObject(node);\n\n\t// If an event object doesn't exist, we recreate the webstrate object itself to avoid confusion.\n\t// This can happen if an element has been removed from the DOM, then re-added. In this case, all\n\t// event listeners will have been removed, so it might cause confusion when the same webstrate\n\t// object persists when all event listeners are gone.\n\t// By doing this, we also prevent other modules from trying to redefine read-only properties on\n\t// a webstrate object that has been \"recycled\".\n\tif (!eventObjectExists) {\n\t\tnode.webstrate = {};\n\t}\n\n\t// If this webstrate object is being added before the element has been node to the DOM (or if the\n\t// node is transient), it won't have a __wid, so we won't create an id property.\n\t// attachWebstrateObjectToNode may be run multiple times for the same node (e.g. if a node is\n\t// being moved around in the DOM), in which case we're not allowed to redefine the id property.\n\tif (node.__wid && !node.webstrate.id) {\n\t\t// We don't use `writeable: false` and value here, because in rare cases, node.__wid may change,\n\t\t// so we need to always serve the current node.__wid, not the node.__wid value that existed when\n\t\t// this was added. The wid may get redefined if a client (e.g. file system) creates a node\n\t\t// without a wid, causing a race condition on setting the wid on the other clients. This is\n\t\t// handled by sharedb, so we won't have different wids for the same node for more than a few\n\t\t// milliseconds under normal network conditions. That's the cost of eventual consistency.\n\t\tObject.defineProperty(node.webstrate, 'id', {\n\t\t\tget: function get() {\n\t\t\t\treturn node.__wid;\n\t\t\t},\n\t\t\tset: function set() {\n\t\t\t\tthrow new TypeError('Cannot redefine property: id');\n\t\t\t},\n\t\t\tenumerable: true\n\t\t});\n\t}\n\n\t// Only continue if the event object doesn't exist. We can't just check for the existence of\n\t// the webstrate object here, because an element that has been deleted and then reinserted\n\t// may still have a webstrate object, but won't have an event object, as the event object gets\n\t// deleted whenever an element gets removed from the DOM.\n\tif (eventObjectExists) {\n\t\treturn;\n\t}\n\n\t// Map from event names to a set of the actual listeners: string -> set of listeners.\n\tvar eventListeners = {};\n\t// Map from event names to actual listeners: string -> function.\n\tvar addEventListenerListeners = {};\n\t// Map from event names to actual listeners: string -> function.\n\tvar removeEventListenerListeners = {};\n\n\tfunction eventExists(eventName) {\n\t\treturn eventListeners.hasOwnProperty(eventName);\n\t}\n\n\tnode.webstrate.on = function (eventName, eventListener) {\n\t\tif (!eventExists(eventName)) {\n\t\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist on ' + node + '.');\n\t\t}\n\t\teventListeners[eventName].add(eventListener);\n\t\tif (addEventListenerListeners[eventName]) {\n\t\t\taddEventListenerListeners[eventName](eventListener);\n\t\t}\n\t};\n\tnode.webstrate.off = function (eventName, eventListener) {\n\t\tif (!eventExists(eventName)) {\n\t\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t\t}\n\t\teventListeners[eventName].delete(eventListener);\n\t\tif (removeEventListenerListeners[eventName]) {\n\t\t\tremoveEventListenerListeners[eventName](eventListener);\n\t\t}\n\t};\n\n\tvar eventObject = {\n\t\tcreateEvent: function createEvent(eventName) {\n\t\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\t\tif (eventExists(eventName) && !options.idempotent) {\n\t\t\t\tconsole.error('Event ' + eventName + ' already exists on ' + node + '.');\n\t\t\t\tthrow new Error('Event ' + eventName + ' already exists on ' + node + '.');\n\t\t\t}\n\n\t\t\tif (typeof options.addListener !== 'undefined') {\n\t\t\t\tif (typeof options.addListener !== 'function') {\n\t\t\t\t\tconsole.error('addListener must be a function, received: ' + options.addListener);\n\t\t\t\t\tthrow new Error('addListener must be a function, received: ' + options.addListener);\n\t\t\t\t}\n\t\t\t\taddEventListenerListeners[eventName] = options.addListener;\n\t\t\t}\n\n\t\t\tif (typeof options.removeListener !== 'undefined') {\n\t\t\t\tif (typeof options.removeListener !== 'function') {\n\t\t\t\t\tconsole.error('removeListener must be a function, received: ' + options.removeListener);\n\t\t\t\t\tthrow new Error('removeListener must be a function, received: ' + options.removeListener);\n\t\t\t\t}\n\t\t\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t\t\t}\n\n\t\t\tif (!eventExists(eventName)) {\n\t\t\t\teventListeners[eventName] = new Set();\n\t\t\t}\n\t\t},\n\t\ttriggerEvent: function triggerEvent(eventName) {\n\t\t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\targs[_key - 1] = arguments[_key];\n\t\t\t}\n\n\t\t\tif (!eventExists(eventName)) {\n\t\t\t\tconsole.error('Event ' + eventName + ' doesn\\'t exist on ' + node + '.');\n\t\t\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist on ' + node + '.');\n\t\t\t}\n\t\t\teventListeners[eventName].forEach(function (eventListener) {\n\t\t\t\tsetImmediate.apply(undefined, [eventListener].concat(args));\n\t\t\t});\n\t\t}\n\t};\n\n\tnodeObjectsModule.setEventObject(node, eventObject);\n\n\tif (triggerEvent) {\n\t\tcoreEvents.triggerEvent('webstrateObjectAdded', node, eventObject);\n\t}\n}\n\ncoreEvents.addEventListener('populated', function (targetElement) {\n\tcoreUtils.recursiveForEach(targetElement, function (childNode) {\n\t\t// We ensure that all elements in the ShareDB document have wids. If an element has been added\n\t\t// with e.g. Webstrates file system, it will be in the document, but not have a wid yet.\n\t\tcoreOpCreator.addWidToElement(childNode);\n\t\t// The second argument is whether to trigger the webstrateObjectAdded event. We do not want to\n\t\t// trigger these when we add the webstrate object initially as it may cause confusion when an\n\t\t// webstrateObjectsAdded event is triggered with the node in the nodes array, while a\n\t\t// webstrateObjectAdded event also is triggered for the same node.\n\t\tattachWebstrateObjectToNode(childNode, false);\n\t}, coreEvents.PRIORITY.IMMEDIATE);\n\n\t// All nodes get a webstrate object attached after they enter the DOM. It may, however, be\n\t// useful to access the Webstrate object before the element has been added to the DOM.\n\t// Therefore, we add Webstrate objects to all nodes created with document.createElement and\n\t// document.createElementNS immediately here.\n\t// We don't do this until after the document has been populated, because we just above attach\n\t// webstrate objects on the entire DOM.\n\tcoreDOM.overrideDocument('createElementNS', coreDOM.CONTEXT.BOTH, function (createElementNS, namespaceURI, qualifiedName) {\n\t\tfor (var _len2 = arguments.length, unused = Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {\n\t\t\tunused[_key2 - 4] = arguments[_key2];\n\t\t}\n\n\t\tvar options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\t\tvar element = createElementNS.apply(undefined, [namespaceURI, qualifiedName, options].concat(unused));\n\t\tattachWebstrateObjectToNode(element, true); // true to trigger webstrateObjectAdded event.\n\t\treturn element;\n\t});\n\n\tcoreDOM.overrideDocument('createElement', coreDOM.CONTEXT.BOTH, function (createElement, tagName) {\n\t\tfor (var _len3 = arguments.length, unused = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n\t\t\tunused[_key3 - 3] = arguments[_key3];\n\t\t}\n\n\t\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t\tvar element = createElement.apply(undefined, [tagName, options].concat(unused));\n\t\tattachWebstrateObjectToNode(element, true);\n\t\treturn element;\n\t});\n\n\tcoreDOM.overrideDocument('importNode', coreDOM.CONTEXT.BOTH, function (importNode, externalNode, deep) {\n\t\tfor (var _len4 = arguments.length, unused = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n\t\t\tunused[_key4 - 3] = arguments[_key4];\n\t\t}\n\n\t\tvar element = importNode.apply(undefined, [externalNode, deep].concat(unused));\n\t\tcoreUtils.recursiveForEach(element, function (childNode) {\n\t\t\tattachWebstrateObjectToNode(childNode, true);\n\t\t});\n\t\treturn element;\n\t});\n\n\tvar cloneNode = Element.prototype.cloneNode;\n\tElement.prototype.cloneNode = function (deep) {\n\t\tfor (var _len5 = arguments.length, unused = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n\t\t\tunused[_key5 - 1] = arguments[_key5];\n\t\t}\n\n\t\tvar element = cloneNode.call.apply(cloneNode, [this, deep].concat(unused));\n\t\tcoreUtils.recursiveForEach(element, function (childNode) {\n\t\t\tattachWebstrateObjectToNode(childNode, true);\n\t\t});\n\t\treturn element;\n\t};\n\n\tcoreEvents.triggerEvent('webstrateObjectsAdded', targetElement);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('DOMNodeInserted', function (node) {\n\tcoreUtils.recursiveForEach(node, function (childNode) {\n\t\t// The second argument is whether to trigger the webstrateObjectAdded event. We do want that.\n\t\tattachWebstrateObjectToNode(childNode, true);\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('DOMTextNodeInsertion', function (node) {\n\t// The second argument is whether to trigger the webstrateObjectAdded event. We do want that.\n\tattachWebstrateObjectToNode(node, true);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\nmodule.exports = nodeObjectsModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/nodeObjects.js\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/nodeObjects.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar coreEvents = __webpack_require__(1);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\nvar loadedEvent = __webpack_require__(9);\nvar coreUtils = __webpack_require__(0);\n\nvar userObjectModule = {};\n\n// In static mode, the user object is not being sent to the client.\nif (!coreUtils.getLocationObject().staticMode) {\n\tcoreEvents.createEvent('userObjectAdded');\n\n\t// Delay the loaded event, until the 'userObjectAdded' event has been triggered.\n\tloadedEvent.delayUntil('userObjectAdded');\n\n\tvar websocket = coreWebsocket.copy(function (event) {\n\t\treturn event.data.startsWith('{\"wa\":');\n\t});\n\n\t// Public user object\n\tvar publicObject = {};\n\n\tvar clientId = void 0;\n\n\tuserObjectModule.publicObject = publicObject;\n\tglobalObject.publicObject.user = publicObject;\n\n\twebsocket.onjsonmessage = function (message) {\n\t\tswitch (message.wa) {\n\t\t\tcase 'hello':\n\t\t\t\t{\n\t\t\t\t\t// Merge the incoming information with the existing user object. We don't overwrite it, as\n\t\t\t\t\t// other modules may already have added their own stuff.\n\t\t\t\t\tObject.assign(publicObject, message.user);\n\t\t\t\t\tclientId = message.id;\n\t\t\t\t\tcoreEvents.triggerEvent('userObjectAdded');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'userClientJoin':\n\t\t\t\t{\n\t\t\t\t\tvar joiningClientId = message.id;\n\t\t\t\t\tvar isOwnJoin = clientId === joiningClientId;\n\t\t\t\t\t// Own join will already be in the client list.\n\t\t\t\t\tif (!isOwnJoin && publicObject.clients) {\n\t\t\t\t\t\tpublicObject.clients.push(joiningClientId);\n\t\t\t\t\t}\n\t\t\t\t\t// Registers joins from the same user in other webstrates, from other devices, etc.\n\t\t\t\t\tif (message.userClient && publicObject.allClients) {\n\t\t\t\t\t\tpublicObject.allClients[message.id] = message.userClient;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// There is no specific 'userClientPart' command, because we can just try to remove all\n\t\t\t// parting clients from the user clients list.\n\t\t\tcase 'clientPart':\n\t\t\t\t{\n\t\t\t\t\t// ClientId and socketId are the same.\n\t\t\t\t\tvar partingClientId = message.id;\n\t\t\t\t\tif (publicObject.clients) {\n\t\t\t\t\t\tvar userIdx = publicObject.clients.indexOf(partingClientId);\n\t\t\t\t\t\tif (userIdx !== -1) {\n\t\t\t\t\t\t\tpublicObject.clients.splice(userIdx, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (publicObject.allClients) {\n\t\t\t\t\t\tdelete publicObject.allClients[partingClientId];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t};\n\n\t// Map from event names to a set of the actual listeners: string -> set of listeners.\n\tvar eventListeners = {};\n\t// Map from event names to actual listeners: string -> function.\n\tvar addEventListenerListeners = {};\n\t// Map from event names to actual listeners: string -> function.\n\tvar removeEventListenerListeners = {};\n\n\tuserObjectModule.eventExists = function (eventName) {\n\t\treturn eventListeners.hasOwnProperty(eventName);\n\t};\n\n\tuserObjectModule.createEvent = function (eventName) {\n\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tif (userObjectModule.eventExists(eventName) && !options.idempotent) {\n\t\t\tthrow new Error('Event ' + eventName + ' already exists.');\n\t\t}\n\n\t\tif (typeof options.addListener !== 'undefined') {\n\t\t\tif (typeof options.addListener !== 'function') {\n\t\t\t\tthrow new Error('addListener must be a function, received: ' + options.addListener);\n\t\t\t}\n\t\t\taddEventListenerListeners[eventName] = options.addListener;\n\t\t}\n\n\t\tif (typeof options.removeListener !== 'undefined') {\n\t\t\tif (typeof options.removeListener !== 'function') {\n\t\t\t\tthrow new Error('removeListener must be a function, received: ' + options.removeListener);\n\t\t\t}\n\t\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t\t}\n\n\t\tif (!userObjectModule.eventExists(eventName)) {\n\t\t\teventListeners[eventName] = new Set();\n\t\t}\n\t};\n\n\tuserObjectModule.triggerEvent = function (eventName) {\n\t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\targs[_key - 1] = arguments[_key];\n\t\t}\n\n\t\tif (!userObjectModule.eventExists(eventName)) {\n\t\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t\t}\n\t\teventListeners[eventName].forEach(function (eventListener) {\n\t\t\tsetImmediate.apply(undefined, [eventListener].concat(args));\n\t\t});\n\t};\n\n\tpublicObject.on = function (eventName, eventListener) {\n\t\tif (!userObjectModule.eventExists(eventName)) {\n\t\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t\t}\n\t\teventListeners[eventName].add(eventListener);\n\t\tif (addEventListenerListeners[eventName]) {\n\t\t\taddEventListenerListeners[eventName](eventListener);\n\t\t}\n\t};\n\n\tpublicObject.off = function (eventName, eventListener) {\n\t\tif (!userObjectModule.eventExists(eventName)) {\n\t\t\tthrow new Error('Event ' + eventName + ' doesn\\'t exist.');\n\t\t}\n\t\teventListeners[eventName].delete(eventListener);\n\t\tif (removeEventListenerListeners[eventName]) {\n\t\t\tremoveEventListenerListeners[eventName](eventListener);\n\t\t}\n\t};\n}\n\nmodule.exports = userObjectModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/userObject.js\n// module id = 11\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/userObject.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n/* JsonML <-> HTML library by Kristian B. Antonsen\n * This library is based on jQuery JSONML Plugin by Trevor Norris.\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar coreUtils = __webpack_require__(0);\nvar coreDOM = __webpack_require__(6);\n\nvar coreJsonML = {};\n\nfunction isPlainObject(obj) {\n\treturn obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object'\n\t// Previously, we did comparison like: Object.getPrototypeOf(obj) === Object.prototype, but we\n\t// can no longer do that, because if we use the parent's ShareDB Connection, plain objects created\n\t// in the outer frame will have used that frame's Object.prototype, which is not the same as the\n\t// Object.prototype in the inner frame, even though they're identical. Basically:\n\t// window.Object !== iframe.contentWindow.Object.\n\t&& Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction toHTML(elem, xmlNs, scripts) {\n\tvar fragment = document.createDocumentFragment();\n\tvar i = 0;\n\tvar name = null;\n\tvar selector = void 0;\n\n\t// Check if is an element or array of elements\n\tif (typeof elem[0] == 'string') {\n\t\tname = elem[0];\n\t\ti = 1;\n\t}\n\n\tif (elem[0] === '!' || elem[0] === '#comment') {\n\t\treturn document.createComment(elem.slice(typeof elem[1] === 'string' ? 1 : 2).join(''));\n\t}\n\n\tfor (; i < elem.length; i++) {\n\t\t// If array create new element\n\t\tif (Array.isArray(elem[i])) {\n\t\t\t// children of foreignobject element should use the default XHTML namespace\n\t\t\t// ('http://www.w3.org/1999/xhtml'), so we set it to undefined. Curiously enough, if we\n\t\t\t// actually do `xmlNs = \"http://www.w3.org/1999/xhtml\"`, stuff won't be rendered properly.\n\t\t\tif (name.toLowerCase() === 'foreignobject') {\n\t\t\t\txmlNs = undefined;\n\t\t\t}\n\n\t\t\tfragment.appendChild(toHTML(elem[i], xmlNs, scripts));\n\n\t\t\t// If object set element attributes\n\t\t} else if (isPlainObject(elem[i])) {\n\t\t\tif (name) {\n\n\t\t\t\tname = coreUtils.sanitizeString(name);\n\n\t\t\t\t// When loading a website with an SVG element without a namespace attribute, Chrome will\n\t\t\t\t// guess the namespace itself. When adding it like we do with Webstrates, it won't. So\n\t\t\t\t// to have Webstrates give us a more normal browser experience, we add the namespace\n\t\t\t\t// manually.\n\t\t\t\tif (name.toLowerCase() === 'svg') {\n\t\t\t\t\txmlNs = 'http://www.w3.org/2000/svg';\n\t\t\t\t}\n\n\t\t\t\t// As also mentioned in regards to foreignobject, setting the namspace to the default\n\t\t\t\t// (\"http://www.w3.org/1999/xhtml\") causes stuff to not render properly.\n\t\t\t\tif (xmlNs && xmlNs !== 'http://www.w3.org/1999/xhtml') {\n\t\t\t\t\tselector = document.createElementNS(xmlNs, name);\n\t\t\t\t} else {\n\t\t\t\t\tselector = document.createElement(name);\n\t\t\t\t}\n\n\t\t\t\t// Add attributes to the element.\n\t\t\t\tfor (var index in elem[i]) {\n\t\t\t\t\t// The __wid attribute is a unique ID assigned each node and should not be in the DOM, but\n\t\t\t\t\t// instead be a property on the DOM element.\n\t\t\t\t\tif (index.toLowerCase() === '__wid') {\n\t\t\t\t\t\tcoreUtils.setWidOnElement(selector, elem[i][index]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar value = coreUtils.unescape(elem[i][index]);\n\t\t\t\t\tindex = coreUtils.sanitizeString(index);\n\t\t\t\t\tif (xmlNs === 'http://www.w3.org/2000/svg') {\n\t\t\t\t\t\tif (index === 'href' || index === 'xlink:href') {\n\t\t\t\t\t\t\tselector.setAttributeNS('http://www.w3.org/1999/xlink', index, value, coreDOM.elementOptions);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar isSvgPath = selector.tagName.toLowerCase() === 'path' && index === 'd';\n\t\t\t\t\tif (isSvgPath) {\n\t\t\t\t\t\tselector.__d = value;\n\t\t\t\t\t}\n\t\t\t\t\tselector.setAttribute(coreUtils.unescapeDots(index), value, coreDOM.elementOptions);\n\t\t\t\t}\n\n\t\t\t\t// Add scripts to our scripts list, so we can execute them later synchronously.\n\t\t\t\tif (selector.tagName.toLowerCase() === 'script') {\n\t\t\t\t\tselector.async = false;\n\t\t\t\t\tscripts && scripts.push(selector);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If string or number insert text node\n\t\t} else if (typeof elem[i] == 'number' || typeof elem[i] == 'string') {\n\t\t\tfragment.appendChild(document.createTextNode(elem[i]));\n\n\t\t\t// If is an element append to fragment\n\t\t} else if (elem[i].nodeType) {\n\t\t\tfragment.appendChild(elem[i]);\n\t\t}\n\t}\n\n\tif (!selector && name) {\n\t\tname = coreUtils.sanitizeString(name);\n\t\tselector = document.createElement(name);\n\t}\n\n\t// If a selector is set append children and return\n\tif (selector) {\n\t\t// When creating <templates>, we need the document to actually contain an documentFragment.\n\t\t// If we just add a documentFragment to an element, the children of documentFragment will\n\t\t// actually be added instead. To prevent this, we add the children to the `content` property\n\t\t// if it exists.\n\t\tif (selector.content && selector.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\tselector.content.appendChild(fragment);\n\t\t} else {\n\t\t\tselector.appendChild(fragment);\n\t\t}\n\t\treturn selector;\n\t}\n\n\t// Otherwise return children of fragment\n\treturn fragment.childNodes;\n}\n\ncoreJsonML.toHTML = toHTML;\n\nfunction addChildren( /*DOM*/elem, /*function*/filter, /*JsonML*/jml) {\n\tvar childNodes = coreUtils.getChildNodes(elem);\n\tif (childNodes.length === 0) return false;\n\n\tfor (var i = 0; i < childNodes.length; i++) {\n\t\tvar child = fromHTML(childNodes[i], filter);\n\t\tif (child) {\n\t\t\tjml.push(child);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {Node} elem\n * @param {function} filter\n * @return {array} JsonML\n */\nfunction fromHTML(elem, filter) {\n\t// If an element doesn't have a PathTree, we don't want it in the JsonML. This will be the case\n\t// for <transient> elements.\n\tif (!elem || !elem.nodeType || !elem.__pathNodes || elem.__pathNodes.length === 0) {\n\t\t// free references\n\t\treturn elem = null;\n\t}\n\n\tvar i = void 0,\n\t    jml = void 0;\n\tswitch (elem.nodeType) {\n\t\tcase document.ELEMENT_NODE:\n\t\tcase document.DOCUMENT_NODE:\n\t\tcase document.DOCUMENT_FRAGMENT_NODE:\n\t\t\t{\n\t\t\t\tjml = [elem.tagName || ''];\n\n\t\t\t\tvar attr = elem.attributes;\n\t\t\t\tvar props = {};\n\t\t\t\tvar hasAttrib = false;\n\n\t\t\t\tfor (i = 0; attr && i < attr.length; i++) {\n\t\t\t\t\t// Transient attributes should not be added to the JsonML.\n\t\t\t\t\tif (config.isTransientAttribute(elem, attr[i].name)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (attr[i].specified) {\n\t\t\t\t\t\tif (attr[i].name === 'style') {\n\t\t\t\t\t\t\tprops.style = elem.style.cssText || attr[i].value;\n\t\t\t\t\t\t} else if ('string' === typeof attr[i].value) {\n\t\t\t\t\t\t\tif (elem.namespaceURI === 'http://www.w3.org/2000/svg') {\n\t\t\t\t\t\t\t\tprops[attr[i].name.toLowerCase()] = attr[i].value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprops[attr[i].name] = attr[i].value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\thasAttrib = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (elem.__wid) {\n\t\t\t\t\tprops.__wid = elem.__wid;\n\t\t\t\t\thasAttrib = true;\n\t\t\t\t}\n\n\t\t\t\tjml.push(props); //Webstrates always assumes that an element has attributes.\n\n\t\t\t\tvar child = void 0,\n\t\t\t\t    childNodes = void 0;\n\t\t\t\tswitch (jml[0].toLowerCase()) {\n\t\t\t\t\tcase 'frame':\n\t\t\t\t\tcase 'iframe':\n\t\t\t\t\t\tbreak; //Do not recursively serialize content in iFrames (CNK)\n\t\t\t\t\tcase 'style':\n\t\t\t\t\t\tchild = elem.styleSheet && elem.styleSheet.cssText;\n\t\t\t\t\t\tif (child && 'string' === typeof child) {\n\t\t\t\t\t\t\t// unwrap comment blocks\n\t\t\t\t\t\t\tchild = child.replace('\x3c!--', '').replace('--\x3e', '');\n\t\t\t\t\t\t\tjml.push(child);\n\t\t\t\t\t\t} else if (childNodes = coreUtils.getChildNodes(elem)) {\n\t\t\t\t\t\t\tfor (i = 0; i < childNodes.length; i++) {\n\t\t\t\t\t\t\t\tchild = childNodes[i];\n\t\t\t\t\t\t\t\tchild = fromHTML(child, filter);\n\t\t\t\t\t\t\t\tif (child && 'string' === typeof child) {\n\t\t\t\t\t\t\t\t\t// unwrap comment blocks\n\t\t\t\t\t\t\t\t\tchild = child.replace('\x3c!--', '').replace('--\x3e', '');\n\t\t\t\t\t\t\t\t\tjml.push(child);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\taddChildren(elem, filter, jml);\n\t\t\t\t\t\tchild = elem.type !== 'password' && elem.value;\n\t\t\t\t\t\tif (child) {\n\t\t\t\t\t\t\tif (!hasAttrib) {\n\t\t\t\t\t\t\t\t// need to add an attribute object\n\t\t\t\t\t\t\t\tjml.shift();\n\t\t\t\t\t\t\t\tprops = {};\n\t\t\t\t\t\t\t\tjml.unshift(props);\n\t\t\t\t\t\t\t\tjml.unshift(elem.tagName || '');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprops.value = child;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'textarea':\n\t\t\t\t\t\tif (!addChildren(elem, filter, jml)) {\n\t\t\t\t\t\t\tchild = elem.value || elem.innerHTML;\n\t\t\t\t\t\t\tif (child && 'string' === typeof child) {\n\t\t\t\t\t\t\t\tjml.push(child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\taddChildren(elem, filter, jml);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// filter result\n\t\t\t\tif ('function' === typeof filter) {\n\t\t\t\t\tjml = filter(jml, elem);\n\t\t\t\t}\n\n\t\t\t\t// free references\n\t\t\t\telem = null;\n\t\t\t\treturn jml;\n\t\t\t}\n\t\tcase Node.TEXT_NODE: // text node\n\t\tcase Node.CDATA_SECTION_NODE:\n\t\t\t{\n\t\t\t\t// CDATA node\n\t\t\t\tvar str = String(elem.nodeValue);\n\t\t\t\t// free references\n\t\t\t\telem = null;\n\t\t\t\treturn str;\n\t\t\t}\n\t\tcase Node.DOCUMENT_TYPE_NODE:\n\t\t\t{\n\t\t\t\t// doctype\n\t\t\t\tjml = ['!'];\n\n\t\t\t\tvar type = ['DOCTYPE', (elem.name || 'html').toLowerCase()];\n\n\t\t\t\tif (elem.publicId) {\n\t\t\t\t\ttype.push('PUBLIC', '\"' + elem.publicId + '\"');\n\t\t\t\t}\n\n\t\t\t\tif (elem.systemId) {\n\t\t\t\t\ttype.push('\"' + elem.systemId + '\"');\n\t\t\t\t}\n\n\t\t\t\tjml.push(type.join(' '));\n\n\t\t\t\t// filter result\n\t\t\t\tif ('function' === typeof filter) {\n\t\t\t\t\tjml = filter(jml, elem);\n\t\t\t\t}\n\t\t\t\t// free references\n\t\t\t\telem = null;\n\t\t\t\treturn jml;\n\t\t\t}\n\t\tcase Node.COMMENT_NODE:\n\t\t\t{\n\t\t\t\t// comment node\n\t\t\t\tif ((elem.nodeValue || '').indexOf('DOCTYPE') !== -1) {\n\t\t\t\t\t// free references\n\t\t\t\t\telem = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tjml = ['!', elem.nodeValue];\n\n\t\t\t\t// filter result\n\t\t\t\tif ('function' === typeof filter) {\n\t\t\t\t\tjml = filter(jml, elem);\n\t\t\t\t}\n\n\t\t\t\t// free references\n\t\t\t\telem = null;\n\t\t\t\treturn jml;\n\t\t\t}\n\t\tdefault:\n\t\t\t{\n\t\t\t\t// etc.\n\t\t\t\t// free references\n\t\t\t\treturn elem = null;\n\t\t\t}\n\t}\n}\n\ncoreJsonML.fromHTML = fromHTML;\n\nmodule.exports = coreJsonML;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreJsonML.js\n// module id = 12\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreJsonML.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\n\nvar coreMutation = {};\n\ncoreEvents.createEvent('mutation');\n\nvar observerOptions = {\n\tchildList: true,\n\tsubtree: true,\n\tattributes: true,\n\tcharacterData: true,\n\tattributeOldValue: true,\n\tcharacterDataOldValue: true\n};\n\nvar rootElement = void 0;\nvar primaryObserver = new MutationObserver(mutationsHandler);\nvar fragmentObservers = {};\nvar fragmentParentMap = {};\n\ncoreMutation.emitMutationsFrom = function (_rootElement) {\n\trootElement = _rootElement;\n\t// Add MutationObserver on root.\n\tprimaryObserver.observe(rootElement, observerOptions);\n\t// Add MutationObservers on to all documentFragments (the things that live inside <template>s).\n\tcoreUtils.recursiveForEach(rootElement, function (node) {\n\t\tif (node.content && node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\tsetupFragmentObserver(node.content, node);\n\t\t}\n\t});\n\tisPaused = false;\n};\n\nfunction mutationsHandler(mutations) {\n\tmutations.forEach(function forEachMutation(mutation) {\n\t\t// DocumentFragments (as per the specification) can't have parents, even if they actually do.\n\t\t// Therefore, they also can't exist in the PathTree. Instead, we pretend that they *are*\n\t\t// their parents. Since this is only used with <template>s, whose only children are a single\n\t\t// documentFragment, this makes sense. The JsonML also does not store the documentFragment,\n\t\t// but it is automatically created when creating a <template> tag.\n\t\tif (mutation.target.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\t// We use defineProperty rather than a primitive assignemtn, because the target property is\n\t\t\t// read-only.\n\t\t\tObject.defineProperty(mutation, 'target', {\n\t\t\t\tvalue: fragmentParentMap[mutation.target.id]\n\t\t\t});\n\t\t}\n\n\t\tcoreEvents.triggerEvent('mutation', mutation);\n\t});\n}\n\n/**\n * Set ups a Mutation Observer on a Document Fragment.\n * @param {DocumentFragment} fragment Fragment to observe.\n * @param {DOMElement} element        Element containing fragment.\n * @private\n */\nfunction setupFragmentObserver(fragment, element) {\n\tif (fragment.id) {\n\t\treturn;\n\t}\n\tfragment.id = coreUtils.randomString();\n\tvar fragmentObserver = new MutationObserver(mutationsHandler);\n\tfragmentObserver.observe(fragment, observerOptions);\n\tfragmentObservers[fragment.id] = [fragment, fragmentObserver];\n\tfragmentParentMap[fragment.id] = element;\n}\n\n/**\n * Removes a Mutation Observer from a Document Fragment.\n * @param {DocumentFragment} fragment Fragment to remove observer from.\n * @private\n */\nfunction teardownFragmentObserver(fragment) {\n\tif (!fragment.id || !fragmentParentMap[fragment.id]) {\n\t\treturn;\n\t}\n\tvar fragmentObserver = void 0;\n\n\tvar _fragmentObservers$fr = _slicedToArray(fragmentObservers[fragment.id], 2);\n\n\tfragment = _fragmentObservers$fr[0];\n\tfragmentObserver = _fragmentObservers$fr[1];\n\n\tfragmentObserver.disconnect();\n\tdelete fragmentObservers[fragment.id];\n\tdelete fragmentParentMap[fragment.id];\n}\n\n// The global mutation observer does not observe on changes to documentFragments (the things that\n// live inside <template>s within the document, so we have to manually create and manage individual\n// observers for each documentFragment.\n// Before we can do that, we have to create DOMNodeInserted and DOMNodeDeletedoutselves ourselves,\n// because this module gets loaded before they get created (by coreOpApplier or coreOpCreator).\n// The 'idempotent' option allows these events to be created even if they already. Just to be safe.\ncoreEvents.createEvent('DOMNodeInserted', { idempotent: true });\ncoreEvents.createEvent('DOMNodeDeleted', { idempotent: true });\n\n// Whenever the DOM gets modified, we add/remove potential MutationObservers from documentFragments\n// (i.e. the things living inside <template>s).\ncoreEvents.addEventListener('DOMNodeInserted', function (addedNode) {\n\tcoreUtils.recursiveForEach(addedNode, function (node) {\n\t\tif (node.content && node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\tsetupFragmentObserver(node.content, node);\n\t\t}\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('DOMNodeDeleted', function (removedNode) {\n\tcoreUtils.recursiveForEach(removedNode, function (node) {\n\t\tif (node.content && node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\tteardownFragmentObserver(node.content);\n\t\t}\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// To not create a live-lock, the coreOpApplier module needs to pause the mutation observer when\n// adding incoming ops to the DOM. Otherwise, those incoming ops would in turn create new ops, and\n// so on.\n// The following allows other modules to manage the MutationObservers.\nvar isPaused = true;\nObject.defineProperty(coreMutation, 'isPaused', {\n\tget: function get() {\n\t\treturn isPaused;\n\t}\n});\n\ncoreMutation.pause = function () {\n\tif (isPaused) return;\n\tObject.keys(fragmentObservers).forEach(function (fragmentId) {\n\t\tvar _fragmentObservers$fr2 = _slicedToArray(fragmentObservers[fragmentId], 2),\n\t\t    _fragment = _fragmentObservers$fr2[0],\n\t\t    fragmentObserver = _fragmentObservers$fr2[1];\n\n\t\tfragmentObserver.disconnect();\n\t});\n\tprimaryObserver.disconnect();\n\tisPaused = true;\n};\n\ncoreMutation.resume = function () {\n\tif (!isPaused) return;\n\tObject.keys(fragmentObservers).forEach(function (fragmentId) {\n\t\tvar _fragmentObservers$fr3 = _slicedToArray(fragmentObservers[fragmentId], 2),\n\t\t    fragment = _fragmentObservers$fr3[0],\n\t\t    fragmentObserver = _fragmentObservers$fr3[1];\n\n\t\tfragmentObserver.observe(fragment, observerOptions);\n\t});\n\tprimaryObserver.observe(rootElement, observerOptions);\n\tisPaused = false;\n};\n\nmodule.exports = coreMutation;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreMutation.js\n// module id = 13\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreMutation.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar coreConfig = __webpack_require__(16);\nvar coreEvents = __webpack_require__(1);\nvar coreDatabase = __webpack_require__(7);\nvar corePathTree = __webpack_require__(8);\nvar coreUtils = __webpack_require__(0);\nvar coreJsonML = __webpack_require__(12);\nvar diffMatchPatch = __webpack_require__(50);\nvar json0 = __webpack_require__(43);\n\nvar coreOpCreator = {};\n\ncoreEvents.createEvent('createdOps');\n\n// The 'idempotent' option allows these events to be created even if they already\n// exists. We do this, because these events also are used (and created) in coreOpApplier.\ncoreEvents.createEvent('DOMAttributeSet', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeRemoved', { idempotent: true });\ncoreEvents.createEvent('DOMNodeInserted', { idempotent: true });\ncoreEvents.createEvent('DOMNodeDeleted', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextDeletion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeDeletion', { idempotent: true });\n\n// The attribute's index into a JsonML element array.\nvar ATTRIBUTE_INDEX = 1;\n\n// Instantiate the DiffMatchPatch library used for creating ops from text mutations.\nvar dmp = new diffMatchPatch();\n\n/**\n * Convert a number of string patches to OT operations.\n * @param  {JsonMLPath} path Base path for patches to apply to.\n * @param  {string} oldValue Old value.\n * @param  {string} newValue New value.\n * @return {Ops}             List of resulting operations.\n */\nfunction patchesToOps(path, oldValue, newValue) {\n\tvar ops = [];\n\n\tvar patches = dmp.patch_make(oldValue, newValue);\n\n\tObject.keys(patches).forEach(function (i) {\n\t\tvar patch = patches[i],\n\t\t    offset = patch.start1;\n\t\tpatch.diffs.forEach(function (_ref) {\n\t\t\tvar _ref2 = _slicedToArray(_ref, 2),\n\t\t\t    type = _ref2[0],\n\t\t\t    value = _ref2[1];\n\n\t\t\tswitch (type) {\n\t\t\t\tcase diffMatchPatch.DIFF_DELETE:\n\t\t\t\t\tops.push({ sd: value, p: [].concat(_toConsumableArray(path), [offset]) });\n\t\t\t\t\tbreak;\n\t\t\t\tcase diffMatchPatch.DIFF_INSERT:\n\t\t\t\t\tops.push({ si: value, p: [].concat(_toConsumableArray(path), [offset]) });\n\t\t\t\t// falls through intentionally\n\t\t\t\tcase diffMatchPatch.DIFF_EQUAL:\n\t\t\t\t\toffset += value.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error('Unsupported operation type: ' + type);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn ops;\n}\n\n/**\n * Creates attribute operation (object insertion) from mutation.\n * @param  {MutationRecord} mutation MutationRecord created by MutationObserver.\n * @param  {PathNode} targetPathNode The PathNode from PathTree that is the target of the\n *                                   mutation.\n */\nfunction attributeMutation(mutation, targetPathNode) {\n\tif (!targetPathNode || config.isTransientAttribute(mutation.target, mutation.attributeName)) {\n\t\treturn;\n\t}\n\n\t// MongoDB doesn't support periods (.) in keys, so we store them as &dot; instead.\n\tvar cleanAttributeName = coreUtils.escapeDots(mutation.attributeName);\n\tvar targetPathNodeJsonML = targetPathNode.toPath();\n\tvar path = [].concat(_toConsumableArray(targetPathNodeJsonML), [ATTRIBUTE_INDEX, cleanAttributeName]);\n\tvar oldValue = mutation.oldValue;\n\tvar newValue = coreUtils.escape(mutation.target.getAttribute(mutation.attributeName));\n\tvar jsonmlAttrs = coreDatabase.elementAtPath([].concat(_toConsumableArray(targetPathNodeJsonML), [ATTRIBUTE_INDEX]));\n\n\t// If the new value is null, we are removing the attribute.\n\tif (newValue === null) {\n\t\tcoreEvents.triggerEvent('DOMAttributeRemoved', mutation.target, mutation.attributeName, oldValue, newValue, true);\n\t\treturn [{ od: oldValue, p: path }];\n\t}\n\n\tif (newValue === jsonmlAttrs[cleanAttributeName]) {\n\t\treturn [];\n\t}\n\n\t// dmp.patch_make does not accept empty strings, so if we are creating a new attribute (or\n\t// setting an attribute's value for the first time), we have to create the operation manually.\n\t// The second condition should not be true without the first one, but it will if the changes\n\t// happen so rapidly, that the browser skipped a MutationRecord. Or that's my theory, at least.\n\t// Also, if the newValue is short, it's easier and faster to just send it rather than patch it.\n\t// And lastly, if we're throttling ops (meaning we're not sending all of them), we can't create\n\t// diffs as diffs only work between two known states, but we won't know the previous state if we\n\t// have left out some ops. Just replacing a string with a new one doesn't require any knowledge\n\t// about the current state.\n\tvar ops = void 0;\n\tif (oldValue === null || newValue.length < 50 || !jsonmlAttrs[cleanAttributeName] || !coreConfig.attributeValueDiffing || mutation.target.hasAttribute('op-throttle')) {\n\t\tops = [{ od: oldValue, oi: newValue, p: path }];\n\t} else {\n\t\tops = patchesToOps(path, jsonmlAttrs[cleanAttributeName], newValue);\n\t}\n\n\tcoreEvents.triggerEvent('DOMAttributeSet', mutation.target, mutation.attributeName, oldValue, newValue, true);\n\treturn ops;\n}\n\n/**\n * Creates string insertion and string deletion operations from mutation.\n * @param  {MutationRecord} mutation MutationRecord created by MutationObserver.\n * @param  {PathNode} targetPathNode The PathNode from PathTree that is the target of the\n *                                   mutation.\n */\nfunction characterDataMutation(mutation, targetPathNode) {\n\t// No pathNode means transient, therefore not in the JsonML, so creating an op isn't possible and\n\t// also doesn't make sense.\n\tif (!targetPathNode) {\n\t\treturn;\n\t}\n\n\tvar isComment = mutation.target.nodeType === document.COMMENT_NODE;\n\tvar path = targetPathNode.toPath();\n\n\tvar pathElement = coreDatabase.elementAtPath(path);\n\t// The old value at the path must be a string for us to be able to create patches. However, if\n\t// nothing exists there, we'll get the parent element.\n\tvar oldValue = typeof pathElement === 'string' && pathElement || '';\n\n\tvar newValue = mutation.target.data.replace(/ /g, ' ');\n\n\t/*if (!isComment && coreDatabase.elementAtPath(path) !== oldValue) {\n \t// This should not happen, but it will if a text node is inserted and then altered right\n \t// after. If this happens, we can ignore it.\n \treturn;\n }*/\n\n\tvar ops = void 0;\n\tif (mutation.target.parentElement && mutation.target.parentElement.hasAttribute('op-compose')) {\n\t\toldValue = mutation.target.futureContents || oldValue;\n\t\tmutation.target.futureContents = newValue;\n\t}\n\n\tops = patchesToOps(path, oldValue, newValue);\n\tif (isComment) {\n\t\tops[0].p.splice(ops[0].p.length - 1, 0, 1);\n\t}\n\n\t// In most cases, we could use mutation.target.parentElement to determine the parentElement, but\n\t// when deleting a node from the DOM, the target will no longer have a parentElement. Therefore,\n\t// we instead look at our path tree.\n\tvar parentElement = targetPathNode.parent.DOMNode;\n\n\tops.forEach(function (op) {\n\t\tvar type = void 0,\n\t\t    value = void 0,\n\t\t    charIndex = op.p[op.p.length - 1];\n\t\tif ('si' in op) {\n\t\t\ttype = 'DOMTextNodeInsertion';\n\t\t\tvalue = op.si;\n\t\t} else if ('sd' in op) {\n\t\t\ttype = 'DOMTextNodeDeletion';\n\t\t\tvalue = op.sd;\n\t\t} else if ('od' in op) {\n\t\t\ttype = 'DOMNodeDeleted';\n\t\t\tvalue = op.od;\n\t\t}if ('oi' in op) {\n\t\t\ttype = 'DOMNodeInserted';\n\t\t\tvalue = op.oi;\n\t\t}\n\n\t\tcoreEvents.triggerEvent(type, mutation.target, parentElement, charIndex, value, true);\n\t});\n\n\treturn ops;\n}\n\n/**\n * Creates node insertion and deletion operations from mutation.\n * @param  {MutationRecord} mutation MutationRecord created by MutationObserver.\n * @param  {PathNode} targetPathNode The PathNode from PathTree that is the target of the\n *                                   mutation.\n */\nfunction childListMutation(mutation, targetPathNode) {\n\tvar ops = [];\n\n\tArray.from(mutation.addedNodes).forEach(function (addedNode) {\n\t\t// Sanitizes all nodes (i.e. ensures valid tag names and attributes) and set wids on all nodes.\n\t\tvar parentNode = mutation.target;\n\n\t\tvar addedPathNode = corePathTree.getPathNode(addedNode, parentNode);\n\n\t\t// If an element already has a pathNode, it means it's already in the DOM. This could still\n\t\t// generate an op if the element is being moved. However, if the element is already in the DOM,\n\t\t// and it has the same parent as before, then it hasn't moved, so there's no reason to generate\n\t\t// an op.\n\t\t//\n\t\t// NOTE: I think there might be a bug here: If moving a text node around, it could have a\n\t\t// pathNode, but also have the same parent, in which case the move wouldn't create an op.\n\t\t// I am, however, unable to reproduce this...\n\t\tif (addedPathNode && targetPathNode.id === addedPathNode.parent.id) {\n\t\t\treturn;\n\t\t}\n\n\t\tcoreUtils.recursiveForEach(addedNode, function (childNode, parentNode) {\n\t\t\tif (childNode.nodeType === document.ELEMENT_NODE) {\n\t\t\t\tvar sanitizedTagName = coreUtils.sanitizeString(childNode.tagName);\n\t\t\t\t// If the name is unsanitized, we remove the element and replace it with an identical\n\t\t\t\t// element with a sanitized tag name.\n\t\t\t\tif (sanitizedTagName !== childNode.tagName) {\n\t\t\t\t\tvar replacementNode = document.createElementNS(childNode.tagName.namespaceURI, sanitizedTagName);\n\n\t\t\t\t\t// Move all children.\n\t\t\t\t\twhile (childNode.firstChild) {\n\t\t\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(replacementNode, childNode.firstChild);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Copy all attributes and sanitize them as well.\n\t\t\t\t\tfor (var i = 0; i < childNode.attributes.length; i++) {\n\t\t\t\t\t\tvar attr = childNode.attributes[i];\n\t\t\t\t\t\treplacementNode.setAttribute(coreUtils.sanitizeString(attr.nodeName), attr.nodeValue);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Insert the element before childNode.\n\t\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(childNode.parentElement, replacementNode, childNode);\n\t\t\t\t\tchildNode.remove();\n\t\t\t\t\tchildNode = replacementNode;\n\t\t\t\t} else {\n\t\t\t\t\t// If we haven't replaced the element, we still have to sanitize the attributes.\n\t\t\t\t\tfor (var _i = 0; _i < childNode.attributes.length; _i++) {\n\t\t\t\t\t\tvar _attr = childNode.attributes[_i];\n\t\t\t\t\t\tvar sanitizedNodeName = coreUtils.sanitizeString(_attr.nodeName);\n\t\t\t\t\t\tif (sanitizedNodeName !== _attr.nodeName) {\n\t\t\t\t\t\t\tchildNode.removeAttribute(_attr.nodeName);\n\t\t\t\t\t\t\tchildNode.setAttribute(sanitizedNodeName, _attr.nodeValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// The element may being moved, and thus already is in the DOM and has a wid. We don't want\n\t\t\t\t// to redefine this. Also, the element can't be transient, i.e. its parent has to be in\n\t\t\t\t// the JsonML (targetPathNode must exist) and the element itself can't be transient.\n\t\t\t\tif (!childNode.__wid && targetPathNode && !config.isTransientElement(childNode)) {\n\t\t\t\t\tvar wid = coreUtils.randomString();\n\t\t\t\t\tcoreUtils.setWidOnElement(childNode, wid);\n\t\t\t\t}\n\t\t\t}\n\t\t}, parentNode);\n\n\t\t// The above wid/sanitization, we do recursively on each node, so one might naturally wonder why\n\t\t// we don't need to do the same here: Creating a PathTree (as below) happens recursively on all\n\t\t// child nodes automatically. When it comes to inserting the newly created PathTree afterwards,\n\t\t// that shouldn't happen recursively; we just need to add the newly created PathTree one place\n\t\t// in the existing tree.\n\n\t\t// If we can't create path node, it can't been registered in the JsonML at all, so creating\n\t\t// an op for it doesn't make sense. This happens for instance with transient elements.\n\t\tvar newPathNode = corePathTree.create(addedNode, targetPathNode);\n\t\tif (!newPathNode) {\n\t\t\tcoreEvents.triggerEvent('DOMNodeInserted', addedNode, mutation.target, true);\n\t\t\treturn;\n\t\t}\n\n\t\t// We use the previous sibling to insert the new element in the correct position in the path\n\t\t// tree. However, if the previous sibling doesn't have a webstrate object, it won't be in the\n\t\t// path tree, so it will appear that the element has no previous element. Therefore, we\n\t\t// traverse the list of previous siblings until we find one that does have a webstrate object.\n\t\t// Transient elements (outside of template tags) will righfully be absent from the pathtree,\n\t\t// and thus not have webstrate objects.\n\t\t// We have to use addedNode.previousSibling and not mutation.previousSibling, as this will\n\t\t// refer to the previousSibling when the element was inserted. If multiple elements (B, C) have\n\t\t// been inserted after element A, one after the each other, in one tick,\n\t\t// mutation.previousSibling will refer to A for both mutations, but mutation.previousSibling\n\t\t// will refer to A and B, respectively.\n\t\tvar previousSibling = addedNode.previousSibling;\n\t\tvar previousSiblingPathNode = corePathTree.getPathNode(previousSibling, parentNode);\n\t\twhile (previousSibling && !previousSiblingPathNode) {\n\t\t\tpreviousSibling = previousSibling.previousSibling;\n\t\t\tpreviousSiblingPathNode = corePathTree.getPathNode(previousSibling, parentNode);\n\t\t}\n\n\t\tif (previousSibling) {\n\t\t\tvar previousSiblingIndex = targetPathNode.children.indexOf(previousSiblingPathNode);\n\t\t\ttargetPathNode.children.splice(previousSiblingIndex + 1, 0, newPathNode);\n\t\t} else if (addedNode.nextSibling) {\n\t\t\ttargetPathNode.children.unshift(newPathNode);\n\t\t} else {\n\t\t\ttargetPathNode.children.push(newPathNode);\n\t\t}\n\t\tvar path = corePathTree.getPathNode(addedNode, parentNode).toPath();\n\t\tvar op = { li: coreJsonML.fromHTML(addedNode), p: path };\n\t\tops.push(op);\n\n\t\tcoreEvents.triggerEvent('DOMNodeInserted', addedNode, mutation.target, true);\n\t});\n\n\tArray.from(mutation.removedNodes).forEach(function (removedNode) {\n\t\tvar removedPathNode = corePathTree.getPathNode(removedNode, mutation.target);\n\n\t\t// If an element has no path node, it hasn't been registered in the JsonML at all, so it won't\n\t\t// exist on other clients, and therefore creating an op to delete it wouldn't make sense.\n\t\tif (!removedPathNode) {\n\t\t\tcoreEvents.triggerEvent('DOMNodeDeleted', removedNode, mutation.target, true);\n\t\t\treturn;\n\t\t}\n\n\t\tvar path = removedPathNode.toPath();\n\t\tremovedPathNode.remove();\n\t\tvar jsonmlElement = coreDatabase.elementAtPath(path);\n\t\t// If the element doesn't exist in the JsonML, we can't create an op for its deletion, and we\n\t\t// shouldn't either, so we return. This happens when we replace an unsanitized tag with a\n\t\t// sanitized one.\n\t\tif (!jsonmlElement) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar op = { ld: jsonmlElement, p: path };\n\t\tops.push(op);\n\n\t\tcoreEvents.triggerEvent('DOMNodeDeleted', removedNode, mutation.target, true);\n\t});\n\n\treturn ops;\n}\n\ncoreOpCreator.emitOpsFromMutations = function () {\n\tcoreEvents.addEventListener('mutation', function (mutation) {\n\t\tvar targetPathNode = corePathTree.getPathNode(mutation.target);\n\n\t\tvar elementTarget = mutation.target.nodeType === document.ELEMENT_NODE ? mutation.target : mutation.target.parentElement;\n\t\tvar elementPathNode = corePathTree.getPathNode(elementTarget);\n\n\t\tvar ops = void 0;\n\t\tswitch (mutation.type) {\n\t\t\tcase 'attributes':\n\t\t\t\tops = attributeMutation(mutation, targetPathNode);break;\n\t\t\tcase 'characterData':\n\t\t\t\tops = characterDataMutation(mutation, targetPathNode);break;\n\t\t\tcase 'childList':\n\t\t\t\tops = childListMutation(mutation, targetPathNode);break;\n\t\t}\n\n\t\t// In rare cases, what happens doesn't amount to an operation, so we ignore it.\n\t\tif (!ops || ops.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When setting the op-throttle attribute on an element with a number N as the value, all\n\t\t// changes made to that element will be throttled to only send at most 1 op every N\n\t\t// milliseconds. The newest op is always the one to be sent. This can be useful intermediate\n\t\t// values aren't essential.\n\t\tif (elementTarget && elementTarget.hasAttribute('op-throttle')) {\n\t\t\tvar throttleDelay = Number(elementTarget.getAttribute('op-throttle'));\n\t\t\tif (!targetPathNode.throttleFn || targetPathNode.throttleDelay !== throttleDelay) {\n\t\t\t\ttargetPathNode.throttleDelay = throttleDelay;\n\t\t\t\ttargetPathNode.throttleFn = coreUtils.throttleFn(coreEvents.triggerEvent.bind(coreEvents), throttleDelay);\n\t\t\t}\n\n\t\t\ttargetPathNode.throttleFn('createdOps', ops);\n\t\t\treturn;\n\t\t}\n\n\t\t// If we get here, op-throttle doesn't exist, so there's no need for a (potentially) old\n\t\t// throttle function that we're no longer using.\n\t\tif (targetPathNode) {\n\t\t\ttargetPathNode.throttleFn = null;\n\t\t}\n\n\t\t// When setting the op-compose attribute on an element with a number N as the value, all\n\t\t// changes made to that element will be composed to only send ops at most every N\n\t\t// milliseconds. All mutations that have occured since the last trigger will be composed into\n\t\t// (hopefully) fewer ops that will be sent as a group, speeding up the processing of them.\n\t\t// This can be useful when a lot of essential (i.e. ones we can't throw out like with\n\t\t// op-throttle) ops are created and performance is suffering.\n\t\tif (elementTarget && elementTarget.hasAttribute('op-compose')) {\n\t\t\tvar composeDelay = Number(elementTarget.getAttribute('op-compose'));\n\n\t\t\ttargetPathNode.composedOps = targetPathNode.composedOps ? json0.compose(targetPathNode.composedOps, ops) : ops;\n\n\t\t\tif (!elementPathNode.composeFn || elementPathNode.composeDelay !== composeDelay) {\n\t\t\t\telementPathNode.composeDelay = composeDelay;\n\t\t\t\ttargetPathNode.composedOps = ops;\n\t\t\t\telementPathNode.composeFn = coreUtils.throttleFn(function (targetPathNode) {\n\t\t\t\t\tif (targetPathNode.composedOps) {\n\t\t\t\t\t\tcoreEvents.triggerEvent('createdOps', coreUtils.objectClone(targetPathNode.composedOps));\n\t\t\t\t\t\ttargetPathNode.composedOps = null;\n\t\t\t\t\t}\n\t\t\t\t}, composeDelay);\n\t\t\t}\n\n\t\t\telementPathNode.composeFn(targetPathNode);\n\t\t\treturn;\n\t\t}\n\n\t\t// If we get here, op-compose doesn't exist, so there's no need for a a (potentially) old\n\t\t// compose function that we're no longer using.\n\t\tif (elementPathNode) {\n\t\t\telementPathNode.composeFn = null;\n\t\t}\n\n\t\tcoreEvents.triggerEvent('createdOps', ops);\n\t}, coreEvents.PRIORITY.IMMEDIATE);\n};\n\ncoreOpCreator.addWidToElement = function (node) {\n\tif (node.nodeType === document.ELEMENT_NODE && !node.__wid) {\n\t\tvar pathNode = corePathTree.getPathNode(node);\n\n\t\t// Anything without a pathNode is transient and therefore doesn't need a wid.\n\t\tif (!pathNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When inserting something into the DOM before the 'loaded' event has triggered, we will\n\t\t// be calling this function on a node that doesn't exist in the ShareDB document, resulting in\n\t\t// the submission of an op to add a wid to an element that doesn't exist, causing an error.\n\t\t// This oughtn't happen as nobody should touch the DOM before the 'loaded' event has triggered,\n\t\t// but some libraries (and users!) don't respect that. To mitigate this, we stop if the element\n\t\t// doesn't exist.\n\t\t// An alternative fix would be to create and submit and op that would create the element, but if\n\t\t// some script adds something to the DOM on every page load, we probably don't want to keep it\n\t\t// anyway, so it might actually be better to treat it as a wonky, broken transient element (\n\t\t// as we do now).\n\t\tvar path = pathNode.toPath();\n\t\tvar element = coreDatabase.getDocument(path);\n\t\tif (!Array.isArray(element)) {\n\t\t\tconsole.warn('Element was inserted before \\'loaded\\' event was triggered. This may cause ' + 'undefined behaviour.', node);\n\t\t\treturn;\n\t\t}\n\n\t\tvar wid = coreUtils.randomString();\n\t\tcoreUtils.setWidOnElement(node, wid);\n\t\tvar ops = [{ oi: wid, p: [].concat(_toConsumableArray(path), [ATTRIBUTE_INDEX, '__wid']) }];\n\t\tcoreEvents.triggerEvent('createdOps', ops);\n\t}\n};\n\ncoreOpCreator.ensureExistenceOfWids = function (targetElement) {\n\tcoreUtils.recursiveForEach(targetElement, function (node) {\n\t\treturn coreOpCreator.addWidToElement(node);\n\t});\n};\n\ncoreEvents.addEventListener('DOMNodeInserted', function (node, parentElement, local) {\n\t// If local is set, this node was inserted by ourself and thus already has a wid (if it needs to).\n\tif (!local) coreOpCreator.addWidToElement(node);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('DOMNodeDeleted', function (node) {\n\tif (node.__wid) {\n\t\tcoreUtils.removeWidFromElement(node.__wid);\n\t}\n});\n\nmodule.exports = coreOpCreator;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreOpCreator.js\n// module id = 14\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreOpCreator.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar coreJsonML = __webpack_require__(12);\nvar corePathTree = __webpack_require__(8);\n\nvar corePopulator = {};\n\ncoreEvents.createEvent('populated');\n\ncorePopulator.populate = function (rootElement, doc) {\n\t// Empty the document, so we can use it.\n\twhile (rootElement.firstChild) {\n\t\trootElement.removeChild(rootElement.firstChild);\n\t}\n\n\tvar webstrateId = doc.id;\n\tvar staticMode = coreUtils.getLocationObject().staticMode;\n\t// If the document doesn't exist (no type) or is empty (no data), we should recreate it, unless\n\t// we're in static mode. We should never modify the document from static mode.\n\tif ((!doc.type || doc.data.length === 0) && !staticMode) {\n\t\tif (!doc.type) {\n\t\t\tconsole.log('Creating new sharedb document: \"' + webstrateId + '\".');\n\t\t\tdoc.create('json0');\n\t\t} else {\n\t\t\tconsole.warn('Document: \"' + webstrateId + '\" exists, but was empty. Recreating basic document.');\n\t\t}\n\n\t\tvar op = [{ 'p': [], 'oi': ['html', {}, '\\n', ['head', {}, '\\n', ['title', {}, webstrateId], '\\n'], '\\n', ['body', {}, '\\n']] }];\n\t\tdoc.submitOp(op);\n\t}\n\n\t// All documents are persisted as JsonML, so we only know how to work with JSON documents.\n\tif (!staticMode && doc.type.name !== 'json0' || staticMode && doc.type !== 'http://sharejs.org/types/JSONv0') {\n\t\tconsole.error(staticMode, doc.type);\n\t\tthrow 'Unsupported document type: ' + doc.type.name;\n\t}\n\n\t// In order to execute scripts synchronously, we insert them all without execution, and then\n\t// execute them in order afterwards.\n\tvar scripts = [];\n\tvar html = coreJsonML.toHTML(doc.data, undefined, scripts);\n\tcoreUtils.appendChildWithoutScriptExecution(rootElement, html);\n\n\treturn new Promise(function (resolve) {\n\t\tcoreUtils.executeScripts(scripts, function () {\n\t\t\t// Do not include the parent element in the path, i.e. create corePathTree on the <html>\n\t\t\t// element rather than the document element.\n\t\t\tvar targetElement = rootElement.childNodes[0];\n\t\t\tvar pathTree = corePathTree.create(targetElement, null, true);\n\t\t\tpathTree.check();\n\t\t\tresolve();\n\t\t\tcoreEvents.triggerEvent('populated', targetElement, webstrateId);\n\t\t});\n\t});\n};\n\nmodule.exports = corePopulator;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/corePopulator.js\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/corePopulator.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar coreConfigModule = {\n\tattributeValueDiffing: true\n};\n\nObject.defineProperty(coreConfigModule, 'isTransientElement', {\n\tget: function get() {\n\t\treturn config.isTransientElement;\n\t},\n\tset: function set(fn) {\n\t\tif (typeof fn !== 'function') throw new Error('isTransientElement must be a function');\n\t\treturn config.isTransientElement = fn;\n\t}\n});\n\nObject.defineProperty(coreConfigModule, 'isTransientAttribute', {\n\tget: function get() {\n\t\treturn config.isTransientAttribute;\n\t},\n\tset: function set(fn) {\n\t\tif (typeof fn !== 'function') throw new Error('isTransientAttribute must be a function');\n\t\treturn config.isTransientAttribute = fn;\n\t}\n});\n\nObject.defineProperty(coreConfigModule, 'peerConnectionConfig', {\n\tget: function get() {\n\t\treturn config.peerConnectionConfig;\n\t},\n\tset: function set(obj) {\n\t\tif ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') throw new Error('peerConnectionConfig must be an object');\n\t\treturn config.peerConnectionConfig = obj;\n\t}\n});\n\nObject.defineProperty(coreConfigModule, 'serverConfig', {\n\t// serverConfig gets injected with webpack at compile-time, the string serverConfig below will\n\t// literally be replaced with the value defined in webpack.config.js. Therefore, we have to have\n\t// the return and curly brackets, or the object itself would be interpreted as a code block, e.g.\n\t//   get: () => { threads: 4, niceWebstrateIds: true, ... },\n\tget: function get() {\n\t\treturn {\"niceWebstrateIds\":false,\"maxAssetSize\":100,\"nodeVersion\":\"v10.16.3\"};\n\t},\n\tset: function set() {\n\t\tthrow new Error('Server config is read-only');\n\t}\n});\n\nmodule.exports = coreConfigModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreConfig.js\n// module id = 16\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreConfig.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 17\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/process/browser.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar EventEmitter = __webpack_require__(51).EventEmitter;\n\nexports.EventEmitter = EventEmitter;\nexports.mixin = mixin;\n\nfunction mixin(Constructor) {\n  for (var key in EventEmitter.prototype) {\n    Constructor.prototype[key] = EventEmitter.prototype[key];\n  }\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/emitter.js\n// module id = 18\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/emitter.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n/*\nWebstrates ApplyOp (coreOpApplier.js)\n\nThis module exposes the applyOp(op, rootElement) function on the Webstrates scope. This function\napplies a subset of json0 OT operations (see https://github.com/ottypes/json0) to a DOM element.\nThe operations handled are list insertion and deletion (li and ld), as well as string insertion and\ndeletion (si and sd). These operations are generated on another client using the CreateOp module.\n*/\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar corePathTree = __webpack_require__(8);\nvar coreMutation = __webpack_require__(13);\nvar coreJsonML = __webpack_require__(12);\nvar coreDOM = __webpack_require__(6);\n\nvar coreOpApplier = {};\n\n// The 'idempotent' option allows these events to be created even if they already\n// exists. We do this, because these events also are used (and created) in coreOpCreator.\ncoreEvents.createEvent('DOMAttributeSet', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeRemoved', { idempotent: true });\ncoreEvents.createEvent('DOMNodeInserted', { idempotent: true });\ncoreEvents.createEvent('DOMNodeDeleted', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextDeletion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeDeletion', { idempotent: true });\n\nvar jsonml = {\n\tTAG_NAME_INDEX: 0,\n\tATTRIBUTE_INDEX: 1,\n\tELEMENT_LIST_OFFSET: 2\n};\n\n/**\n * Extract the XML namespace from a DOM element.\n * @param  {DOMNode} element Element.\n * @return {string}          Namespace string.\n * @private\n */\nfunction getNamespace(element) {\n\tif (!element || !element.getAttribute) {\n\t\treturn undefined;\n\t}\n\n\tif (element.closest('foreignObject') && !(element instanceof SVGForeignObjectElement)) {\n\t\treturn document.body.namespaceURI;\n\t}\n\n\treturn element.getAttribute('xmlns') ? element.getAttribute('xmlns') : element.namespaceURI;\n}\n\n/**\n * Recursively navigates an element using path to set the value as an attribute.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode. Last element of path is the attribute\n *                                key.\n * @param {string} value          Attribute value.\n * @private\n */\nfunction setAttribute(rootElement, path, cleanAttributeName, newValue) {\n\tvar _corePathTree$element = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element2 = _slicedToArray(_corePathTree$element, 1),\n\t    childElement = _corePathTree$element2[0];\n\n\t// This has been commented out as it makes non-transient attributes appear transient in protected\n\t// mode, and we don't really seem to need it. If an op comes in, it can't really be transient\n\t// after all.\n\t//if (config.isTransientAttribute(childElement, cleanAttributeName)) {\n\t//\treturn;\n\t//}\n\n\t// The __wid attribute is a unique ID assigned each node and should not be in the DOM.\n\n\n\tif (cleanAttributeName === '__wid') {\n\t\tcoreUtils.setWidOnElement(childElement, newValue);\n\t\treturn;\n\t}\n\n\t// MongoDB doesn't support periods (.) inkeys, so we store them as &dot; instead.\n\tvar attributeName = coreUtils.unescapeDots(cleanAttributeName);\n\tnewValue = coreUtils.unescape(newValue);\n\n\tvar isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\tif (isSvgPath) childElement.__d = newValue;\n\n\tvar oldValue = childElement.getAttribute(attributeName);\n\tchildElement.setAttribute(attributeName, newValue, coreDOM.elementOptions);\n\n\t// Last argument is false for not local, i.e happened on another client.\n\tcoreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue, false);\n}\n\n/**\n * Recursively navigates an element using path to remove the attribute at the end of the path.\n * @param {DOMNode} rootElement   DOMNode usf ed as root element for path navigation.\n * @param {DOMPath} path          Path to fllow on DOMNode. Last element of path is the attribute\n *                                key.\n * @private\n */\nfunction removeAttribute(rootElement, path, attributeName) {\n\tvar _corePathTree$element3 = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element4 = _slicedToArray(_corePathTree$element3, 1),\n\t    childElement = _corePathTree$element4[0];\n\n\tif (config.isTransientAttribute(childElement, attributeName)) {\n\t\treturn;\n\t}\n\n\tvar isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\tif (isSvgPath) delete childElement.__d;\n\tvar oldValue = childElement.getAttribute(attributeName);\n\tchildElement.removeAttribute(attributeName);\n\n\t// Last argument is false for not local, i.e happened on another client.\n\tcoreEvents.triggerEvent('DOMAttributeRemoved', childElement, attributeName, oldValue, false);\n}\n\n/**\n * Recursively navigates an element using path to insert an element.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {mixed} value           Element to insert, either a text string or JSON element.\n * @private\n */\nfunction insertNode(rootElement, path, value) {\n\tvar _corePathTree$element5 = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element6 = _slicedToArray(_corePathTree$element5, 3),\n\t    childElement = _corePathTree$element6[0],\n\t    childIndex = _corePathTree$element6[1],\n\t    parentElement = _corePathTree$element6[2];\n\n\tvar namespace = getNamespace(parentElement);\n\tvar newElement = typeof value === 'string' ? document.createTextNode(value) : coreJsonML.toHTML(value, namespace);\n\n\t// childElement may be undefined, and if so we insert newElement at the end of the list. If\n\t// chidElement is defined, however, we insert the element before childElement.\n\tcoreUtils.appendChildWithoutScriptExecution(parentElement, newElement, childElement);\n\n\tvar parentPathNode = corePathTree.getPathNode(parentElement);\n\tvar childPathNode = corePathTree.create(newElement, parentPathNode);\n\n\t// childPathNode may not have been created, because its parent doesn't have a PathTree (because\n\t// its a descendant of a transient element, or a transient element itself) or because the new\n\t// element itself is a transient element.\n\tif (childPathNode) {\n\t\t// Insert new element into parent PathTree.\n\t\tparentPathNode.children.splice(childIndex, 0, childPathNode);\n\t}\n\n\tcoreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);\n}\n\n/**\n * Recursively navigates an element using path to delete an element.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @private\n */\nfunction deleteNode(rootElement, path) {\n\tvar _corePathTree$element7 = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element8 = _slicedToArray(_corePathTree$element7, 3),\n\t    childElement = _corePathTree$element8[0],\n\t    childIndex = _corePathTree$element8[1],\n\t    parentElement = _corePathTree$element8[2];\n\n\t// This part is a bit of a hack, because contenteditable is a weird beast to play with.\n\t// Consider a contenteditable field with the text HELLO in it. Say user A puts a cursor before\n\t// the letter O: HELL|O. User B then makes a linebreak after the H. Now, ELLO gets removed,\n\t// setting user A's cursor after the H|, and then the ELLO part gets reinserted in a DIV element\n\t// below. Now the cursor is after H: H|, and not before the O as before: ELL|O.\n\t// To fix this issue, when something gets deleted, we try to find the next close text node, see\n\t// if its contents matches what we just removed, and if so, we set our cursor there, because it's\n\t// likely that this deletion was caused by the scenario just described.\n\n\n\tvar fakeRange = getSelectionRange(childElement);\n\tvar nextTextNode = void 0;\n\t// A text node directly after us.\n\tif (childElement.nextSibling && childElement.nextSibling.nodeType === document.TEXT_NODE) {\n\t\tnextTextNode = childElement.nextSibling;\n\t\t// A text node in an element right after us.\n\t} else if (childElement.nextElementSibling && childElement.nextElementSibling.firstChild && childElement.nextElementSibling.firstChild.nodeType === document.TEXT_NODE) {\n\t\tnextTextNode = childElement.nextElementSibling.firstChild;\n\t\t// A text node right after our parent (if we're in a DIV for instance).\n\t} else if (parentElement.nextSibling && parentElement.nextSibling.nodeType === document.TEXT_NODE) {\n\t\tnextTextNode = parentElement.nextSibling;\n\t\t// A text node in a DIV right after our parent (if we're in a DIV for instance).\n\t} else if (parentElement.nextElementSibling && parentElement.nextElementSibling.firstChild && parentElement.nextElementSibling.firstChild.nodeType === document.TEXT_NODE) {\n\t\tnextTextNode = parentElement.nextElementSibling.firstChild;\n\t}\n\n\tif (fakeRange && childElement.data && nextTextNode && nextTextNode.data === childElement.data) {\n\t\tif (fakeRange.startContainer === childElement) {\n\t\t\tfakeRange.startContainer = nextTextNode;\n\t\t}\n\t\tif (fakeRange.endContainer === childElement) {\n\t\t\tfakeRange.endContainer = nextTextNode;\n\t\t}\n\t\tsetSelectionRange(nextTextNode, fakeRange);\n\t}\n\n\t// Update PathTree to reflect the deletion.\n\t// TODO: Use PathTree.remove() instead.\n\tvar parentPathNode = corePathTree.getPathNode(parentElement);\n\t//const childPathNode = corePathTree.getPathNode(childElement, parentPathNode);\n\tparentPathNode.children.splice(childIndex, 1);\n\n\t// And remove the actual DOM node.\n\tchildElement.remove();\n\n\t// Notify nodeRemoved listeners.\n\tcoreEvents.triggerEvent('DOMNodeDeleted', childElement, parentElement, false);\n}\n\n/**\n * Replace a node, either a tag name, list of attributes or a regular node.\n * Note that this is added for compatibility with a wider array of json0 operations such as those\n * used by Webstrates file system. Webstrates itself does not create these kinds of operations.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {mixed} value           Element to insert, new tag name, or new set of attributes.\n * @private\n */\nfunction replaceNode(rootElement, path, value) {\n\tvar _corePathTree$element9 = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element10 = _slicedToArray(_corePathTree$element9, 4),\n\t    childElement = _corePathTree$element10[0],\n\t    childIndex = _corePathTree$element10[1],\n\t    parentElement = _corePathTree$element10[2],\n\t    indexType = _corePathTree$element10[3];\n\n\t// Webstrates file system has some broken parsing, so it may think JavaScript like \"< b)\" in\n\t// \"if (a < b)\" is an element and try to send a replacement op. In this case, childElement\n\t// doesn't exist. This should be solved in Webstrates file system, but we'll fix it here, too.\n\n\n\tif (!childElement) {\n\t\treturn;\n\t}\n\n\tswitch (indexType) {\n\t\t// We're renaming a tag, e.g. when <span>foo</span> should become <div>foo</div>.\n\t\tcase jsonml.TAG_NAME_INDEX:\n\t\t\t{\n\t\t\t\tvar oldElement = childElement;\n\t\t\t\tvar namespace = getNamespace(oldElement);\n\t\t\t\tvar newElement = coreJsonML.toHTML([value], namespace);\n\n\t\t\t\tvar parentPathNode = corePathTree.getPathNode(parentElement);\n\t\t\t\tif (!parentPathNode) {\n\t\t\t\t\tconsole.warn('No parentPathNode found, aborting. This shouldn\\'t happen, but...');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Move all children.\n\t\t\t\twhile (oldElement.firstChild) {\n\t\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(newElement, oldElement.firstChild);\n\t\t\t\t}\n\n\t\t\t\t// Copy all attributes.\n\t\t\t\tfor (var i = 0; i < oldElement.attributes.length; i++) {\n\t\t\t\t\tvar attr = oldElement.attributes.item(i);\n\t\t\t\t\tvar attributeName = attr.nodeName;\n\t\t\t\t\tvar isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\t\tif (isSvgPath) newElement.__d = attr.nodeValue;\n\t\t\t\t\tnewElement.setAttribute(attributeName, attr.nodeValue);\n\t\t\t\t}\n\n\t\t\t\t// Overwrite old node with new node.\n\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(parentElement, newElement, oldElement);\n\t\t\t\toldElement.remove();\n\n\t\t\t\tvar newElementPathNode = corePathTree.create(newElement, parentPathNode, true);\n\n\t\t\t\t// New element may not have a PathNode if it's a transient object.\n\t\t\t\tif (!newElementPathNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tparentPathNode.children.splice(childIndex, 1, newElementPathNode);\n\n\t\t\t\tcoreEvents.triggerEvent('DOMNodeDeleted', oldElement, parentElement, false);\n\t\t\t\tcoreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t// We're replacing an entire object of attributes by writing all the new attributes and\n\t\t// deleting old ones.\n\t\tcase jsonml.ATTRIBUTE_INDEX:\n\t\t\t{\n\t\t\t\tvar newAttributes = value;\n\t\t\t\tvar oldAttributeKeys = Array.from(childElement.attributes).map(function (attribute) {\n\t\t\t\t\treturn attribute.name;\n\t\t\t\t});\n\n\t\t\t\tvar attributes = new Set([].concat(_toConsumableArray(Object.keys(newAttributes)), _toConsumableArray(oldAttributeKeys)));\n\t\t\t\tattributes.forEach(function (attributeName) {\n\t\t\t\t\tvar isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\t\tif (attributeName in newAttributes) {\n\t\t\t\t\t\tif (isSvgPath) childElement.__d = newAttributes[attributeName];\n\t\t\t\t\t\tchildElement.setAttribute(attributeName, newAttributes[attributeName]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isSvgPath) delete childElement.__d;\n\t\t\t\t\t\tchildElement.removeAttribute(attributeName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t// Otherwise, we're just replacing a regular node.\n\t\tdefault:\n\t\t\t{\n\t\t\t\tdeleteNode(rootElement, path);\n\t\t\t\tinsertNode(rootElement, path, value);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}\n\n/**\n * Get element with cursor/selection offset. Given a negative offset, traverse through the DOM\n * tree to find the appropriate element.\n * @param  {DOMNode} element    Element to traverse from\n * @param  {Number} offset      Cursor/selection offset.\n * @return {[element, offset]}  Touple containing new element and (positive) offset.\n * @private\n */\nfunction findOffsetElement(element, offset) {\n\t// If the offset is within this element, we can return.\n\tif (offset >= 0) return [element, offset];\n\n\t// Explore the previous sibling's children if has children.\n\tif (element.lastChild) {\n\t\toffset = element.lastChild.nodeType === document.TEXT_NODE ? offset + element.lastChild.length : offset;\n\t\treturn findOffsetElement(element.lastChild, offset);\n\t}\n\n\tif (!element.previousSibling) {\n\t\t// If he element isn't a text node and has no children, we move up the tree to explore the\n\t\t// parent node.\n\t\toffset = element.parentNode.nodeType === document.TEXT_NODE ? offset + element.parentNode.length : offset;\n\t\treturn findOffsetElement(element.parentNode, offset);\n\t}\n\n\t// Explore the previous sibling if it's a text node. This recursion will converge towards a\n\t// positive offset.\n\tif (element.previousSibling.nodeType === document.TEXT_NODE) {\n\t\treturn findOffsetElement(element.previousSibling, offset + element.previousSibling.nodeValue.length);\n\t}\n}\n\n/**\n * Find selection range in node if it exists.\n * @param  {TextNode} textNode TextNode to look for Range in.\n * @return {mixed}             Basic object containing the essential properties of a Range object.\n * @private\n */\nfunction getSelectionRange(textNode) {\n\t// If there are no selections, return.\n\tif (!window.getSelection() || window.getSelection().rangeCount === 0) {\n\t\treturn;\n\t}\n\n\tvar realRange = window.getSelection().getRangeAt(0);\n\t// If selection isn't in this node, return.\n\tif (realRange.commonAncestorContainer !== textNode) {\n\t\treturn;\n\t}\n\n\t// Finally, return the range. We can't return the original range, as it may change. Since the\n\t// range is already bound to the DOM, if we clone it, the cloned range will also be bound to the\n\t// DOM. If any changes are made to the involved TextNode, then the offsets will therefore be\n\t// set to 0. Therefore, we mange a basic object containing the essential properties of a real\n\t// Range object.\n\tvar fakeRange = {\n\t\tstartOffset: realRange.startOffset,\n\t\tstartContainer: realRange.startContainer,\n\t\tendOffset: realRange.endOffset,\n\t\tendContainer: realRange.endContainer\n\t};\n\treturn fakeRange;\n}\n\n/**\n * Set selection on textnode based on fakeRange. Uses findOffsetElement to fix negative offsets.\n * @param {TextNode} textNode  TextNode to base selection around.\n * @param {mixed} fakeRange    Basic object containing the essential properties of a Range object.\n * @private\n */\nfunction setSelectionRange(textNode, fakeRange) {\n\tvar realRange = document.createRange();\n\n\tif (fakeRange.startOffset < 0) {\n\t\tvar _findOffsetElement = findOffsetElement(fakeRange.startContainer, fakeRange.startOffset),\n\t\t    _findOffsetElement2 = _slicedToArray(_findOffsetElement, 2),\n\t\t    startContainer = _findOffsetElement2[0],\n\t\t    startOffset = _findOffsetElement2[1];\n\n\t\tfakeRange.startContainer = startContainer;\n\t\tfakeRange.startOffset = startOffset;\n\t}\n\n\tif (fakeRange.endOffset < 0) {\n\t\tvar _findOffsetElement3 = findOffsetElement(fakeRange.endContainer, fakeRange.endOffset),\n\t\t    _findOffsetElement4 = _slicedToArray(_findOffsetElement3, 2),\n\t\t    endContainer = _findOffsetElement4[0],\n\t\t    endOffset = _findOffsetElement4[1];\n\n\t\tfakeRange.endContainer = endContainer;\n\t\tfakeRange.endOffset = endOffset;\n\t}\n\n\trealRange.setStart(fakeRange.startContainer, fakeRange.startOffset);\n\trealRange.setEnd(fakeRange.endContainer, fakeRange.endOffset);\n\twindow.getSelection().removeAllRanges();\n\twindow.getSelection().addRange(realRange);\n}\n\n/**\n * Recursively navigates an element using path to insert text at an index.\n * @param {DOMNode} parentElement DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {int} charIndex         Index in existing string to insert new string at.\n * @param {string} value          String to be inserted.\n * @private\n */\nfunction insertInText(rootElement, path, charIndex, value) {\n\tvar _corePathTree$element11 = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element12 = _slicedToArray(_corePathTree$element11, 4),\n\t    childElement = _corePathTree$element12[0],\n\t    /*childIndex*/parentElement = _corePathTree$element12[2],\n\t    indexType = _corePathTree$element12[3];\n\n\tvar attributeName = typeof path[path.length - 1] === 'string' ? path[path.length - 1] : undefined;\n\n\tswitch (indexType) {\n\t\tcase jsonml.TAG_NAME_INDEX:\n\t\t\t// Diff changes to tag names is not supported.\n\t\t\tthrow Error('Unsupported indexType jsonml.TAGNAME_INDEX (0)');\n\t\tcase jsonml.ATTRIBUTE_INDEX:\n\t\t\t// This is not necessarily an attribute change, because the attribute object in JsonML is\n\t\t\t// optional. Therefore, it may just be a change made to a comment or regular text node\n\t\t\t// without an attribute object. We verify by seeing if an attribute name exists.\n\t\t\tif (attributeName) {\n\t\t\t\t// Attribute value diff.\n\t\t\t\tattributeName = path.pop();\n\t\t\t\t// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,\n\t\t\t\t// which messes up our attribute diffing. We also do this in deleteInText below.\n\t\t\t\tvar isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\tvar _oldValue = childElement.getAttribute(attributeName);\n\t\t\t\tif (isSvgPath) _oldValue = childElement.__d;\n\t\t\t\tvar _newValue = _oldValue.substring(0, charIndex) + value + _oldValue.substring(charIndex);\n\t\t\t\tif (isSvgPath) childElement.__d = _newValue;\n\t\t\t\tchildElement.setAttribute(attributeName, _newValue);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, _oldValue, _newValue, false);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeTextInsertion', childElement, attributeName, charIndex, value, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t// falls through if not an attribute value change.\n\t\tdefault:\n\t\t\t// Text node or comment content change.\n\t\t\tvar isComment = parentElement.nodeType === document.COMMENT_NODE;\n\t\t\tparentElement = isComment ? parentElement : childElement;\n\t\t\tvar oldValue = parentElement.data;\n\t\t\tvar newValue = oldValue.substring(0, charIndex) + value + oldValue.substring(charIndex);\n\t\t\t// Generate current text selection range.\n\t\t\tvar fakeRange = getSelectionRange(parentElement);\n\t\t\tparentElement.data = newValue;\n\n\t\t\tif (fakeRange) {\n\t\t\t\t// Adjust the range to account for the insertion.\n\t\t\t\tif (fakeRange.endContainer === parentElement && fakeRange.endOffset > charIndex) {\n\t\t\t\t\tfakeRange.endOffset += value.length;\n\t\t\t\t\tif (fakeRange.startContainer === parentElement && fakeRange.startOffset >= charIndex) {\n\t\t\t\t\t\tfakeRange.startOffset += value.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Update selection.\n\t\t\t\tsetSelectionRange(parentElement, fakeRange);\n\t\t\t}\n\n\t\t\tcoreEvents.triggerEvent('DOMTextNodeInsertion', childElement, parentElement, charIndex, value);\n\t\t\tbreak;\n\t}\n\n\t// Create and dispatch deprecated events.\n\t// TODO: This should be removed, eventually.\n\tvar event = new CustomEvent('insertText', {\n\t\tdetail: { position: charIndex, value: value, attributeName: attributeName }\n\t});\n\tparentElement.dispatchEvent(event);\n}\n\n/**\n * Recursively navigates an element using path to delete text at an index.\n * @param {DOMNode} parentElement DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {int} charIndex         Index in existing string to remove string from.\n * @param {string} value          String to be removed.\n * @private\n */\nfunction deleteInText(rootElement, path, charIndex, value) {\n\tvar _corePathTree$element13 = corePathTree.elementAtPath(rootElement, path),\n\t    _corePathTree$element14 = _slicedToArray(_corePathTree$element13, 4),\n\t    childElement = _corePathTree$element14[0],\n\t    /*childIndex*/parentElement = _corePathTree$element14[2],\n\t    indexType = _corePathTree$element14[3];\n\n\tvar attributeName = typeof path[path.length - 1] === 'string' ? path[path.length - 1] : undefined;\n\n\tswitch (indexType) {\n\t\tcase jsonml.TAG_NAME_INDEX:\n\t\t\t// Diff changes to tag names is not supported.\n\t\t\tthrow Error('Unsupported indexType jsonml.TAGNAME_INDEX (1)');\n\t\tcase jsonml.ATTRIBUTE_INDEX:\n\t\t\tif (attributeName) {\n\t\t\t\t// Attribute value diff.\n\t\t\t\tattributeName = path.pop();\n\t\t\t\t// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,\n\t\t\t\t// which messes up our attribute diffing. We also do this in insertInText above.\n\t\t\t\tvar isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\tvar _oldValue2 = childElement.getAttribute(attributeName);\n\t\t\t\tif (isSvgPath) _oldValue2 = childElement.__d;\n\t\t\t\tvar _newValue2 = _oldValue2.substring(0, charIndex) + _oldValue2.substring(charIndex + value.length);\n\t\t\t\tif (isSvgPath) childElement.__d = _newValue2;\n\t\t\t\tchildElement.setAttribute(attributeName, _newValue2);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, _oldValue2, _newValue2, false);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeTextDeletion', childElement, attributeName, charIndex, value, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t// If not an attribute value change: falls through.\n\t\tdefault:\n\t\t\t// Text node or comment content change.\n\t\t\tvar isComment = parentElement.nodeType === document.COMMENT_NODE;\n\t\t\tparentElement = isComment ? parentElement : childElement;\n\t\t\t// Generate current text selection range.\n\t\t\tvar fakeRange = getSelectionRange(parentElement);\n\t\t\tvar oldValue = parentElement.data;\n\t\t\tvar newValue = oldValue.substring(0, charIndex) + oldValue.substring(charIndex + value.length);\n\t\t\tparentElement.data = newValue;\n\n\t\t\tif (fakeRange) {\n\t\t\t\t// Adjust the range to account for the deletion.\n\t\t\t\tif (fakeRange.endContainer === parentElement && fakeRange.endOffset > charIndex) {\n\t\t\t\t\tfakeRange.endOffset -= value.length;\n\t\t\t\t\tif (fakeRange.startContainer === parentElement && fakeRange.startOffset >= charIndex) {\n\t\t\t\t\t\tfakeRange.startOffset -= value.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Update selection.\n\t\t\t\tsetSelectionRange(parentElement, fakeRange);\n\t\t\t}\n\n\t\t\tcoreEvents.triggerEvent('DOMTextNodeDeletion', childElement, parentElement, charIndex, value);\n\t\t\tbreak;\n\t}\n\n\t// Create and dispatch deprecated events. This should be removed, eventually.\n\tvar event = new CustomEvent('deleteText', {\n\t\tdetail: { position: charIndex, value: value, attributeName: attributeName }\n\t});\n\tparentElement.dispatchEvent(event);\n\n\t// Notify deleteText listeners.\n\t//coreEvents.triggerEvent(\"deleteText\", charIndex, value, attributeName);\n}\n\n/**\n * Apply an operation to an element.\n * @param  {Op} op   Operation to be applied. Contains path and op type.\n * @param  {DOMNode} DOMNode used as root element for path navigation.\n * @public\n */\nfunction applyOp(op, rootElement) {\n\tvar charIndex = void 0,\n\t    attributeName = void 0;\n\tvar path = op.p;\n\tif (path.length === 0) {\n\t\treturn;\n\t}\n\n\t// We have to use \"prop in obj\" syntax, because not all properties have a value, necessarily\n\t// (i.e. `oi`).\n\tif ('si' in op || 'sd' in op) {\n\t\t// For string insertions and string deletions, we extract the character index from the path.\n\t\tcharIndex = path.pop();\n\t}\n\n\tif ('oi' in op || 'od' in op) {\n\t\t// For attribute insertions and attribute deletions, we extract the attribtue name from the\n\t\t// path.\n\t\tattributeName = path.pop();\n\t}\n\t// Attribute insertion (object insertion). Also catches replace operations, i.e. operations with\n\t// both `oi` and `od`.\n\tif ('oi' in op) {\n\t\treturn setAttribute(rootElement, path, attributeName, op.oi);\n\t}\n\n\t// Attribute removal (object deletion)\n\tif ('od' in op) {\n\t\treturn removeAttribute(rootElement, path, attributeName);\n\t}\n\n\t// String deletion.\n\tif ('sd' in op) {\n\t\treturn deleteInText(rootElement, path, charIndex, op.sd);\n\t}\n\n\t// String insertion.\n\tif ('si' in op) {\n\t\treturn insertInText(rootElement, path, charIndex, op.si);\n\t}\n\n\t// Node replacement, either a regular node, tag renaming, or a complete replacement of\n\t// attributes.\n\tif ('li' in op && 'ld' in op) {\n\t\treturn replaceNode(rootElement, path, op.li);\n\t}\n\n\t// Element deletion operation (list deletion).\n\tif ('ld' in op) {\n\t\treturn deleteNode(rootElement, path);\n\t}\n\n\t// Element insertion operation (list insertion).\n\tif ('li' in op) {\n\t\treturn insertNode(rootElement, path, op.li);\n\t}\n}\n\ncoreOpApplier.listenForOpsAndApplyOn = function (rootElement) {\n\tcoreEvents.addEventListener('receivedOps', function (ops) {\n\t\t// We disable the mutation observers before applying the operations. Otherwise, applying the\n\t\t// operations would cause new mutations to be created, which in turn would cause the\n\t\t// creation of new operations, leading to a livelock for all clients.\n\t\tcoreMutation.pause();\n\n\t\tops.forEach(function (op) {\n\t\t\tapplyOp(op, rootElement);\n\t\t});\n\n\t\t// And re-enable MuationObservers.\n\t\tcoreMutation.resume();\n\t}, coreEvents.PRIORITY.IMMEDIATE);\n};\n\nmodule.exports = coreOpApplier;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreOpApplier.js\n// module id = 19\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/coreOpApplier.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar coreUtils = __webpack_require__(0);\nvar coreEvents = __webpack_require__(1);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\nvar nodeObjects = __webpack_require__(10);\n\nvar signalingModule = {};\n\ncoreEvents.createEvent('receivedSignal');\n\nvar websocket = coreWebsocket.copy(function (event) {\n\treturn event.data.startsWith('{\"wa\":\"publish\"');\n});\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\n// Allow other modules to add interceptors to signals. An interceptor is function that gets access\n// to a signal payload, then decides whether this module should handle the signal as a regular\n// signal. For instance, the signal streaming module uses the signaling mechanism to set up\n// streaming connections, but we don't want the streaming signals to be triggering regular signals\n// on nodes. Therefore, the streaming module intercepts all signals, and handles the streaming\n// signals and then returns true to intercept it.\nvar interceptors = new Set();\n\nsignalingModule.addInterceptor = function (interceptor) {\n\treturn interceptors.add(interceptor);\n};\nsignalingModule.removeInterceptor = function (interceptor) {\n\treturn interceptors.delete(interceptor);\n};\n\n// Allow other modules to subscribe manually to a node. This is useful for interception. E.g. signal\n// streaming needs to subscribe to nodes, but subscribing in the \"normal\" way will be silly, since\n// the callback given there will never be triggered, because we intercept all the signals.\nsignalingModule.subscribe = function (wid) {\n\treturn subscribe(wid);\n};\nsignalingModule.unsubscribe = function (wid) {\n\treturn unsubscribe(wid);\n};\n\nwebsocket.onjsonmessage = function (payload) {\n\t// Ignore message intended for other webstrates sharing the same websocket.\n\tif (payload.d !== webstrateId) return;\n\n\tvar intercepted = false;\n\tinterceptors.forEach(function (interceptor) {\n\t\tintercepted |= interceptor(payload);\n\t});\n\t// If any of the interceptors has returned true, we don't want to process the signal, as the\n\t// intercepting module has already done what needs to be done with it.\n\tif (intercepted) return;\n\n\tvar wid = payload.id;\n\tvar node = coreUtils.getElementByWid(wid);\n\tif (!node && wid !== 'document') {\n\t\treturn;\n\t}\n\n\tvar senderId = payload.s;\n\tvar message = payload.m;\n\tvar eventObject = nodeObjects.getEventObject(node);\n\n\t// Trigger event in userland.\n\tvar triggerTarget = node ? eventObject : globalObject;\n\ttriggerTarget.triggerEvent('signal', message, senderId, node);\n\n\t// Trigger event internally.\n\tcoreEvents.triggerEvent('receivedSignal', message, senderId, node);\n};\n\n// Map of wids to number of subscribers on the wid. Used to resubscribe after a disconnect.\nvar subscriptions = {};\n\nfunction signal(wid, message, recipients) {\n\tvar msgObj = {\n\t\twa: 'publish',\n\t\td: webstrateId,\n\t\tid: wid,\n\t\tm: message\n\t};\n\tif (recipients) {\n\t\tmsgObj.recipients = recipients;\n\t}\n\twebsocket.send(msgObj);\n}\n\nfunction subscribe(wid) {\n\tvar msgObj = {\n\t\twa: 'subscribe',\n\t\td: webstrateId,\n\t\tid: wid\n\t};\n\twebsocket.send(msgObj);\n\tsubscriptions[wid] = (subscriptions[wid] || 0) + 1;\n}\n\nfunction unsubscribe(wid) {\n\tsubscriptions[wid] = (subscriptions[wid] || 0) - 1;\n\tif (subscriptions[wid] < 1) {\n\t\tvar msgObj = {\n\t\t\twa: 'unsubscribe',\n\t\t\td: webstrateId,\n\t\t\tid: wid\n\t\t};\n\t\twebsocket.send(msgObj);\n\t\tdelete subscriptions[wid];\n\t}\n}\n\nfunction setupSignal(node, publicObject, eventObject) {\n\t// Text nodes and won't have wids, meaning there's way for us to signal on them, and thus it'd be\n\t// pointless to add a signaling method and event.\n\tif (node.nodeType === document.TEXT_NODE) {\n\t\treturn;\n\t}\n\n\t// If an element doesn't have a wid, it's because we haven't registered it in the DOM yet,\n\t// meaning nobody can signal on it. However, we still allow users to subscribe to signals on\n\t// the event, in case the element gets a wid in the next cycle. If it doesn't get a wid in\n\t// time, we warn the user that they subscribed to a signal that doesn't exist.\n\teventObject.createEvent('signal', {\n\t\taddListener: function addListener() {\n\t\t\tvar wid = publicObject.id;\n\t\t\tif (wid) {\n\t\t\t\tsubscribe(wid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetImmediate(function () {\n\t\t\t\tvar wid = publicObject.id;\n\t\t\t\tif (wid) {\n\t\t\t\t\tsubscribe(wid);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.warn('Signal event listener attached to ' + node.outerHTML + ', but element can\\'t be' + ' signaled on, because it\\'s not in the DOM or is transient.');\n\t\t\t});\n\t\t},\n\t\tremoveListener: function removeListener() {\n\t\t\tvar wid = publicObject.id;\n\t\t\tunsubscribe(wid);\n\t\t}\n\t});\n\n\tObject.defineProperty(publicObject, 'signal', {\n\t\tvalue: function value(message, recipients) {\n\t\t\tvar wid = publicObject.id;\n\t\t\tif (wid) {\n\t\t\t\tsignal(wid, message, recipients);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('Can\\'t signal on ' + node.outerHTML + ', because it\\'s not in the DOM or is' + ' transient.');\n\t\t},\n\t\twritable: false\n\t});\n}\n\ncoreEvents.addEventListener('populated', function (targetElement) {\n\tsetupSignal(targetElement, globalObject.publicObject, globalObject);\n});\n\n// Add signal events to all webstrate objects (with a wid) after the document has been populated.\ncoreEvents.addEventListener('webstrateObjectsAdded', function (nodeTree) {\n\tcoreUtils.recursiveForEach(nodeTree, function (node) {\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tsetupSignal(node, node.webstrate, eventObject);\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// Add signal events to all webstrate objects (with wid) after they're added continually.\ncoreEvents.addEventListener('webstrateObjectAdded', function (node, eventObject) {\n\tsetupSignal(node, node.webstrate, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('reconnect', function () {\n\treturn Object.keys(subscriptions).forEach(subscribe);\n});\n\nmodule.exports = signalingModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/signaling.js\n// module id = 20\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/signaling.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar makeError = __webpack_require__(52);\n\nfunction ShareDBError(code, message) {\n  ShareDBError.super.call(this, message);\n  this.code = code;\n}\n\nmakeError(ShareDBError);\n\nmodule.exports = ShareDBError;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/error.js\n// module id = 21\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/error.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Logger = __webpack_require__(60);\nvar logger = new Logger();\nmodule.exports = logger;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/logger/index.js\n// module id = 22\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/logger/index.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.defaultType = __webpack_require__(53).type;\n\nexports.map = {};\n\nexports.register = function (type) {\n  if (type.name) exports.map[type.name] = type;\n  if (type.uri) exports.map[type.uri] = type;\n};\n\nexports.register(exports.defaultType);\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/types.js\n// module id = 23\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/types.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.doNothing = doNothing;\nfunction doNothing() {}\n\nexports.hasKeys = function (object) {\n  for (var key in object) {\n    return true;\n  }return false;\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nexports.isInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nexports.isValidVersion = function (version) {\n  if (version === null) return true;\n  return exports.isInteger(version) && version >= 0;\n};\n\nexports.isValidTimestamp = function (timestamp) {\n  return exports.isValidVersion(timestamp);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/util.js\n// module id = 24\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/util.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\n\nvar assetsModule = {};\n\n// Create internal event that other modules may subscribe to\ncoreEvents.createEvent('asset');\n\n// Create event in userland.\nglobalObject.createEvent('asset');\n\nvar assets = void 0;\n\nvar websocket = coreWebsocket.copy(function (event) {\n\treturn event.data.startsWith('{\"wa\":');\n});\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\nwebsocket.onjsonmessage = function (message) {\n\tif (message.d !== webstrateId) return;\n\tswitch (message.wa) {\n\t\tcase 'assets':\n\t\t\tassets = message.assets;\n\t\t\tbreak;\n\t\tcase 'asset':\n\t\t\tassets.push(message.asset);\n\t\t\tcoreEvents.triggerEvent('asset', message.asset);\n\t\t\tglobalObject.triggerEvent('asset', message.asset);\n\t\t\tbreak;\n\t}\n};\n\n// Define webstrate.assets. Returns a frozen copy, so users won't modify it.\nObject.defineProperty(globalObject.publicObject, 'assets', {\n\tget: function get() {\n\t\treturn Object.freeze(coreUtils.objectClone(assets));\n\t}\n});\n\n/**\n * Makes it possible to select and upload files.\n * @param  {Function} callback Callback with two arguments, error and response. First argument will\n *                             be null on success.\n * @return {Promise}  Promise that gets resolved with the result.\n * @public\n */\nglobalObject.publicObject.uploadAsset = function () {\n\tvar callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\treturn new Promise(function (accept, reject) {\n\t\tvar input = document.createElement('input');\n\t\tinput.setAttribute('multiple', true);\n\t\tinput.setAttribute('type', 'file');\n\n\t\tinput.addEventListener('change', function (event) {\n\t\t\tvar formData = new FormData();\n\t\t\tObject.entries(options).forEach(function (_ref) {\n\t\t\t\tvar _ref2 = _slicedToArray(_ref, 2),\n\t\t\t\t    key = _ref2[0],\n\t\t\t\t    value = _ref2[1];\n\n\t\t\t\treturn formData.append(key, value);\n\t\t\t});\n\n\t\t\tfor (var i = 0; i < input.files.length; i++) {\n\t\t\t\tformData.append('file[]', input.files.item(i));\n\t\t\t}\n\n\t\t\tfetch('', {\n\t\t\t\tmethod: 'post',\n\t\t\t\tcredentials: 'include',\n\t\t\t\tbody: formData\n\t\t\t}).then(function (res) {\n\t\t\t\treturn res.json().then(function (json) {\n\t\t\t\t\tif (res.ok) {\n\t\t\t\t\t\taccept(json);\n\t\t\t\t\t\tcallback(null, json);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(json.error);\n\t\t\t\t\t\tcallback(json.error);\n\t\t\t\t\t}\n\t\t\t\t}).catch(function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t}).catch(function (err) {\n\t\t\t\treject(err);\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t});\n\n\t\tinput.click();\n\t});\n};\n\nglobalObject.publicObject.deleteAsset = function (assetName, callback) {\n\twebsocket.send({ wa: 'deleteAsset', d: webstrateId, assetName: assetName }, function (err, result) {\n\t\treturn callback && callback(err, result);\n\t});\n};\n\nglobalObject.publicObject.searchAsset = function (assetIdentifier) {\n\tvar query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\tvar callback = arguments[2];\n\n\tif (typeof callback !== 'function') throw new Error('Must provide callback function');\n\n\tvar _assetIdentifier$spli = assetIdentifier.split('/'),\n\t    _assetIdentifier$spli2 = _slicedToArray(_assetIdentifier$spli, 2),\n\t    assetName = _assetIdentifier$spli2[0],\n\t    assetVersion = _assetIdentifier$spli2[1];\n\n\twebsocket.send({ wa: 'assetSearch', d: webstrateId, assetName: assetName, assetVersion: +assetVersion,\n\t\tquery: query.query, sort: query.sort, limit: query.limit, skip: query.skip }, function (err, result) {\n\t\treturn callback(err, result.records, result.count);\n\t});\n};\n\nmodule.exports = assetsModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/assets.js\n// module id = 25\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/assets.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\nvar loadedEvent = __webpack_require__(9);\nvar coreUtils = __webpack_require__(0);\nvar clientManagerModule = {};\n\n// In static mode, the client list is not being sent to the client.\nif (!coreUtils.getLocationObject().staticMode) {\n\t// Create internal events that other modules may subscribe to\n\tcoreEvents.createEvent('clientsReceived');\n\tcoreEvents.createEvent('clientJoin');\n\tcoreEvents.createEvent('clientPart');\n\n\t// Delay the loaded event, until the 'clientsReceied' event has been triggered.\n\tloadedEvent.delayUntil('clientsReceived');\n\n\t// Create events in userland.\n\tglobalObject.createEvent('clientJoin');\n\tglobalObject.createEvent('clientJoin*');\n\tglobalObject.createEvent('clientPart');\n\tglobalObject.createEvent('clientPart*');\n\n\tvar websocket = coreWebsocket.copy(function (event) {\n\t\treturn event.data.startsWith('{\"wa\":');\n\t});\n\tvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\n\t// We initialize clients, so we won't do splice/indexOf if we receive a clientPart\n\t// event before a hello event.\n\tvar clientId = void 0,\n\t    clients = [];\n\n\tObject.defineProperty(globalObject.publicObject, 'clients', {\n\t\tget: function get() {\n\t\t\treturn coreUtils.objectCloneAndLock(clients);\n\t\t}\n\t});\n\n\tObject.defineProperty(globalObject.publicObject, 'clientId', {\n\t\tget: function get() {\n\t\t\treturn clientId;\n\t\t}\n\t});\n\n\twebsocket.onjsonmessage = function (message) {\n\t\t// Ignore message intended for other webstrates sharing the same websocket.\n\t\tif (message.d !== webstrateId) return;\n\n\t\tswitch (message.wa) {\n\t\t\tcase 'hello':\n\t\t\t\t{\n\t\t\t\t\tclients = message.clients;\n\t\t\t\t\tclientId = message.id;\n\n\t\t\t\t\t// Trigger internally.\n\t\t\t\t\tcoreEvents.triggerEvent('clientsReceived');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'clientJoin':\n\t\t\t\t{\n\t\t\t\t\tvar joiningClientId = message.id;\n\t\t\t\t\tvar isOwnJoin = clientId === joiningClientId;\n\t\t\t\t\t// Own join will already be in the client list.\n\t\t\t\t\tif (!isOwnJoin) {\n\t\t\t\t\t\tclients.push(joiningClientId);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Trigger internally.\n\t\t\t\t\tcoreEvents.triggerEvent('clientJoin', joiningClientId);\n\n\t\t\t\t\t// Trigger in userland.\n\t\t\t\t\tif (!isOwnJoin) {\n\t\t\t\t\t\tglobalObject.triggerEvent('clientJoin', joiningClientId, isOwnJoin);\n\t\t\t\t\t}\n\t\t\t\t\tglobalObject.triggerEvent('clientJoin*', joiningClientId, isOwnJoin);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 'clientPart':\n\t\t\t\t{\n\t\t\t\t\tvar partingClientId = message.id;\n\t\t\t\t\tvar partingClientIdIdx = clients.indexOf(partingClientId);\n\t\t\t\t\t// If we haven't registered the client joining, don't register it leaving (and also don't\n\t\t\t\t\t// try to remove it from the client list. That won't end well.)\n\t\t\t\t\tif (partingClientIdIdx === -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tclients.splice(partingClientIdIdx, 1);\n\n\t\t\t\t\t// Trigger internally.\n\t\t\t\t\tcoreEvents.triggerEvent('clientPart', partingClientId);\n\n\t\t\t\t\t// Trigger in userland.\n\t\t\t\t\tvar isOwnPart = clientId === partingClientId;\n\t\t\t\t\tif (!isOwnPart) {\n\t\t\t\t\t\tglobalObject.triggerEvent('clientPart', partingClientId, isOwnPart);\n\t\t\t\t\t}\n\t\t\t\t\tglobalObject.triggerEvent('clientPart*', partingClientId, isOwnPart);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t};\n\n\t// The server delays firing the 'clientJoin' event until the joining client is ready.\n\t// If we didn't do that, another client might send a message to the joining client immediately\n\t// after the 'clientJoin' event has been triggered. At this point, however, the joining client's\n\t// scripts haven't been run (they usually aren't executed until after the userland 'loaded' event\n\t// has been triggered), so the joining client won't be able to receive the data. Therefore, we\n\t// delay this 'clientJoin' message, until after the userland 'loaded' event has been triggered, so\n\t// that we know the joining client will be ready to handle the reactions of the join.\n\n\t// Note that if the server doesn't receive a ready event within 2 seconds, it sends it out anyway.\n\t// That way, no clients can linger unnoticed in a document.\n\tcoreEvents.addEventListener('loadedTriggered', function () {\n\t\twebsocket.send({ wa: 'ready', d: webstrateId });\n\t});\n}\n\nmodule.exports = clientManagerModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/clientManager.js\n// module id = 26\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/clientManager.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\n\n// Create internal events that other modules may subscribe to\ncoreEvents.createEvent('connect');\ncoreEvents.createEvent('disconnect');\ncoreEvents.createEvent('reconnect');\n\n// Create events in userland.\nglobalObject.createEvent('disconnect');\nglobalObject.createEvent('reconnect');\n\nvar websocket = coreWebsocket.copy();\n\nvar previousState = websocket.readyState;\n\nwebsocket.onopen = function (event) {\n\t// If this is the first time we're connecting.\n\tif (previousState === WebSocket.CONNECTING) {\n\t\tcoreEvents.triggerEvent('connect');\n\t\t// If we've been connected before.\n\t} else if (previousState === WebSocket.CLOSED) {\n\t\tcoreEvents.triggerEvent('reconnect');\n\t\tglobalObject.triggerEvent('reconnect');\n\t}\n\tpreviousState = websocket.readyState;\n};\n\nwebsocket.onerror = websocket.onclose = function (event) {\n\t// When attempting to reconnect, onclose will get triggered on every reconnecion attempt, but we\n\t// don't want the disconnect event to get triggered every time we fail to connect, so we just\n\t// check if we're in the same state as before (WebSocket.CLOSED (3)). If we are, we are in a\n\t// reconnection loop, so there's no reason to fire 'disconnect' again.\n\tif (previousState === websocket.readyState) return;\n\tpreviousState = websocket.readyState;\n\tcoreEvents.triggerEvent('disconnect');\n\tglobalObject.triggerEvent('disconnect');\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/connectionEvents.js\n// module id = 27\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/connectionEvents.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\nvar userObject = __webpack_require__(11);\nvar coreUtils = __webpack_require__(0);\n\nvar cookiesModule = {};\n\nvar websocket = coreWebsocket.copy(function (event) {\n\treturn event.data.startsWith('{\"wa\":');\n});\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\nglobalObject.createEvent('cookieUpdateHere');\nglobalObject.createEvent('cookieUpdateAnywhere');\n\nfunction updateCookie(key, value) {\n\tvar isAnywhere = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n\tvar updateObj = {\n\t\twa: 'cookieUpdate',\n\t\tupdate: { key: key, value: value }\n\t};\n\tif (!isAnywhere) {\n\t\tupdateObj.d = globalObject.publicObject.webstrateId;\n\t}\n\twebsocket.send(updateObj);\n}\n\nvar cookies = void 0;\nwebsocket.onjsonmessage = function (message) {\n\tswitch (message.wa) {\n\t\tcase 'hello':\n\t\t\tif (message.d !== webstrateId) return;\n\n\t\t\tcookies = message.cookies || { here: {}, anywhere: {} };\n\n\t\t\t// Only allow cookies if the user object exists, i.e. is logged in with OAuth.\n\t\t\tif (userObject.publicObject.userId && userObject.publicObject.userId !== 'anonymous:') {\n\t\t\t\tuserObject.publicObject.cookies = {\n\t\t\t\t\tanywhere: {\n\t\t\t\t\t\tget: function get(key) {\n\t\t\t\t\t\t\treturn key ? cookies.anywhere[key] : cookies.anywhere;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function set(key, value) {\n\t\t\t\t\t\t\tcookies.anywhere[key] = value;\n\t\t\t\t\t\t\tupdateCookie(key, value, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\there: {\n\t\t\t\t\t\tget: function get(key) {\n\t\t\t\t\t\t\treturn key ? cookies.here[key] : cookies.here;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function set(key, value, callback) {\n\t\t\t\t\t\t\tcookies.here[key] = value;\n\t\t\t\t\t\t\tupdateCookie(key, value, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'cookieUpdate':\n\t\t\tif (typeof message.d !== 'undefined' && message.d !== webstrateId) return;\n\n\t\t\tvar _ref = [message.update.key, message.update.value],\n\t\t\t    key = _ref[0],\n\t\t\t    value = _ref[1];\n\n\t\t\tif (message.d) {\n\t\t\t\tcookies.here[key] = value;\n\t\t\t\tglobalObject.triggerEvent('cookieUpdateHere', key, value);\n\t\t\t} else {\n\t\t\t\tcookies.anywhere[key] = value;\n\t\t\t\tglobalObject.triggerEvent('cookieUpdateAnywhere', key, value);\n\t\t\t}\n\t\t\tbreak;\n\t}\n};\n\nmodule.exports = cookiesModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/cookies.js\n// module id = 28\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/cookies.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar globalObject = __webpack_require__(2);\nvar coreDatabase = __webpack_require__(7);\n\nvar resolves = [];\n\n// Defines the `dataSaved` event on the webstrate object. A call to this function retunrs a promise\n// that will get resolved once all ops have been successfully been received by the server and\n// submitted to the database.\nObject.defineProperty(globalObject.publicObject, 'dataSaved', {\n\tget: function get() {\n\t\treturn function () {\n\t\t\treturn new Promise(function (accept, reject) {\n\t\t\t\t//Make sure that any mutations are actually picked up by mutation observers.\n\t\t\t\t//As dataSaved() might be called in same Task as the mutation introducing code.\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t// If there are no pending operations (i.e. ops the server is yet to acknowledge), resolve\n\t\t\t\t\t// immediately.\n\t\t\t\t\tif (!coreDatabase.getDocument().hasPending()) accept();\n\t\t\t\t\t// Otherwise, add the promise's accept resolver to a list, so we can resolve it once the\n\t\t\t\t\t// pending operations have been acknowledged.\n\t\t\t\t\telse resolves.push(accept);\n\t\t\t\t}, 0);\n\t\t\t});\n\t\t};\n\t},\n\tset: function set() {\n\t\tthrow new Error('dataSaved cannot be overwritten');\n\t},\n\tenumerable: true\n});\n\n// Listen for opsAcknowledged event (created by coreDatabase), then trigger all listeners and remove\n// them. We don't want to trigger these promises multiple times.\ncoreEvents.addEventListener('opsAcknowledged', function () {\n\tresolves.forEach(function (accept) {\n\t\treturn accept();\n\t});\n\tresolves = [];\n}, coreEvents.PRIORITY.LAST);\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/dataSavedEvent.js\n// module id = 29\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/dataSavedEvent.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreEvents = __webpack_require__(1);\nvar globalObject = __webpack_require__(2);\nvar corePathTree = __webpack_require__(8);\n\n// Create events in userland.\nglobalObject.createEvent('editingError');\n\ncoreEvents.addEventListener('databaseError', function (error) {\n\tif (error.data.a !== 'op') return;\n\terror.data.op.forEach(function (op) {\n\t\tvar _corePathTree$element = corePathTree.elementAtPath(document.documentElement, op.p),\n\t\t    _corePathTree$element2 = _slicedToArray(_corePathTree$element, 3),\n\t\t    parentElement = _corePathTree$element2[2];\n\n\t\tvar type = ['si', 'sd', 'oi', 'od', 'li', 'ld'].find(function (type) {\n\t\t\treturn type in op;\n\t\t});\n\t\tglobalObject.triggerEvent('editingError', type, parentElement);\n\t});\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/databaseErrors.js\n// module id = 30\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/databaseErrors.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar nodeObjects = __webpack_require__(10);\n\n/**\n * Create public events on all webstrate objects on DOM nodes.\n * @param  {DOMNode} node       Node containing webstrate element.\n * @param  {Object} eventObject Event object associated to the webstrate element.\n * @private\n */\nfunction createEventsOnEventObject(node, eventObject) {\n\tswitch (node.nodeType) {\n\t\tcase document.ELEMENT_NODE:\n\t\t\t// Prime events (\"*\" suffix) gets triggered for local events, too. I.e. is a remote user\n\t\t\t// changes an attribute, both attributeChanged and attributeChanged* gets triggered. However,\n\t\t\t// if the local user changes an attribute, only atributeChanged* gets triggered.\n\t\t\teventObject.createEvent('attributeChanged');\n\t\t\teventObject.createEvent('attributeChanged*');\n\t\t\teventObject.createEvent('nodeAdded');\n\t\t\teventObject.createEvent('nodeAdded*');\n\t\t\teventObject.createEvent('nodeRemoved');\n\t\t\teventObject.createEvent('nodeRemoved*');\n\t\t// falls through\n\t\tcase document.TEXT_NODE:\n\t\t\teventObject.createEvent('insertText');\n\t\t\teventObject.createEvent('insertText*');\n\t\t\teventObject.createEvent('deleteText');\n\t\t\teventObject.createEvent('deleteText*');\n\t\t\tbreak;\n\t}\n}\n\n// This gets triggered (in nodeObjects) when the page has loaded initially and nodes have had\n// webstrate objects added to them.\ncoreEvents.addEventListener('webstrateObjectsAdded', function (nodes) {\n\tcoreUtils.recursiveForEach(nodes, function (node) {\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tcreateEventsOnEventObject(node, eventObject);\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeSet', function (node, attributeName, oldValue, newValue, local) {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\t// Only trigger the main event for remote changes (i.e. changes made by other clients).\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('attributeChanged', attributeName, oldValue, newValue, !!local);\n\t\t}\n\t\t// But do trigger the \"prime\" event for all changes, including local changes.\n\t\teventObject.triggerEvent('attributeChanged*', attributeName, oldValue, newValue, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeRemoved', function (node, attributeName, oldValue, local) {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('attributeChanged', attributeName, oldValue, undefined, !!local);\n\t\t}\n\t\teventObject.triggerEvent('attributeChanged*', attributeName, oldValue, undefined, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMNodeInserted', function (node, parentElement, local) {\n\t\t// Finding the event object of the parent instead of the node itself, as firing the event\n\t\t// on the node itself isn't very useful.\n\t\tvar eventObject = nodeObjects.getEventObject(parentElement);\n\n\t\t// They parent may have been deleted, in which case there's no event object.\n\t\tif (!eventObject) return;\n\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('nodeAdded', node, !!local);\n\t\t}\n\t\teventObject.triggerEvent('nodeAdded*', node, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMNodeDeleted', function (node, parentElement, local) {\n\t\t// Finding the event object of the parent instead of the node itself, as firing the event\n\t\t// on the node itself isn't very useful.\n\t\tvar eventObject = nodeObjects.getEventObject(parentElement);\n\n\t\t// They parent may have been deleted, in which case there's no event object.\n\t\tif (!eventObject) return;\n\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('nodeRemoved', node, !!local);\n\t\t}\n\t\teventObject.triggerEvent('nodeRemoved*', node, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeTextInsertion', function (node, attributeName, position, value, local) {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('insertText', position, value, attributeName, !!local);\n\t\t}\n\t\teventObject.triggerEvent('insertText*', position, value, attributeName, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMTextNodeInsertion', function (node, parentElement, position, value, local) {\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('insertText', position, value, !!local);\n\t\t}\n\t\teventObject.triggerEvent('insertText*', position, value, !!local);\n\t\t// Also trigger on parent.\n\t\tif (parentElement.nodeType === document.ELEMENT_NODE) {\n\t\t\teventObject = nodeObjects.getEventObject(parentElement);\n\t\t\tif (!local) {\n\t\t\t\teventObject.triggerEvent('insertText', position, value, !!local);\n\t\t\t}\n\t\t\teventObject.triggerEvent('insertText*', position, value, !!local);\n\t\t}\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeTextDeletion', function (node, attributeName, position, value, local) {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tif (!local) {\n\t\t\teventObject.triggerEvent('deleteText', position, value, attributeName, !!local);\n\t\t}\n\t\teventObject.triggerEvent('deleteText*', position, value, attributeName, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMTextNodeDeletion', function (node, parentElement, position, value, local) {\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tif (eventObject) {\n\t\t\tif (!local) {\n\t\t\t\teventObject.triggerEvent('deleteText', position, value, !!local);\n\t\t\t}\n\t\t\teventObject.triggerEvent('deleteText*', position, value, !!local);\n\t\t}\n\t\t// Also trigger on parent.\n\t\tif (parentElement.nodeType === document.ELEMENT_NODE) {\n\t\t\teventObject = nodeObjects.getEventObject(parentElement);\n\t\t\tif (!local) {\n\t\t\t\teventObject.triggerEvent('deleteText', position, value, !!local);\n\t\t\t}\n\t\t\teventObject.triggerEvent('deleteText*', position, value, !!local);\n\t\t}\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// This gets triggered when an node gets added after the initial page load.\ncoreEvents.addEventListener('webstrateObjectAdded', function (node, eventObject) {\n\tcreateEventsOnEventObject(node, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/domEvents.js\n// module id = 31\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/domEvents.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nif (config.keepAliveInterval) {\n\tvar coreWebsocket = __webpack_require__(3);\n\n\tvar websocket = coreWebsocket.copy();\n\tvar interval = void 0;\n\n\twebsocket.onopen = function (event) {\n\t\tinterval = setInterval(function () {\n\t\t\twebsocket.send({ type: 'alive' });\n\t\t}, config.keepAliveInterval * 1000);\n\t};\n\n\twebsocket.onclose = websocket.onerror = function (event) {\n\t\tclearInterval(interval);\n\t};\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/keepAlive.js\n// module id = 32\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/keepAlive.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\n\nvar messagesModule = {};\n\n// Messaging is disabled in static mode, because no 'hello' message is received, there's no client\n// list, etc.\nif (!coreUtils.getLocationObject().staticMode) {\n\t// Create internal event that other modules may subscribe to\n\tcoreEvents.createEvent('messageReceived');\n\tcoreEvents.createEvent('messageSent');\n\tcoreEvents.createEvent('messageDeleted');\n\tcoreEvents.createEvent('allMessagesDeleted');\n\n\t// Create event in userland.\n\tglobalObject.createEvent('messageReceived');\n\tglobalObject.createEvent('messageDeleted');\n\n\tvar websocket = coreWebsocket.copy(function (event) {\n\t\treturn event.data.startsWith('{\"wa\":');\n\t});\n\n\tvar messages = void 0;\n\n\tvar defineMessageProperties = function defineMessageProperties() {\n\t\t// If we're reconnecting, these properties will already exist.\n\t\tif (globalObject.publicObject.messages) return;\n\n\t\tObject.defineProperty(globalObject.publicObject, 'messages', {\n\t\t\tget: function get() {\n\t\t\t\treturn coreUtils.objectCloneAndLock(messages);\n\t\t\t},\n\t\t\tset: function set() {\n\t\t\t\tthrow new Error('webstrate.messages is read-only. Use webstrate.deleteMessage(messageId) ' + 'or webstrate.deleteMessages() to delete a message');\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(globalObject.publicObject, 'message', {\n\t\t\tvalue: function value(message, recipients) {\n\t\t\t\tvar msgObj = {\n\t\t\t\t\twa: 'sendMessage',\n\t\t\t\t\tm: message,\n\t\t\t\t\trecipients: recipients\n\t\t\t\t};\n\t\t\t\twebsocket.send(msgObj);\n\t\t\t},\n\t\t\twritable: false\n\t\t});\n\n\t\tObject.defineProperty(globalObject.publicObject, 'deleteMessage', {\n\t\t\tvalue: function value(messageId) {\n\t\t\t\twebsocket.send({\n\t\t\t\t\twa: 'deleteMessage', messageId: messageId\n\t\t\t\t});\n\t\t\t\treturn !!messages.find(function (message) {\n\t\t\t\t\treturn message.messageId === messageId;\n\t\t\t\t});\n\t\t\t},\n\t\t\twritable: false\n\t\t});\n\n\t\tObject.defineProperty(globalObject.publicObject, 'deleteAllMessages', {\n\t\t\tvalue: function value() {\n\t\t\t\tmessages = [];\n\t\t\t\twebsocket.send({\n\t\t\t\t\twa: 'deleteAllMessages'\n\t\t\t\t});\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\twritable: false\n\t\t});\n\t};\n\n\twebsocket.onjsonmessage = function (message) {\n\t\tswitch (message.wa) {\n\t\t\tcase 'hello':\n\t\t\t\t{\n\t\t\t\t\tmessages = message.messages || [];\n\t\t\t\t\tmessages.forEach(function (message) {\n\t\t\t\t\t\treturn Object.freeze(message);\n\t\t\t\t\t});\n\t\t\t\t\tif (message.user.userId !== 'anonymous:') {\n\t\t\t\t\t\tdefineMessageProperties();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'message':\n\t\t\t\t{\n\t\t\t\t\tmessage = {\n\t\t\t\t\t\tmessageId: message.messageId,\n\t\t\t\t\t\tmessage: message.message,\n\t\t\t\t\t\tsenderId: message.senderId\n\t\t\t\t\t};\n\t\t\t\t\tObject.freeze(message);\n\t\t\t\t\tmessages.push(message);\n\t\t\t\t\tcoreEvents.triggerEvent('messageReceived', message);\n\t\t\t\t\tglobalObject.triggerEvent('messageReceived', message.message, message.senderId, message.messageId);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'messageDeleted':\n\t\t\t\t{\n\t\t\t\t\tvar messageIndex = messages.findIndex(function (m) {\n\t\t\t\t\t\treturn m.messageId === message.messageId;\n\t\t\t\t\t});\n\t\t\t\t\tif (messageIndex === -1) return;\n\t\t\t\t\tmessages.splice(messageIndex, 1);\n\t\t\t\t\tcoreEvents.triggerEvent('messageDeleted', message);\n\t\t\t\t\tglobalObject.triggerEvent('messageDeleted', message.messageId);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'allMessagesDeleted':\n\t\t\t\t{\n\t\t\t\t\tvar oldMessages = messages;\n\t\t\t\t\tmessages = [];\n\t\t\t\t\tcoreEvents.triggerEvent('allMessagesDeleted', message);\n\t\t\t\t\toldMessages.forEach(function (message) {\n\t\t\t\t\t\treturn globalObject.triggerEvent('messageDeleted', message.messageId);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t};\n\n\tcoreEvents.addEventListener('loadedTriggered', function () {\n\t\tif (messages.length > 0) {\n\t\t\tmessages.forEach(function (message) {\n\t\t\t\tcoreEvents.triggerEvent('messageReceived', message);\n\t\t\t\tglobalObject.triggerEvent('messageReceived', message.message, message.senderId, message.messageId);\n\t\t\t});\n\t\t}\n\t});\n}\n\nmodule.exports = messagesModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/messages.js\n// module id = 33\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/messages.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreUtils = __webpack_require__(0);\nvar globalObject = __webpack_require__(2);\n\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\n/**\n * Prompt the user for a ZIP compressed webstrate, like the one retrieved from a `?dl` request.\n * Accepts ZIP files with extensions ZIP and WSA (WebStrate Archieve).\n * @param  {string}   webstrateId (optional) Desired WebstrateId for the new webstrate.\n * @param  {object}   options     Some options, e.g. whether to reload the page or not.\n * @return {Promise}              Will accept on success or reject on failure.\n * @public\n */\nglobalObject.publicObject.newFromPrototypeFile = function (desiredWebstrateId) {\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\tdesiredWebstrateId = desiredWebstrateId || webstrateId;\n\n\treturn new Promise(function (accept, reject) {\n\t\tvar input = document.createElement('input');\n\t\tinput.setAttribute('name', 'file');\n\t\tinput.setAttribute('type', 'file');\n\t\tinput.setAttribute('accept', '.zip,.wsa');\n\n\t\tinput.addEventListener('change', function (event) {\n\t\t\tvar formData = new FormData();\n\t\t\tformData.append('file', input.files.item(0));\n\t\t\tformData.append('apiCall', true);\n\t\t\tformData.append('id', desiredWebstrateId);\n\n\t\t\tfetch('/new', {\n\t\t\t\tmethod: 'post',\n\t\t\t\tcredentials: 'include',\n\t\t\t\tbody: formData\n\t\t\t}).then(function (res) {\n\t\t\t\treturn res.json().then(function (json) {\n\t\t\t\t\tif (res.ok) {\n\t\t\t\t\t\taccept(json);\n\t\t\t\t\t\t// Reload the page if we're updating this webstrate, unless we're specifically\n\t\t\t\t\t\t// told not to.\n\t\t\t\t\t\tif (webstrateId === desiredWebstrateId && !options.noreload) {\n\t\t\t\t\t\t\tdocument.location.reload();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(json.error);\n\t\t\t\t\t}\n\t\t\t\t}).catch(function (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t});\n\t\t\t}).catch(function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\n\t\tinput.click();\n\t});\n};\n\n/**\n * Prototype a webstrate to a target webstrate, potentially this webstrate.\n * @param  {string}   webstrateId (optional) Desired WebstrateId for the new webstrate.\n * @param  {object}   options     Some options, e.g. whether to reload the page or not.\n * @return {Promise}              Will accept on success or reject on failure.\n * @public\n */\nglobalObject.publicObject.newFromPrototypeURL = function (url, desiredWebstrateId) {\n\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\tdesiredWebstrateId = desiredWebstrateId || webstrateId;\n\turl = new URL(url, location.href);\n\n\treturn new Promise(function (accept, reject) {\n\t\tfetch('/new?prototypeUrl=' + url + '&id=' + desiredWebstrateId, {\n\t\t\tmethod: 'get',\n\t\t\tcredentials: 'include'\n\t\t}).then(function (res) {\n\t\t\treturn res.text().then(function (text) {\n\t\t\t\tif (res.ok) {\n\t\t\t\t\taccept(text);\n\t\t\t\t\t// Reload the page if we're updating this webstrate, unless we're specifically\n\t\t\t\t\t// told not to.\n\t\t\t\t\tif (webstrateId === desiredWebstrateId && !options.noreload) {\n\t\t\t\t\t\tdocument.location.reload();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treject(text.error);\n\t\t\t\t}\n\t\t\t}).catch(function (err) {\n\t\t\t\treject(err);\n\t\t\t});\n\t\t}).catch(function (err) {\n\t\t\treject(err);\n\t\t});\n\t});\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/newWebstrates.js\n// module id = 34\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/newWebstrates.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\nvar userObject = __webpack_require__(11);\nvar loadedEvent = __webpack_require__(9);\n\nvar permissionsModule = {};\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\n// In static mode, the user does not receive the permissions. Since the webstrate doesn't change,\n// it also doesn't make sense to listen for permission changes, so we don't do that either.\nif (!coreUtils.getLocationObject().staticMode) {\n\t// Create internal events.\n\tcoreEvents.createEvent('globalPermissions');\n\tcoreEvents.createEvent('userPermissions');\n\n\t// Create events for userland.\n\tglobalObject.createEvent('permissionsChanged');\n\n\t// Delay the loaded event, until the 'globalPermissions' and 'userPermissions' events have been\n\t// triggered.\n\tloadedEvent.delayUntil('globalPermissions', 'userPermissions');\n\n\tvar websocket = coreWebsocket.copy(function (event) {\n\t\treturn event.data.startsWith('{\"wa\":');\n\t});\n\tvar doc = void 0,\n\t    username = void 0,\n\t    provider = void 0,\n\t    userPermissions = void 0,\n\t    defaultPermissionsList = void 0,\n\t    permissionsList = void 0;\n\n\tObject.defineProperty(userObject.publicObject, 'permissions', {\n\t\tget: function get() {\n\t\t\treturn userPermissions;\n\t\t},\n\t\tset: function set(v) {\n\t\t\tthrow new Error('Permissions must be changed through the data-auth attribute');\n\t\t},\n\t\tenumerable: true\n\t});\n\n\tObject.defineProperty(globalObject.publicObject, 'permissions', {\n\t\tget: function get() {\n\t\t\treturn permissionsList;\n\t\t},\n\t\tset: function set(v) {\n\t\t\tthrow new Error('Permissions must be changed through the data-auth attribute');\n\t\t},\n\t\tenumerable: true\n\t});\n\n\tpermissionsModule.getUserPermissions = function (username, provider) {\n\t\tvar activePermissionList = permissionsList;\n\t\t// If we found no permissions, resort to default permissions.\n\t\tif (!permissionsList || Object.keys(permissionsList).length === 0) {\n\t\t\t// If there's also no default permissions, we pretend every user has read-write permissions\n\t\t\t// lest we lock everybody out. We append a question mark to let the system know that these are\n\t\t\t// last-resort permissions.\n\t\t\tif (!defaultPermissionsList) {\n\t\t\t\treturn 'rw?';\n\t\t\t}\n\t\t\tactivePermissionList = defaultPermissionsList;\n\t\t}\n\n\t\tvar user = activePermissionList.find(function (user) {\n\t\t\treturn user.username === username && user.provider === provider;\n\t\t});\n\n\t\tif (user) {\n\t\t\treturn user.permissions;\n\t\t}\n\n\t\tvar anonymous = activePermissionList.find(function (user) {\n\t\t\treturn user.username === 'anonymous' && user.provider === '';\n\t\t});\n\n\t\treturn anonymous ? anonymous.permissions : '';\n\t};\n\n\tpermissionsModule.getPermissionsFromDocument = function (doc) {\n\t\tif (doc && doc.data && doc.data[0] && doc.data[0] === 'html' && doc.data[1] && doc.data[1]['data-auth']) {\n\t\t\ttry {\n\t\t\t\tvar permissions = JSON.parse(doc.data[1]['data-auth'].replace(/'/g, '\"').replace(/&quot;/g, '\"').replace(/&amp;/g, '&'));\n\n\t\t\t\tif (!Array.isArray(permissions)) {\n\t\t\t\t\tconsole.warn('Couldn\\'t parse document permissions - expected an array.');\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\treturn permissions;\n\t\t\t} catch (err) {\n\t\t\t\tconsole.warn('Couldn\\'t parse document permission - malformed.');\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t};\n\n\t/*\n * We need both doc, username, provider, permissionsList and defaultPermissionsList to be set before\n * we can emit permission events, so we create two promises, and wait until both have been resolved.\n */\n\tvar receivedDocumentPromise = new Promise(function (accept) {\n\t\tcoreEvents.addEventListener('receivedDocument', function (_doc) {\n\t\t\tdoc = _doc;\n\t\t\tpermissionsList = permissionsModule.getPermissionsFromDocument(doc);\n\t\t\tcoreEvents.triggerEvent('globalPermissions', permissionsList);\n\t\t\tuserPermissions = permissionsModule.getUserPermissions(username, provider);\n\t\t\tcoreEvents.triggerEvent('userPermissions', userPermissions);\n\t\t\taccept();\n\t\t});\n\t});\n\n\tvar helloMessageReceivedPromise = new Promise(function (accept) {\n\t\twebsocket.onjsonmessage = function (message) {\n\t\t\tif (message.wa === 'hello' && message.d === webstrateId) {\n\t\t\t\tusername = message.user.username;\n\t\t\t\tprovider = message.user.provider;\n\t\t\t\tdefaultPermissionsList = message.defaultPermissions;\n\t\t\t\taccept();\n\t\t\t}\n\t\t};\n\t});\n\n\t/**\n  * Identifies whether a set operations modify the permissions of a webstrate.\n  * @param  {[ops]} ops   List of operations.\n  * @return {bool}     True if ops modify permissions, false otherwise.\n  * @private\n  */\n\tvar permissionsChanged = function permissionsChanged(ops) {\n\t\treturn ops.some(function (op) {\n\t\t\treturn op.p[0] && op.p[0] === 1 && op.p[1] && op.p[1] === 'data-auth';\n\t\t});\n\t};\n\n\t/**\n  * Recalculates permissions and trigger permission events if permissions have changed.\n  * @param  {[ops]} ops List of operations.\n  * @private\n  */\n\tvar handleOps = function handleOps(ops) {\n\t\tif (!permissionsChanged(ops)) return;\n\n\t\tvar oldPermissionsList = permissionsList;\n\t\tpermissionsList = permissionsModule.getPermissionsFromDocument(doc);\n\t\tcoreEvents.triggerEvent('globalPermissions', permissionsList);\n\t\tglobalObject.triggerEvent('permissionsChanged', permissionsList, oldPermissionsList);\n\t\tvar newUserPermissions = permissionsModule.getUserPermissions(username, provider);\n\t\tif (!coreUtils.objectEquals(userPermissions, newUserPermissions)) {\n\t\t\tuserPermissions = newUserPermissions;\n\t\t\tcoreEvents.triggerEvent('userPermissions', userPermissions);\n\t\t}\n\t};\n\n\tPromise.all([receivedDocumentPromise, helloMessageReceivedPromise]).then(function () {\n\t\tcoreEvents.addEventListener('receivedOps', handleOps);\n\t\tcoreEvents.addEventListener('createdOps', handleOps);\n\t});\n}\nmodule.exports = permissionsModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/permissions.js\n// module id = 35\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/permissions.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n/**\n * Protected mode is enabled by adding data-protected as an attribute on the body tag and reloading\n * the page. Afterwards, all attributes set and elements inserted will automatically be transient.\n * To create an element that's approved to be in the DOM (i.e. not transient), the element should\n * be created with:\n *     document.createElement(tagName, { approved: true });\n *\n * Likewise, for setting a non-transient attribute:\n *     Element.setAttribute(name, value, { approved: true });\n *\n * Elements created by other modules will automatically be approved. Attributes set by other\n * modules will also automatically be approved, as long as they pass in the mandatory\n * coreDOM.elementOptions object as the last parameter to all setAttribute/setAttributeNS calls.\n */\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar coreDOM = __webpack_require__(6);\nvar globalObject = __webpack_require__(2);\n\nvar protectedModeModule = {};\n\ncoreEvents.addEventListener('receivedDocument', function (doc, options) {\n\tvar dataProtectedAttribute = doc.data && doc.data[1] && doc.data[1]['data-protected'];\n\tvar elementsProtected = ['all', 'elements', ''].includes(dataProtectedAttribute);\n\tvar attributesProtected = ['all', 'attributes', ''].includes(dataProtectedAttribute);\n\t// Changes to static documents aren't persisted, so no reason to enforce any protection.\n\tif (options.static) return;\n\n\t// Either elements, attributes, or both are protected in this webstrate.\n\tvar isProtected = elementsProtected || attributesProtected;\n\n\t// Define webstrate.isProtected. Returns true if elements, attributes, or the document is\n\t// protected and returns false otherwise.\n\tObject.defineProperty(globalObject.publicObject, 'isProtected', {\n\t\tget: function get() {\n\t\t\treturn isProtected;\n\t\t},\n\t\tset: function set() {\n\t\t\tthrow new Error('isProtected cannot be modified.');\n\t\t},\n\t\tenumerable: true\n\t});\n\n\t// We should only try to protect the document if the `data-protected` attribute has been set on\n\t// the <html> tag.\n\tif (!isProtected) return;\n\n\t// Warn the user that any changes made in the DOM editor in the Developer Tools will not persist.\n\tvar protectedParts = elementsProtected && attributesProtected ? 'the document' : elementsProtected ? 'elements' : 'attributes';\n\tconsole.warn('This document is protected. Any changes made to ' + protectedParts + ' through ' + 'the DOM editor in the Developer Tools will be perceived as transient.');\n\n\t/**\n  * Checks whether a DOMNode is allowed to be persisted (i.e. non-transient).\n  */\n\tvar isApprovedNode = function isApprovedNode(DOMNode) {\n\t\treturn !elementsProtected || !!DOMNode.__approved;\n\t};\n\n\t/**\n  * Checks whether an attribute is allowed to be peristed (i.e. non-transient).\n  */\n\tvar isApprovedAttribute = function isApprovedAttribute(DOMNode, attributeName) {\n\t\treturn !attributesProtected || DOMNode.__approvedAttributes && DOMNode.__approvedAttributes.has(attributeName);\n\t};\n\n\t// Overwrite config.isTransientElement, so nodes with the `__approved` property are transient. We\n\t// also pass on the call to the original isTransientElement function defined in the client config.\n\tvar _isTransientElement = config.isTransientElement;\n\tconfig.isTransientElement = function (DOMNode) {\n\t\treturn _isTransientElement(DOMNode)\n\t\t// The [contenteditable] part below is a hack. There's no way to allow only certain sources\n\t\t// to write in a contenteditable field, so we have to allow everything to make it possible to\n\t\t// use contenteditable fields at all in protected mode.\n\t\t|| !(isApprovedNode(DOMNode) || DOMNode.closest('[contenteditable]'));\n\t};\n\n\t// Overwrite config.isTransientAttribute to make approved attribute in APPROVAL_TYPE.ATTRIBUTE\n\t// transient, otherwise that attribute gets synchronized to the server\n\tvar _isTransientAttribute = config.isTransientAttribute;\n\tconfig.isTransientAttribute = function (DOMNode, attributeName) {\n\t\treturn !(isApprovedAttribute(DOMNode, attributeName) && !_isTransientAttribute(DOMNode, attributeName));\n\t};\n\n\t/**\n  * Approves a node to make it perist on the server. Also, overriding innerHTML of the node to\n  * approve all descendents when set through innerHTML.\n  * \n  * @param {Node} node An object eventually having a property approved set to true.\n  */\n\tvar approveNode = function approveNode(node) {\n\n\t\t// No need to reapprove node, and no need to override innerHTML again.\n\t\tif (node.__approved) return;\n\n\t\t// Use defineProperty and enumerable false to disallow overriding it and\n\t\t// hide it during enumeration.\n\t\tObject.defineProperty(node, '__approved', {\n\t\t\tget: function get() {\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tenumerable: false\n\t\t});\n\n\t\t// overriding the innerHTML property of the node to approve its children when\n\t\t// innerHTML is used\n\t\tif (node.nodeType === Node.ELEMENT_NODE) {\n\t\t\tvar innerHTMLDescriptor = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');\n\n\t\t\tObject.defineProperty(node, 'innerHTML', {\n\t\t\t\tset: function set(value) {\n\t\t\t\t\tvar returnValue = innerHTMLDescriptor.set.call(node, value);\n\n\t\t\t\t\t// Approve all children and their attributes.\n\t\t\t\t\t// Combine approveNode and approveElementAttribute to avoid performing the\n\t\t\t\t\t// recursiveForEach twice.\n\t\t\t\t\tcoreUtils.recursiveForEach(node, function (childNode) {\n\t\t\t\t\t\tapproveNode(childNode);\n\n\t\t\t\t\t\t// Only an Element has attributes.\n\t\t\t\t\t\tif (childNode.nodeType === Node.ELEMENT_NODE) {\n\t\t\t\t\t\t\tArray.from(childNode.attributes).forEach(function (attr) {\n\t\t\t\t\t\t\t\tapproveElementAttribute(childNode, attr.name);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn returnValue;\n\t\t\t\t},\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn innerHTMLDescriptor.get.call(node);\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Approve an element's attribute to make it persist on the server.\n  * \n  * @param {Element} element An element.\n  * @param {string} attrName Attribute name that will be approved.\n  */\n\tvar approveElementAttribute = function approveElementAttribute(element, attrName) {\n\t\tif (!element.__approvedAttributes) {\n\t\t\tvar approvedAttributes = new Set();\n\n\t\t\t// Use defineProperty and enumerable false to disallow overriding it and\n\t\t\t// hide it during enumeration.\n\t\t\tObject.defineProperty(element, '__approvedAttributes', {\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn approvedAttributes;\n\t\t\t\t},\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t}\n\n\t\tif (!element.__approvedAttributes.has(attrName)) {\n\t\t\telement.__approvedAttributes.add(attrName);\n\t\t}\n\t};\n\n\t/**\n  * Removes an attribute from the list of approved attributes making it transient.\n  * \n  * @param {Element} element An element. \n  * @param {String} attrName Attribute name that will be removed from list of approved attribute\n  * names.\n  */\n\tvar removeApproveElementAttribute = function removeApproveElementAttribute(element, attrName) {\n\t\tif (!element.__approvedAttributes) {\n\t\t\treturn;\n\t\t}\n\n\t\telement.__approvedAttributes.delete(attrName);\n\t};\n\n\t// Override some internal functions, so elements created by other modules will be pre-approved.\n\tcoreDOM.overrideDocument('createElementNS', coreDOM.CONTEXT.INTERNAL, function (createElementNS, namespaceURI, qualifiedName) {\n\t\tfor (var _len = arguments.length, unused = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n\t\t\tunused[_key - 4] = arguments[_key];\n\t\t}\n\n\t\tvar options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\t\toptions.approved = true;\n\t\treturn createElementNS.apply(undefined, [namespaceURI, qualifiedName, options].concat(unused));\n\t});\n\n\tcoreDOM.overrideDocument('createElement', coreDOM.CONTEXT.INTERNAL, function (createElement, tagName) {\n\t\tfor (var _len2 = arguments.length, unused = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t\t\tunused[_key2 - 3] = arguments[_key2];\n\t\t}\n\n\t\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t\toptions.approved = true;\n\t\treturn createElement.apply(undefined, [tagName, options].concat(unused));\n\t});\n\n\tcoreDOM.overrideDocument('importNode', coreDOM.CONTEXT.INTERNAL, function (importNode, externalNode, deep) {\n\t\tfor (var _len3 = arguments.length, unused = Array(_len3 > 4 ? _len3 - 4 : 0), _key3 = 4; _key3 < _len3; _key3++) {\n\t\t\tunused[_key3 - 4] = arguments[_key3];\n\t\t}\n\n\t\tvar options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\t\toptions.approved = true;\n\t\treturn importNode.apply(undefined, [externalNode, deep, options].concat(unused));\n\t});\n\n\tcoreDOM.overrideDocument('createElementNS', coreDOM.CONTEXT.BOTH, function (createElementNS, namespaceURI, qualifiedName) {\n\t\tfor (var _len4 = arguments.length, unused = Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {\n\t\t\tunused[_key4 - 4] = arguments[_key4];\n\t\t}\n\n\t\tvar options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\t\tvar element = createElementNS.apply(undefined, [namespaceURI, qualifiedName, options].concat(unused));\n\t\tif (options && options.approved) approveNode(element);else element.setAttribute('unapproved', '');\n\t\treturn element;\n\t});\n\n\tcoreDOM.overrideDocument('createElement', coreDOM.CONTEXT.BOTH, function (createElement, tagName) {\n\t\tfor (var _len5 = arguments.length, unused = Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n\t\t\tunused[_key5 - 3] = arguments[_key5];\n\t\t}\n\n\t\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t\tvar element = createElement.apply(undefined, [tagName, options].concat(unused));\n\t\tif (options && options.approved) approveNode(element);else element.setAttribute('unapproved', '');\n\t\treturn element;\n\t});\n\n\tcoreDOM.overrideDocument('importNode', coreDOM.CONTEXT.BOTH, function (importNode, externalNode, deep) {\n\t\tfor (var _len6 = arguments.length, unused = Array(_len6 > 4 ? _len6 - 4 : 0), _key6 = 4; _key6 < _len6; _key6++) {\n\t\t\tunused[_key6 - 4] = arguments[_key6];\n\t\t}\n\n\t\tvar options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n\t\tvar element = importNode.apply(undefined, [externalNode, deep].concat(unused));\n\t\tcoreUtils.recursiveForEach(element, function (childNode) {\n\t\t\tif (options && options.approved) {\n\t\t\t\tapproveNode(childNode);\n\t\t\t\tif (childNode.nodeType === Node.ELEMENT_NODE) {\n\t\t\t\t\tArray.from(childNode.attributes).forEach(function (attr) {\n\t\t\t\t\t\tapproveElementAttribute(childNode, attr.name);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else childNode.nodeType === document.ELEMENT_NODE && childNode.setAttribute('unapproved', '');\n\t\t});\n\t\treturn element;\n\t});\n\n\t// The elementOptions object should get passed into all prototype function calls (e.g.\n\t// Element.setAttribute) made by other modules. This allows us to inject a setting on the\n\t// object, so we can make all calls from other modules pre-approved.\n\tcoreDOM.elementOptions.approved = true;\n\n\tvar cloneNode = Node.prototype.cloneNode;\n\tNode.prototype.cloneNode = function (deep, options) {\n\t\tfor (var _len7 = arguments.length, unused = Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n\t\t\tunused[_key7 - 2] = arguments[_key7];\n\t\t}\n\n\t\tvar node = cloneNode.call.apply(cloneNode, [this, deep].concat(unused));\n\t\tdelete node.approved;\n\t\tif (options && options.approved) approveNode(node);\n\t\treturn node;\n\t};\n\n\tvar setAttributeNS = Element.prototype.setAttributeNS;\n\tElement.prototype.setAttributeNS = function (namespace, name, value, options) {\n\t\tif (options && options.approved) approveElementAttribute(this, name);\n\n\t\tfor (var _len8 = arguments.length, unused = Array(_len8 > 4 ? _len8 - 4 : 0), _key8 = 4; _key8 < _len8; _key8++) {\n\t\t\tunused[_key8 - 4] = arguments[_key8];\n\t\t}\n\n\t\tsetAttributeNS.call.apply(setAttributeNS, [this, namespace, name, value, options].concat(unused));\n\t};\n\n\tvar setAttribute = Element.prototype.setAttribute;\n\tElement.prototype.setAttribute = function (name, value, options) {\n\t\t// Approve any attribute set on an approved element by checking 'this.__approved'.\n\t\t// Although, third-party libraries can still get their attributes approved by this loose\n\t\t// check, it will still protect browser extensions from spamming DOM elements with attributes.\n\t\tif (this.__approved || options && options.approved) approveElementAttribute(this, name);\n\n\t\tfor (var _len9 = arguments.length, unused = Array(_len9 > 3 ? _len9 - 3 : 0), _key9 = 3; _key9 < _len9; _key9++) {\n\t\t\tunused[_key9 - 3] = arguments[_key9];\n\t\t}\n\n\t\tsetAttribute.call.apply(setAttribute, [this, name, value, options].concat(unused));\n\t};\n\n\tvar removeAttribute = Element.prototype.removeAttribute;\n\tElement.prototype.removeAttribute = function (name, options) {\n\t\tfor (var _len10 = arguments.length, unused = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n\t\t\tunused[_key10 - 2] = arguments[_key10];\n\t\t}\n\n\t\tremoveAttribute.call.apply(removeAttribute, [this, name, options].concat(unused));\n\t\tif (options && options.approved) removeApproveElementAttribute(this, name);\n\t};\n\n\t// Proxy all configurable properties with a set function to intercept calls to properties\n\t// and approve their corresponding element attributes.\n\tvar proxyDescriptors = function proxyDescriptors(prototype, properties) {\n\t\tproperties.forEach(function (propertyName) {\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(prototype, propertyName);\n\t\t\t// Check if descriptor is configurable and has a set function already\n\t\t\tif (descriptor.configurable && typeof descriptor.set === 'function') {\n\t\t\t\tObject.defineProperty(prototype, propertyName, {\n\t\t\t\t\tconfigurable: descriptor.configurable,\n\t\t\t\t\tenumerable: descriptor.enumerable,\n\t\t\t\t\tset: function set(value) {\n\t\t\t\t\t\t// The approved attributes need to be lower-case in order to be approved\n\t\t\t\t\t\t// properly in the isTransientAttribute check.\n\t\t\t\t\t\tif (this.__approved) approveElementAttribute(this, propertyName.toLowerCase());\n\t\t\t\t\t\treturn descriptor.set.call(this, value);\n\t\t\t\t\t},\n\t\t\t\t\tget: descriptor.get\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\t// Proxy Element.prototype and HTMLElement.prototype to approve attribute, e.g.,\n\t// Element.prototype.id -> 'id' or HTMLElement.prototype.contentEditable -> 'contenteditable'.\n\tproxyDescriptors(Element.prototype, ['id']);\n\tproxyDescriptors(HTMLElement.prototype, ['accessKey', 'contentEditable', 'dir', 'draggable', 'hidden', 'lang', 'tabIndex', 'title', 'translate']);\n\n\t// Convert Strings from camelCase to kebab-case.\n\tvar camelToKebab = function camelToKebab(input) {\n\t\treturn input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t};\n\n\t/**\n  * Applies function hook when the target object returns a function for the property name, and\n  * a hook was defined for the property name. It will return the target's default value if no\n  * hook was defined or the returned value is not a function.\n  * \n  * @param {*} element The element associated with the property calls.\n  * @param {*} target The proxied object.\n  * @param {*} propName The property name.\n  */\n\tvar applyHookWhenPropertyIsFunction = function applyHookWhenPropertyIsFunction(element, target, propName) {\n\t\t// Apply hook only if returned value is a function\n\t\tvar returnValue = target[propName];\n\t\tif (typeof returnValue === 'function') {\n\t\t\tvar hook = this.functions[propName];\n\t\t\tif (hook) {\n\t\t\t\tvar hookReturnValue = hook.call(element, returnValue, target, propName);\n\t\t\t\tif (hookReturnValue) {\n\t\t\t\t\treturnValue = hookReturnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Bind to target, otherwise it'll throw an \"TypeError: Illegal invocation\"\n\t\t\treturn returnValue.bind(target);\n\t\t}\n\n\t\t// Return original value when no hook was applied.\n\t\treturn returnValue;\n\t};\n\n\t// Proxy definitions for 'classList', 'dataset', and 'style'.\n\tvar propertiesElement = [{\n\t\tpropertyName: 'classList',\n\t\tprototype: Element.prototype,\n\t\tget: function get(element, target, propName) {\n\t\t\treturn applyHookWhenPropertyIsFunction.call(this, element, target, propName);\n\t\t},\n\t\tfunctions: {\n\t\t\tadd: function add(nativeAddFunc, tokenList, propName) {\n\t\t\t\tvar _this = this;\n\n\t\t\t\treturn function () {\n\t\t\t\t\tfor (var _len11 = arguments.length, tokens = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n\t\t\t\t\t\ttokens[_key11] = arguments[_key11];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_this.__approved) approveElementAttribute(_this, 'class');\n\t\t\t\t\treturn nativeAddFunc.call.apply(nativeAddFunc, [tokenList].concat(tokens));\n\t\t\t\t};\n\t\t\t},\n\t\t\ttoggle: function toggle(nativeToggleFunc, tokenList, propName) {\n\t\t\t\tvar _this2 = this;\n\n\t\t\t\treturn function (token, force) {\n\t\t\t\t\tfor (var _len12 = arguments.length, unused = Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) {\n\t\t\t\t\t\tunused[_key12 - 2] = arguments[_key12];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_this2.__approved) approveElementAttribute(_this2, 'class');\n\t\t\t\t\treturn nativeToggleFunc.call.apply(nativeToggleFunc, [tokenList, token, force].concat(unused));\n\t\t\t\t};\n\t\t\t},\n\t\t\treplace: function replace(nativeReplaceFunc, tokenList, propName) {\n\t\t\t\tvar _this3 = this;\n\n\t\t\t\treturn function (oldToken, newToken) {\n\t\t\t\t\tfor (var _len13 = arguments.length, unused = Array(_len13 > 2 ? _len13 - 2 : 0), _key13 = 2; _key13 < _len13; _key13++) {\n\t\t\t\t\t\tunused[_key13 - 2] = arguments[_key13];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_this3.__approved) approveElementAttribute(_this3, 'class');\n\t\t\t\t\treturn nativeReplaceFunc.call.apply(nativeReplaceFunc, [tokenList, oldToken, newToken].concat(unused));\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}, {\n\t\tpropertyName: 'dataset',\n\t\tprototype: HTMLElement.prototype,\n\t\tset: function set(element, target, propName, value) {\n\t\t\ttarget[propName] = value;\n\t\t\tvar attributeName = camelToKebab(propName);\n\t\t\tif (element.__approved) approveElementAttribute(element, 'data-' + attributeName);\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tpropertyName: 'style',\n\t\tprototype: HTMLElement.prototype,\n\t\tget: function get(element, target, propName) {\n\t\t\treturn applyHookWhenPropertyIsFunction.call(this, element, target, propName);\n\t\t},\n\t\tset: function set(element, target, propName, value) {\n\t\t\ttarget[propName] = value;\n\t\t\tif (element.__approved) approveElementAttribute(element, 'style');\n\t\t\treturn true;\n\t\t},\n\t\tfunctions: {\n\t\t\tsetProperty: function setProperty(nativeSetPropertyFunc, cssStyleDeclaration, propName) {\n\t\t\t\tvar _this4 = this;\n\n\t\t\t\treturn function (propertyName, value, priority) {\n\t\t\t\t\tfor (var _len14 = arguments.length, unused = Array(_len14 > 3 ? _len14 - 3 : 0), _key14 = 3; _key14 < _len14; _key14++) {\n\t\t\t\t\t\tunused[_key14 - 3] = arguments[_key14];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_this4.__approved) approveElementAttribute(_this4, 'style');\n\t\t\t\t\treturn nativeSetPropertyFunc.call.apply(nativeSetPropertyFunc, [cssStyleDeclaration, propertyName, value, priority].concat(unused));\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}];\n\n\t// Proxy each property defined in the properties array. A property definition looks like:\n\t//\n\t// {\n\t// \t\t// The name of the property that will get a new descriptor.\n\t// \t\tpropertyName: 'classList',\n\t// \t\t// The object object or prototype that will get a new descriptor.\n\t// \t\tprototype: HTMLElement.prototype,\n\t// \t\t// This is the same as Proxy.prototype.get but with element as first parameter and 'this'\n\t// \t\t// refers the definition itself.\n\t// \t\tget: function(element, target, propName) {\n\t// \t\t\treturn target[propName];\n\t// \t\t},\n\t// \t\tThis is the same as Proxy.prototype.set but with element as first parameter and 'this'\n\t// \t\t// refers the definition itself.\n\t// \t\tset: function(element, target, propName, value) {\n\t// \t\t\ttarget[propName] = value;\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// }\n\tvar proxyDescriptorsAndvanced = function proxyDescriptorsAndvanced(propertyDefinitions) {\n\n\t\tpropertyDefinitions.forEach(function (definition) {\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(definition.prototype, definition.propertyName);\n\t\t\tObject.defineProperty(definition.prototype, definition.propertyName, {\n\t\t\t\tconfigurable: descriptor.configurable,\n\t\t\t\tenumerable: descriptor.enumerable,\n\t\t\t\tset: function set(value) {\n\t\t\t\t\treturn descriptor.set.call(this, value);\n\t\t\t\t},\n\t\t\t\tget: function get() {\n\t\t\t\t\tvar element = this;\n\t\t\t\t\tvar result = descriptor.get.call(element);\n\n\t\t\t\t\t// Proxy property with either get, set, or both. This means that each call\n\t\t\t\t\t// to a child property will be forwarded to the get or set respectively. In\n\t\t\t\t\t// case not get or set is defined, the default get/set behavior applies.\n\t\t\t\t\tif (definition.get || definition.set) {\n\t\t\t\t\t\treturn new Proxy(result, {\n\t\t\t\t\t\t\tget: function get(target, propName) {\n\t\t\t\t\t\t\t\tif (definition.get) {\n\t\t\t\t\t\t\t\t\treturn definition.get.call(definition, element, target, propName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn target[propName];\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tset: function set(target, propName, value) {\n\t\t\t\t\t\t\t\tif (definition.set) {\n\t\t\t\t\t\t\t\t\treturn definition.set.call(definition, element, target, propName, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget[propName] = value;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t// Proxy properties like 'classList', 'dataset', and 'style'.\n\tproxyDescriptorsAndvanced(propertiesElement);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\nmodule.exports = protectedModeModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/protectedMode.js\n// module id = 36\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/protectedMode.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate, config) {\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreUtils = __webpack_require__(0);\nvar coreEvents = __webpack_require__(1);\nvar globalObject = __webpack_require__(2);\nvar nodeObjects = __webpack_require__(10);\nvar signaling = __webpack_require__(20);\n\nvar signalStreamModule = {};\n\nvar clientId = void 0;\ncoreEvents.addEventListener('populated', function (rootElement, _webstrateId) {\n\tclientId = globalObject.publicObject.clientId;\n});\n\n// Intercept streaming signals, so they're not processed as regular signals by the signaling module.\nsignaling.addInterceptor(function (payload) {\n\tvar message = payload.m;\n\tvar senderClientId = payload.s;\n\t// Only handle internal webrtc messages and also ignore our own messages.\n\tif (typeof message.__internal_webrtc === 'undefined' || senderClientId === clientId) {\n\t\treturn false;\n\t}\n\n\t// No reason to do this all now, so we use setImmdiate.\n\tsetImmediate(handleSignal, payload.id, senderClientId, message);\n\treturn true;\n});\n\nfunction handleSignal(wid, senderClientId, message) {\n\tvar node = coreUtils.getElementByWid(wid);\n\n\tif (message.requestForStreams) {\n\t\tArray.from(wantToStreamCallbacks.get(wid).keys()).forEach(function (ownId) {\n\t\t\tnode.webstrate.signal({\n\t\t\t\t__internal_webrtc: true,\n\t\t\t\twantToStream: true,\n\t\t\t\tsenderId: ownId,\n\t\t\t\trecipientId: message.senderId\n\t\t\t}, senderClientId);\n\t\t});\n\t\treturn;\n\t}\n\n\t// If we get a message from somebody wanting to stream, we ask all the people listening for\n\t// streams. If they accept, we create the webrtcClient.\n\tif (message.wantToStream) {\n\t\tArray.from(wantToListenCallbacks.get(wid).values()).forEach(function (callback) {\n\t\t\tvar ownId = coreUtils.randomString();\n\t\t\t// Other clients may be responding to the same recipientId/stream. Therefore, the streamer\n\t\t\t// can't create a WebRTCClient with the original recipientId as these would override each\n\t\t\t// other in the webrtcClients map (the streamer would be creating two entries with the same\n\t\t\t// recipientId). Instead, the streamer needs to generate a new recipientId for each listener\n\t\t\t// to use, so the streamer can distinguish the clients from each other. However, it's\n\t\t\t// difficult to communicate this back to the listeners. Therefore, the listener instead\n\t\t\t// creates a new recipientId, telling the streamer \"In the future, I'll address you with this\n\t\t\t// id instead\".\n\t\t\tvar newRecipientId = coreUtils.randomString();\n\t\t\tvar webrtcClient = new WebRTCClient(ownId, newRecipientId, senderClientId, node, { listener: true });\n\t\t\twebrtcClients.get(wid).set(ownId, webrtcClient);\n\n\t\t\t// If the client hasn't connected after 30 seconds, we conclude that it won't happen and clean\n\t\t\t// up the client we created.\n\t\t\tsetTimeout(function () {\n\t\t\t\tif (!webrtcClient.stub.isConnected()) {\n\t\t\t\t\twebrtcClients.get(wid).delete(ownId);\n\t\t\t\t}\n\t\t\t}, 30 * 1000);\n\n\t\t\tcallback(senderClientId, 'META_DATA_IS_DEPRECATED', function (clientAcceptCallback) {\n\n\t\t\t\twebrtcClient.onRemoteStream(clientAcceptCallback);\n\t\t\t\tnode.webstrate.signal({\n\t\t\t\t\t__internal_webrtc: true,\n\t\t\t\t\twantToListen: true,\n\t\t\t\t\trecipientId: message.senderId,\n\t\t\t\t\tnewRecipientId: newRecipientId,\n\t\t\t\t\tsenderId: ownId\n\t\t\t\t}, senderClientId);\n\t\t\t\treturn webrtcClient.stub;\n\t\t\t});\n\t\t});\n\t\treturn;\n\t}\n\n\tif (message.wantToListen) {\n\t\tvar callback = wantToStreamCallbacks.get(wid).get(message.recipientId);\n\n\t\tif (callback) {\n\t\t\tcallback(senderClientId, function (localStream, meta, onConnectCallback) {\n\t\t\t\tvar webrtcClient = new WebRTCClient(message.newRecipientId, message.senderId, senderClientId, node, { streamer: true });\n\t\t\t\twebrtcClient.onConnect(onConnectCallback);\n\t\t\t\twebrtcClients.get(wid).set(message.newRecipientId, webrtcClient);\n\t\t\t\twebrtcClient.start(localStream);\n\t\t\t\treturn webrtcClient.stub;\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tif (message.sdp || message.ice) {\n\t\tvar webrtcClient = webrtcClients.get(wid).get(message.recipientId);\n\t\tif (webrtcClient) {\n\t\t\twebrtcClient.handleMessage(message);\n\t\t} else {\n\t\t\tconsole.error('Got message for unknown recipient', message, webrtcClients);\n\t\t}\n\t\treturn;\n\t}\n}\n\nvar wantToStreamCallbacks = new Map();\nvar wantToListenCallbacks = new Map();\nvar webrtcClients = new Map();\n\nfunction WebRTCClient(ownId, recipientId, clientRecipientId, node, _ref) {\n\tvar listener = _ref.listener,\n\t    streamer = _ref.streamer;\n\n\tvar active = false,\n\t    peerConnection = void 0,\n\t    onRemoteStreamCallback = void 0,\n\t    onConnectCallback = void 0,\n\t    onCloseCallback = void 0;\n\n\tvar start = function start(localStream) {\n\t\tactive = true;\n\t\tpeerConnection = new RTCPeerConnection(config.peerConnectionConfig);\n\t\tpeerConnection.onicecandidate = gotIceCandidate;\n\t\tpeerConnection.oniceconnectionstatechange = gotStateChange;\n\t\tif (streamer) {\n\t\t\tpeerConnection.addStream(localStream);\n\t\t\tpeerConnection.createOffer().then(createdDescription).catch(errorHandler);\n\t\t}\n\t\tif (listener) {\n\t\t\tpeerConnection.onaddstream = gotRemoteStream;\n\t\t}\n\t};\n\n\tvar createdDescription = function createdDescription(description) {\n\t\tpeerConnection.setLocalDescription(description).then(function () {\n\t\t\tnode.webstrate.signal({\n\t\t\t\tsdp: peerConnection.localDescription,\n\t\t\t\t__internal_webrtc: true,\n\t\t\t\tsenderId: ownId,\n\t\t\t\trecipientId: recipientId\n\t\t\t}, clientRecipientId);\n\t\t}).catch(errorHandler);\n\t};\n\n\tvar handleMessage = function handleMessage(message) {\n\t\tif (!peerConnection) start();\n\n\t\tif (message.sdp) {\n\t\t\tpeerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp)).then(function () {\n\t\t\t\t// Only create answers in response to offers\n\t\t\t\tif (message.sdp.type == 'offer') {\n\t\t\t\t\tpeerConnection.createAnswer().then(createdDescription).catch(errorHandler);\n\t\t\t\t}\n\t\t\t}).catch(errorHandler);\n\t\t} else if (message.ice) {\n\t\t\tpeerConnection.addIceCandidate(new RTCIceCandidate(message.ice)).catch(errorHandler);\n\t\t}\n\t};\n\n\tvar gotIceCandidate = function gotIceCandidate(event) {\n\t\tif (event.candidate != null) {\n\t\t\tnode.webstrate.signal({\n\t\t\t\tice: event.candidate,\n\t\t\t\t__internal_webrtc: true,\n\t\t\t\tsenderId: ownId,\n\t\t\t\trecipientId: recipientId\n\t\t\t}, clientRecipientId);\n\t\t}\n\t};\n\n\tvar gotStateChange = function gotStateChange(event) {\n\t\tswitch (peerConnection.iceConnectionState) {\n\t\t\tcase 'connected':\n\t\t\t\tonConnectCallback && onConnectCallback(event);\n\t\t\t\tbreak;\n\t\t\tcase 'closed':\n\t\t\tcase 'disconnected':\n\t\t\tcase 'failed':\n\t\t\t\tonCloseCallback && onCloseCallback(event);\n\t\t\t\twebrtcClients.delete(ownId);\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tvar gotRemoteStream = function gotRemoteStream(event) {\n\t\tonRemoteStreamCallback(event.stream);\n\t};\n\n\tvar errorHandler = function errorHandler() {\n\t\tvar _console;\n\n\t\t(_console = console).error.apply(_console, arguments);\n\t};\n\n\treturn {\n\t\tid: ownId, active: active, listener: listener, streamer: streamer, peerConnection: peerConnection,\n\t\tonRemoteStream: function onRemoteStream(callback) {\n\t\t\treturn onRemoteStreamCallback = callback;\n\t\t},\n\t\tonConnect: function onConnect(callback) {\n\t\t\treturn onConnectCallback = callback;\n\t\t},\n\t\tstub: {\n\t\t\tisConnected: function isConnected() {\n\t\t\t\treturn !!peerConnection && ['checking', 'connected', 'completed'].includes(peerConnection.iceConnectionState);\n\t\t\t},\n\t\t\tclose: function close() {\n\t\t\t\treturn peerConnection.close();\n\t\t\t},\n\t\t\tonclose: function onclose(callback) {\n\t\t\t\treturn onCloseCallback = callback;\n\t\t\t}\n\t\t},\n\t\tstart: start, handleMessage: handleMessage\n\t};\n}\n\nfunction setupSignalStream(publicObject, eventObject) {\n\tvar wid = publicObject.id;\n\n\t// Text nodes and transient elements won't have wids, meaning there's way for us to signal on\n\t// them, and thus it'd be pointless to add a signaling method and event.\n\tif (!wid) return;\n\n\twebrtcClients.set(wid, new Map());\n\twantToStreamCallbacks.set(wid, new Map());\n\twantToListenCallbacks.set(wid, new Map());\n\n\t// A mapping from user callbacks to our internal callbacks: fn -> fn.\n\t//const callbacks = new Map();\n\n\tvar node = coreUtils.getElementByWid(wid);\n\n\tObject.defineProperty(publicObject, 'signalStream', {\n\t\tvalue: function value(callback) {\n\t\t\tsignaling.subscribe(wid);\n\t\t\tvar ownId = coreUtils.randomString();\n\t\t\twantToStreamCallbacks.get(wid).set(ownId, callback);\n\t\t\tnode.webstrate.signal({\n\t\t\t\t__internal_webrtc: true,\n\t\t\t\twantToStream: true,\n\t\t\t\tsenderId: ownId\n\t\t\t});\n\t\t},\n\t\twritable: false\n\t});\n\n\tObject.defineProperty(publicObject, 'stopStreamSignal', {\n\t\tvalue: function value(callback) {\n\t\t\t// Find the ownId that was generated when adding this callback.\n\t\t\tvar streamers = Array.from(wantToStreamCallbacks.get(wid).entries());\n\n\t\t\tvar _streamers$find = streamers.find(function (_ref2) {\n\t\t\t\tvar _ref3 = _slicedToArray(_ref2, 2),\n\t\t\t\t    ownId = _ref3[0],\n\t\t\t\t    callback = _ref3[1];\n\n\t\t\t\treturn callback === callback;\n\t\t\t}),\n\t\t\t    _streamers$find2 = _slicedToArray(_streamers$find, 1),\n\t\t\t    ownId = _streamers$find2[0];\n\n\t\t\tif (ownId) {\n\t\t\t\twantToStreamCallbacks.get(wid).delete(ownId);\n\t\t\t}\n\n\t\t\t// \"But what if somebody else is still listening? Then we shouldn't unsubscribe\". Worry not,\n\t\t\t// the signaling module keeps track of how many people are actually listening and doesn't\n\t\t\t// unsubcribe unless we're the last/only listener.\n\t\t\tsignaling.unsubscribe(wid);\n\t\t},\n\t\twritable: false\n\t});\n\n\teventObject.createEvent('signalStream', {\n\t\taddListener: function addListener(callback) {\n\t\t\tif (wantToListenCallbacks.get(wid).size === 0) {\n\t\t\t\tsignaling.subscribe(wid);\n\t\t\t}\n\t\t\tvar ownId = coreUtils.randomString();\n\t\t\twantToListenCallbacks.get(wid).set(ownId, callback);\n\t\t\tnode.webstrate.signal({\n\t\t\t\t__internal_webrtc: true,\n\t\t\t\trequestForStreams: true,\n\t\t\t\tsenderId: ownId\n\t\t\t});\n\t\t},\n\t\tremoveListener: function removeListener(callback) {\n\t\t\t// Find the ownId that was generated when adding this callback.\n\t\t\tvar listeners = Array.from(wantToListenCallbacks.get(wid).entries());\n\n\t\t\tvar _listeners$find = listeners.find(function (_ref4) {\n\t\t\t\tvar _ref5 = _slicedToArray(_ref4, 2),\n\t\t\t\t    ownId = _ref5[0],\n\t\t\t\t    callback = _ref5[1];\n\n\t\t\t\treturn callback === callback;\n\t\t\t}),\n\t\t\t    _listeners$find2 = _slicedToArray(_listeners$find, 1),\n\t\t\t    ownId = _listeners$find2[0];\n\n\t\t\tif (ownId) {\n\t\t\t\twantToListenCallbacks.get(wid).delete(ownId);\n\t\t\t}\n\n\t\t\tsignaling.unsubscribe(wid);\n\t\t}\n\t});\n}\n\nsetupSignalStream(globalObject.publicObject, globalObject);\n\n// Add signalStream events to all webstrate objects (with a wid) after the document has been\n// populated.\ncoreEvents.addEventListener('webstrateObjectsAdded', function (nodes) {\n\tcoreUtils.recursiveForEach(nodes, function (node) {\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\tsetupSignalStream(node.webstrate, eventObject);\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// Add signalStream events to all webstrate objects (with wid) after they're added continually.\ncoreEvents.addEventListener('webstrateObjectAdded', function (node, eventObject) {\n\tsetupSignalStream(node.webstrate, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\nmodule.exports = signalStreamModule;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/signalStream.js\n// module id = 37\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/signalStream.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreUtils = __webpack_require__(0);\nvar coreEvents = __webpack_require__(1);\nvar coreWebsocket = __webpack_require__(3);\nvar globalObject = __webpack_require__(2);\n\nvar taggingModule = {};\n\ncoreEvents.createEvent('receivedTags');\nglobalObject.createEvent('tag');\nglobalObject.createEvent('untag');\n\nvar doc,\n    currentTag,\n    allTags = {},\n    futureTags = {};\n\nvar websocket = coreWebsocket.copy(function (event) {\n\treturn event.data.startsWith('{\"wa\":');\n});\nvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\nwebsocket.onjsonmessage = function (message) {\n\t// Ignore message intended for other webstrates sharing the same websocket.\n\tif (message.d !== webstrateId) return;\n\n\tswitch (message.wa) {\n\n\t\tcase 'tags':\n\t\t\t{\n\t\t\t\tmessage.tags.forEach(function (tag) {\n\t\t\t\t\tallTags[tag.v] = tag.label;\n\t\t\t\t});\n\t\t\t\tcoreEvents.triggerEvent('receivedTags', allTags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase 'tag':\n\t\t\t{\n\t\t\t\tvar label = message.l;\n\t\t\t\tvar version = message.v;\n\n\t\t\t\t// The label may already be in use, but since labels are unique, we should remove it.\n\t\t\t\tvar existingVersion = Object.keys(allTags).find(function (candidateVersion) {\n\t\t\t\t\treturn allTags[candidateVersion] === label;\n\t\t\t\t});\n\n\t\t\t\tif (existingVersion) {\n\t\t\t\t\tdelete allTags[existingVersion];\n\t\t\t\t}\n\n\t\t\t\tallTags[version] = label;\n\t\t\t\tif (doc.version === version) {\n\t\t\t\t\tcurrentTag = label;\n\t\t\t\t} else if (version > doc.version) {\n\t\t\t\t\tfutureTags[version] = label;\n\t\t\t\t}\n\n\t\t\t\tglobalObject.triggerEvent('tag', version, label);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase 'untag':\n\t\t\t{\n\t\t\t\tvar _label = message.l;\n\t\t\t\tvar _version = message.v;\n\n\t\t\t\tif (!_version && _label) {\n\t\t\t\t\t_version = Object.keys(allTags).find(function (candidateVersion) {\n\t\t\t\t\t\treturn allTags[candidateVersion] === _label;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tdelete allTags[_version];\n\n\t\t\t\tglobalObject.triggerEvent('untag', _version);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t}\n};\n\n// When an op comes in, the document version changes and so does the tag. In rare cases, we may have\n// received a tag for a version we were yet to be in at the time, in which case we may already know\n// the tag of the new version, but most likely, this will set currentTag to undefined.\nfunction moveFutureTags() {\n\tcurrentTag = futureTags[doc.version];\n\t// Move all futureTags that are no longer \"future\" into allTags.\n\tObject.keys(futureTags).forEach(function (futureVersion) {\n\t\tif (futureVersion <= doc.version) {\n\t\t\tallTags[futureVersion] = futureTags[futureVersion];\n\t\t\tdelete futureTags[futureVersion];\n\t\t}\n\t});\n}\n\n// We can't set the currentTag until we have received all the tags and the document, so we know the\n// current version of the current. Therefore, we wait until both the document and tags have been\n// received using the promises below.\nvar docPromise = new Promise(function (accept, reject) {\n\tcoreEvents.addEventListener('receivedDocument', function (doc) {\n\t\treturn accept(doc);\n\t});\n});\n\nvar tagsPromise = new Promise(function (accept, reject) {\n\tcoreEvents.addEventListener('receivedTags', function (tags) {\n\t\treturn accept(tags);\n\t});\n});\n\n// We use two promises below, one just for doc and one for tags. In static mode, we won't receive\n// the tags, thus the document will never get set.\n// We can't just have two single promises, in case the tags promise gets resolved before the doc\n// promise.\n// TODO: Make sure we receive tags in static mode as well.\ndocPromise.then(function (_doc) {\n\tdoc = _doc;\n});\n\nPromise.all([docPromise, tagsPromise]).then(function (_ref) {\n\tvar _ref2 = _slicedToArray(_ref, 2),\n\t    _doc = _ref2[0],\n\t    tags = _ref2[1];\n\n\tcurrentTag = tags[doc.version];\n\n\t// We wait for both the document (so we know the version) and the tags to come in, before we can\n\t// start moving the currentTag 'tag pointer'.\n\tcoreEvents.addEventListener('receivedOps', moveFutureTags);\n\tcoreEvents.addEventListener('createdOps', moveFutureTags);\n});\n\n// Define functions on the global webstrate object to allow tagging and untagging.\n\n/**\n * Tag a document with a label at a specific version.\n * @param  {string} label      Tag label.\n * @param  {integer} version   (optional) Version.\n * @param  {Function} callback (optional) Callback to be called when done.\n * @public\n */\nglobalObject.publicObject.tag = function (label, version, callback) {\n\tif (!label && !version) {\n\t\treturn currentTag;\n\t}\n\n\tif (/^\\d/.test(label)) {\n\t\tthrow new Error('Tag name should not begin with a number');\n\t}\n\n\tif (label.includes('.')) {\n\t\tthrow new Error('Tag name should not contain periods');\n\t}\n\n\tif (typeof version === 'function') {\n\t\tcallback = version;\n\t\tversion = undefined;\n\t}\n\n\tif (!version) {\n\t\tversion = doc.version;\n\t}\n\n\tif (isNaN(version)) {\n\t\tthrow new Error('Version must be a number');\n\t}\n\n\tif (allTags[doc.version] === label) return;\n\tallTags[doc.version] = label;\n\twebsocket.send({\n\t\twa: 'tag',\n\t\td: doc.id,\n\t\tv: version,\n\t\tl: label\n\t}, callback);\n};\n\n/**\n * Untag a document with a tag or version\n * @param  {mixed} tagOrVersion Tag or version.\n * @public\n */\nglobalObject.publicObject.untag = function (tagOrVersion) {\n\tif (!tagOrVersion) {\n\t\tthrow new Error('Tag label or version number must he provided');\n\t}\n\n\tvar msgObj = {\n\t\twa: 'untag',\n\t\td: doc.id\n\t};\n\n\tvar version = void 0;\n\n\t// If tagOrVersion begins with a digit, we know it's a version.\n\tif (/^\\d/.test(tagOrVersion)) {\n\t\tversion = tagOrVersion;\n\t} else {\n\t\t// If it's a tag label, find the corresponding version.\n\t\tversion = Object.keys(allTags).find(function (candidateVersion) {\n\t\t\treturn allTags[candidateVersion] === tagOrVersion;\n\t\t});\n\t}\n\n\tmsgObj.v = version;\n\n\tif (!version) {\n\t\tthrow new Error('Provided tag does not exist');\n\t}\n\n\tdelete allTags[version];\n\twebsocket.send(msgObj);\n};\n\nObject.defineProperty(globalObject.publicObject, 'version', {\n\t// If our document is an instance of sharedb.Doc (which it will be, unless we're requesting\n\t// a static version of the document), then doc.version is defined. If doc is just a plain\n\t// JavaScript object, the doc.version will be undefined, but doc.v will exist.\n\tget: function get() {\n\t\treturn doc.version || doc.v;\n\t},\n\tset: function set(v) {\n\t\tthrow new Error('Version is read-only');\n\t}\n});\n\n/**\n * Get a object of all tags. Returns a frozen copy, so users won't (accidentally) modify it.\n * @return {obj} Object with tags, indexed by version number.\n * @public\n */\nglobalObject.publicObject.tags = function () {\n\treturn Object.freeze(coreUtils.objectClone(allTags));\n};\n\nmodule.exports = taggingModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/tagging.js\n// module id = 38\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/tagging.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar coreEvents = __webpack_require__(1);\nvar coreUtils = __webpack_require__(0);\nvar globalObject = __webpack_require__(2);\nvar nodeObjects = __webpack_require__(10);\n\n// If webstrate is transcluded in an iframe, we should probably raise an event on the frame element\n// in the parent document, so the parent document can trigger the transcluded event.\nif (coreUtils.isTranscluded()) {\n\t// If the domain of the iframe we're in is different from the parent's domain, we shouldn't raise\n\t// we won't be allowed to access frameElement due to cross-domain restrictions on iframes.\n\tif (coreUtils.sameParentDomain()) {\n\t\tcoreEvents.addEventListener('loadedTriggered', function () {\n\t\t\twindow.frameElement.dispatchEvent(new CustomEvent('transcluded', {\n\t\t\t\tdetail: [globalObject.publicObject.webstrateId, globalObject.publicObject.clientId, globalObject.publicObject.user],\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true\n\t\t\t}));\n\t\t}, coreEvents.PRIORITY.LAST);\n\t}\n}\n\n/**\n * Add 'transcluded' event to iframe. Do nothing if called with an element that is not an iframe.\n * @param {DOMNode} node       DOMNode.\n * @param {Object} eventObject Event object associated with the given DOM Node. This is the object\n *                             we should add the 'transcluded' event to if the node is an iframe.\n * @private\n */\nfunction addTransclusionEvent(node, eventObject) {\n\tif (node instanceof HTMLIFrameElement) {\n\t\tvar transcludedTriggered = false;\n\t\tvar eventDetails = void 0;\n\t\teventObject.createEvent('transcluded', {\n\t\t\taddListener: function addListener(callback) {\n\t\t\t\tif (transcludedTriggered) {\n\t\t\t\t\tsetImmediate.apply(undefined, [callback].concat(_toConsumableArray(eventDetails)));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdocument.addEventListener('transcluded', function (event) {\n\t\t\tif (event.target === node) {\n\t\t\t\ttranscludedTriggered = true;\n\t\t\t\teventDetails = event.detail;\n\t\t\t\teventObject.triggerEvent.apply(eventObject, ['transcluded'].concat(_toConsumableArray(eventDetails)));\n\t\t\t}\n\t\t});\n\t}\n}\n\n// Wait for all webstrate objects to be defined, then create a transcluded event on all iframe\n// elements and trigger the event once it has loaded (i.e. been populated).\ncoreEvents.addEventListener('webstrateObjectsAdded', function (nodeTree) {\n\tcoreUtils.recursiveForEach(nodeTree, function (node) {\n\t\tvar eventObject = nodeObjects.getEventObject(node);\n\t\taddTransclusionEvent(node, eventObject);\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// Also listen for future webstrate objects that gets added.\ncoreEvents.addEventListener('webstrateObjectAdded', function (node, eventObject) {\n\taddTransclusionEvent(node, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/transclusionEvent.js\n// module id = 39\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/transclusionEvent.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreWebsocket = __webpack_require__(3);\nvar userObject = __webpack_require__(11);\nvar coreUtils = __webpack_require__(0);\n\nvar userHistoryModule = {};\n\n// In static mode, the user object is not being sent to the client.\nif (!coreUtils.getLocationObject().staticMode && userObject.publicObject) {\n\tvar websocket = coreWebsocket.copy(function (event) {\n\t\treturn event.data.startsWith('{\"wa\":');\n\t});\n\n\tuserObject.publicObject.history = function (options) {\n\t\treturn new Promise(function (accept, reject) {\n\t\t\twebsocket.send({ wa: 'userHistory', options: options }, function (err, res) {\n\t\t\t\tif (err) reject(err);else accept(res);\n\t\t\t});\n\t\t});\n\t};\n}\n\nmodule.exports = userHistoryModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/userHistory.js\n// module id = 40\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/userHistory.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar coreUtils = __webpack_require__(0);\nvar coreEvents = __webpack_require__(1);\nvar coreWebsocket = __webpack_require__(3);\nvar userObject = __webpack_require__(11);\n\nvar userObjectSignalingModule = {};\n\n// In static mode, the user object is not being sent to the client, so we can't signal on it.\nif (!coreUtils.getLocationObject().staticMode) {\n\tcoreEvents.createEvent('userObjectSignal');\n\tuserObject.createEvent('signal');\n\n\tvar websocket = coreWebsocket.copy(function (event) {\n\t\treturn event.data.startsWith('{\"wa\":\"signalUserObject\"');\n\t});\n\tvar webstrateId = coreUtils.getLocationObject().webstrateId;\n\n\twebsocket.onjsonmessage = function (payload) {\n\t\tvar message = payload.m;\n\t\tvar senderClientId = payload.s;\n\t\tvar senderWebstrateId = payload.sw;\n\n\t\tcoreEvents.triggerEvent('userObjectSignal', message, senderClientId, senderWebstrateId);\n\t\tuserObject.triggerEvent('signal', message, senderClientId, senderWebstrateId);\n\t};\n\n\tObject.defineProperty(userObject.publicObject, 'signal', {\n\t\tvalue: function value(message) {\n\t\t\tif (!userObject.publicObject.userId || userObject.publicObject.userId === 'anonymous:') {\n\t\t\t\tthrow new Error('User must be logged in to signal on user object.');\n\t\t\t}\n\t\t\tvar msgObj = {\n\t\t\t\twa: 'signalUserObject',\n\t\t\t\td: webstrateId,\n\t\t\t\tm: message\n\t\t\t};\n\t\t\twebsocket.send(msgObj);\n\t\t}\n\t});\n}\n\nmodule.exports = userObjectSignalingModule;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/userObjectSignaling.js\n// module id = 41\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates/userObjectSignaling.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform;\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function transformComponentX(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function (leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function (op, otherOp, type) {\n    if (!(type === 'left' || type === 'right')) throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1) return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left') return transformX(op, otherOp)[0];else return transformX(otherOp, op)[1];\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/bootstrapTransform.js\n// module id = 42\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/ot-json0/lib/bootstrapTransform.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function isArray(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function isObject(obj) {\n  return !!obj && obj.constructor === Object;\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function clone(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function (subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function (data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function (c) {\n  var c_ = { p: c.p };\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length - 1];\n    c_.p = c.p.slice(0, c.p.length - 1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function (op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function (op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function (elem) {\n  if (!isArray(elem)) throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function (elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = { p: c.p.pop() };\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function (snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null) convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null) throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n      // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number') throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n        json.checkList(elem);\n        // Should check the list element matches c.ld\n        elem[key] = c.li;\n      }\n\n      // List insert\n      else if (c.li !== void 0) {\n          json.checkList(elem);\n          elem.splice(key, 0, c.li);\n        }\n\n        // List delete\n        else if (c.ld !== void 0) {\n            json.checkList(elem);\n            // Should check the list element matches c.ld here too.\n            elem.splice(key, 1);\n          }\n\n          // List move\n          else if (c.lm !== void 0) {\n              json.checkList(elem);\n              if (c.lm != key) {\n                var e = elem[key];\n                // Remove it...\n                elem.splice(key, 1);\n                // And insert it back.\n                elem.splice(c.lm, 0, e);\n              }\n            }\n\n            // Object insert / replace\n            else if (c.oi !== void 0) {\n                json.checkObj(elem);\n\n                // Should check that elem[key] == c.od\n                elem[key] = c.oi;\n              }\n\n              // Object delete\n              else if (c.od !== void 0) {\n                  json.checkObj(elem);\n\n                  // Should check that elem[key] == c.od\n                  delete elem[key];\n                } else {\n                  throw new Error('invalid / missing instruction in op');\n                }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function (op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function (snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function (p1, p2, ignoreLast) {\n  if (p1.length != p2.length) return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1)) return false;\n  }\n\n  return true;\n};\n\njson.append = function (dest, c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = { p: last.p, na: last.na + c.na };\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function (op1, op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp, op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function (op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function (a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t) alen++;\n\n  if (b.na != null || b.t) blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i]) return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function (op, path) {\n  return json.commonLengthForOps({ p: path }, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function (dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t) cplength++;\n\n  if (otherC.na != null || otherC.t) otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld), [oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od), [oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        // convert back to old string ops\n        if (c.si != null || c.sd != null) {\n          var p = c.p;\n          for (var i = 0; i < res.length; i++) {\n            c.o = [res[i]];\n            c.p = p.slice();\n            convertToText(c);\n            json.append(dest, c);\n          }\n        } else if (!isArray(res) || res.length > 0) {\n          c.o = res;\n          json.append(dest, c);\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n        // this case is handled below\n      } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n        if (otherC.p[common] === c.p[common]) {\n          // noop\n\n          if (!commonOperand) {\n            return dest;\n          } else if (c.ld !== void 0) {\n            // we're trying to delete the same element, -> noop\n            if (c.li !== void 0 && type === 'left') {\n              // we're both replacing one element with another. only one can survive\n              c.ld = clone(otherC.li);\n            } else {\n              return dest;\n            }\n          }\n        }\n      } else if (otherC.li !== void 0) {\n        if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n          // in li vs. li, left wins.\n          if (type === 'right') c.p[common]++;\n        } else if (otherC.p[common] <= c.p[common]) {\n          c.p[common]++;\n        }\n\n        if (c.lm !== void 0) {\n          if (commonOperand) {\n            // otherC edits the same list we edit\n            if (otherC.p[common] <= c.lm) c.lm++;\n            // changing c.from is handled above.\n          }\n        }\n      } else if (otherC.ld !== void 0) {\n        if (c.lm !== void 0) {\n          if (commonOperand) {\n            if (otherC.p[common] === c.p[common]) {\n              // they deleted the thing we're trying to move\n              return dest;\n            }\n            // otherC edits the same list we edit\n            var p = otherC.p[common];\n            var from = c.p[common];\n            var to = c.lm;\n            if (p < to || p === to && from < to) c.lm--;\n          }\n        }\n\n        if (otherC.p[common] < c.p[common]) {\n          c.p[common]--;\n        } else if (otherC.p[common] === c.p[common]) {\n          if (otherCplength < cplength) {\n            // we're below the deleted element, so -> noop\n            return dest;\n          } else if (c.ld !== void 0) {\n            if (c.li !== void 0) {\n              // we're replacing, they're deleting. we become an insert.\n              delete c.ld;\n            } else {\n              // we're trying to delete the same element, -> noop\n              return dest;\n            }\n          }\n        }\n      } else if (otherC.lm !== void 0) {\n        if (c.lm !== void 0 && cplength === otherCplength) {\n          // lm vs lm, here we go!\n          var from = c.p[common];\n          var to = c.lm;\n          var otherFrom = otherC.p[common];\n          var otherTo = otherC.lm;\n          if (otherFrom !== otherTo) {\n            // if otherFrom == otherTo, we don't need to change our op.\n\n            // where did my thing go?\n            if (from === otherFrom) {\n              // they moved it! tie break.\n              if (type === 'left') {\n                c.p[common] = otherTo;\n                if (from === to) // ugh\n                  c.lm = otherTo;\n              } else {\n                return dest;\n              }\n            } else {\n              // they moved around it\n              if (from > otherFrom) c.p[common]--;\n              if (from > otherTo) c.p[common]++;else if (from === otherTo) {\n                if (otherFrom > otherTo) {\n                  c.p[common]++;\n                  if (from === to) // ugh, again\n                    c.lm++;\n                }\n              }\n\n              // step 2: where am i going to put it?\n              if (to > otherFrom) {\n                c.lm--;\n              } else if (to === otherFrom) {\n                if (to > from) c.lm--;\n              }\n              if (to > otherTo) {\n                c.lm++;\n              } else if (to === otherTo) {\n                // if we're both moving in the same direction, tie break\n                if (otherTo > otherFrom && to > from || otherTo < otherFrom && to < from) {\n                  if (type === 'right') c.lm++;\n                } else {\n                  if (to > from) c.lm++;else if (to === otherFrom) c.lm--;\n                }\n              }\n            }\n          }\n        } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n          // li\n          var from = otherC.p[common];\n          var to = otherC.lm;\n          p = c.p[common];\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n        } else {\n          // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n          // the lm\n          //\n          // i.e. things care about where their item is after the move.\n          var from = otherC.p[common];\n          var to = otherC.lm;\n          p = c.p[common];\n          if (p === from) {\n            c.p[common] = to;\n          } else {\n            if (p > from) c.p[common]--;\n            if (p > to) c.p[common]++;else if (p === to && from > to) c.p[common]++;\n          }\n        }\n      } else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n        if (c.p[common] === otherC.p[common]) {\n          if (c.oi !== void 0 && commonOperand) {\n            // we inserted where someone else replaced\n            if (type === 'right') {\n              // left wins\n              return dest;\n            } else {\n              // we win, make our op replace what they inserted\n              c.od = otherC.oi;\n            }\n          } else {\n            // -> noop if the other component is deleting the same object (or any parent)\n            return dest;\n          }\n        }\n      } else if (otherC.oi !== void 0) {\n        if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n          // left wins if we try to insert at the same place\n          if (type === 'left') {\n            json.append(dest, { p: c.p, od: otherC.oi });\n          } else {\n            return dest;\n          }\n        }\n      } else if (otherC.od !== void 0) {\n        if (c.p[common] == otherC.p[common]) {\n          if (!commonOperand) return dest;\n          if (c.oi !== void 0) {\n            delete c.od;\n          } else {\n            return dest;\n          }\n        }\n      }\n  }\n\n  json.append(dest, c);\n  return dest;\n};\n\n__webpack_require__(42)(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = __webpack_require__(54);\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/json0.js\n// module id = 43\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/ot-json0/lib/json0.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar emitter = __webpack_require__(18);\nvar logger = __webpack_require__(22);\nvar ShareDBError = __webpack_require__(21);\nvar types = __webpack_require__(23);\n\n/**\n * A Doc is a client's view on a sharejs document.\n *\n * It is is uniquely identified by its `id` and `collection`.  Documents\n * should not be created directly. Create them with connection.get()\n *\n *\n * Subscriptions\n * -------------\n *\n * We can subscribe a document to stay in sync with the server.\n *   doc.subscribe(function(error) {\n *     doc.subscribed // = true\n *   })\n * The server now sends us all changes concerning this document and these are\n * applied to our data. If the subscription was successful the initial\n * data and version sent by the server are loaded into the document.\n *\n * To stop listening to the changes we call `doc.unsubscribe()`.\n *\n * If we just want to load the data but not stay up-to-date, we call\n *   doc.fetch(function(error) {\n *     doc.data // sent by server\n *   })\n *\n *\n * Events\n * ------\n *\n * You can use doc.on(eventName, callback) to subscribe to the following events:\n * - `before op (op, source)` Fired before a partial operation is applied to the data.\n *   It may be used to read the old data just before applying an operation\n * - `op (op, source)` Fired after every partial operation with this operation as the\n *   first argument\n * - `create (source)` The document was created. That means its type was\n *   set and it has some initial data.\n * - `del (data, source)` Fired after the document is deleted, that is\n *   the data is null. It is passed the data before delteion as an\n *   arguments\n * - `load ()` Fired when a new snapshot is ingested from a fetch, subscribe, or query\n */\n\nmodule.exports = Doc;\nfunction Doc(connection, collection, id) {\n  emitter.EventEmitter.call(this);\n\n  this.connection = connection;\n\n  this.collection = collection;\n  this.id = id;\n\n  this.version = null;\n  this.type = null;\n  this.data = undefined;\n\n  // Array of callbacks or nulls as placeholders\n  this.inflightFetch = [];\n  this.inflightSubscribe = [];\n  this.inflightUnsubscribe = [];\n  this.pendingFetch = [];\n\n  // Whether we think we are subscribed on the server. Synchronously set to\n  // false on calls to unsubscribe and disconnect. Should never be true when\n  // this.wantSubscribe is false\n  this.subscribed = false;\n  // Whether to re-establish the subscription on reconnect\n  this.wantSubscribe = false;\n\n  // The op that is currently roundtripping to the server, or null.\n  //\n  // When the connection reconnects, the inflight op is resubmitted.\n  //\n  // This has the same format as an entry in pendingOps\n  this.inflightOp = null;\n\n  // All ops that are waiting for the server to acknowledge this.inflightOp\n  // This used to just be a single operation, but creates & deletes can't be\n  // composed with regular operations.\n  //\n  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}\n  this.pendingOps = [];\n\n  // The OT type of this document. An uncreated document has type `null`\n  this.type = null;\n\n  // The applyStack enables us to track any ops submitted while we are\n  // applying an op incrementally. This value is an array when we are\n  // performing an incremental apply and null otherwise. When it is an array,\n  // all submitted ops should be pushed onto it. The `_otApply` method will\n  // reset it back to null when all incremental apply loops are complete.\n  this.applyStack = null;\n\n  // Disable the default behavior of composing submitted ops. This is read at\n  // the time of op submit, so it may be toggled on before submitting a\n  // specifc op and toggled off afterward\n  this.preventCompose = false;\n}\nemitter.mixin(Doc);\n\nDoc.prototype.destroy = function (callback) {\n  var doc = this;\n  doc.whenNothingPending(function () {\n    if (doc.wantSubscribe) {\n      doc.unsubscribe(function (err) {\n        if (err) {\n          if (callback) return callback(err);\n          return doc.emit('error', err);\n        }\n        doc.connection._destroyDoc(doc);\n        if (callback) callback();\n      });\n    } else {\n      doc.connection._destroyDoc(doc);\n      if (callback) callback();\n    }\n  });\n};\n\n// ****** Manipulating the document data, version and type.\n\n// Set the document's type, and associated properties. Most of the logic in\n// this function exists to update the document based on any added & removed API\n// methods.\n//\n// @param newType OT type provided by the ottypes library or its name or uri\nDoc.prototype._setType = function (newType) {\n  if (typeof newType === 'string') {\n    newType = types.map[newType];\n  }\n\n  if (newType) {\n    this.type = newType;\n  } else if (newType === null) {\n    this.type = newType;\n    // If we removed the type from the object, also remove its data\n    this.data = undefined;\n  } else {\n    var err = new ShareDBError(4008, 'Missing type ' + newType);\n    return this.emit('error', err);\n  }\n};\n\n// Ingest snapshot data. This data must include a version, snapshot and type.\n// This is used both to ingest data that was exported with a webpage and data\n// that was received from the server during a fetch.\n//\n// @param snapshot.v    version\n// @param snapshot.data\n// @param snapshot.type\n// @param callback\nDoc.prototype.ingestSnapshot = function (snapshot, callback) {\n  if (!snapshot) return callback && callback();\n\n  if (typeof snapshot.v !== 'number') {\n    var err = new ShareDBError(5008, 'Missing version in ingested snapshot. ' + this.collection + '.' + this.id);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n\n  // If the doc is already created or there are ops pending, we cannot use the\n  // ingested snapshot and need ops in order to update the document\n  if (this.type || this.hasWritePending()) {\n    // The version should only be null on a created document when it was\n    // created locally without fetching\n    if (this.version == null) {\n      if (this.hasWritePending()) {\n        // If we have pending ops and we get a snapshot for a locally created\n        // document, we have to wait for the pending ops to complete, because\n        // we don't know what version to fetch ops from. It is possible that\n        // the snapshot came from our local op, but it is also possible that\n        // the doc was created remotely (which would conflict and be an error)\n        return callback && this.once('no write pending', callback);\n      }\n      // Otherwise, we've encounted an error state\n      var err = new ShareDBError(5009, 'Cannot ingest snapshot in doc with null version. ' + this.collection + '.' + this.id);\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // If we got a snapshot for a version further along than the document is\n    // currently, issue a fetch to get the latest ops and catch us up\n    if (snapshot.v > this.version) return this.fetch(callback);\n    return callback && callback();\n  }\n\n  // Ignore the snapshot if we are already at a newer version. Under no\n  // circumstance should we ever set the current version backward\n  if (this.version > snapshot.v) return callback && callback();\n\n  this.version = snapshot.v;\n  var type = snapshot.type === undefined ? types.defaultType : snapshot.type;\n  this._setType(type);\n  this.data = this.type && this.type.deserialize ? this.type.deserialize(snapshot.data) : snapshot.data;\n  this.emit('load');\n  callback && callback();\n};\n\nDoc.prototype.whenNothingPending = function (callback) {\n  var doc = this;\n  process.nextTick(function () {\n    if (doc.hasPending()) {\n      doc.once('nothing pending', callback);\n      return;\n    }\n    callback();\n  });\n};\n\nDoc.prototype.hasPending = function () {\n  return !!(this.inflightOp || this.pendingOps.length || this.inflightFetch.length || this.inflightSubscribe.length || this.inflightUnsubscribe.length || this.pendingFetch.length);\n};\n\nDoc.prototype.hasWritePending = function () {\n  return !!(this.inflightOp || this.pendingOps.length);\n};\n\nDoc.prototype._emitNothingPending = function () {\n  if (this.hasWritePending()) return;\n  this.emit('no write pending');\n  if (this.hasPending()) return;\n  this.emit('nothing pending');\n};\n\n// **** Helpers for network messages\n\nDoc.prototype._emitResponseError = function (err, callback) {\n  if (callback) {\n    callback(err);\n    this._emitNothingPending();\n    return;\n  }\n  this._emitNothingPending();\n  this.emit('error', err);\n};\n\nDoc.prototype._handleFetch = function (err, snapshot) {\n  var callback = this.inflightFetch.shift();\n  if (err) return this._emitResponseError(err, callback);\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleSubscribe = function (err, snapshot) {\n  var callback = this.inflightSubscribe.shift();\n  if (err) return this._emitResponseError(err, callback);\n  // Indicate we are subscribed only if the client still wants to be. In the\n  // time since calling subscribe and receiving a response from the server,\n  // unsubscribe could have been called and we might already be unsubscribed\n  // but not have received the response. Also, because requests from the\n  // client are not serialized and may take different async time to process,\n  // it is possible that we could hear responses back in a different order\n  // from the order originally sent\n  if (this.wantSubscribe) this.subscribed = true;\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleUnsubscribe = function (err) {\n  var callback = this.inflightUnsubscribe.shift();\n  if (err) return this._emitResponseError(err, callback);\n  if (callback) callback();\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleOp = function (err, message) {\n  if (err) {\n    if (this.inflightOp) {\n      // The server has rejected submission of the current operation. If we get\n      // an error code 4002 \"Op submit rejected\", this was done intentionally\n      // and we should roll back but not return an error to the user.\n      if (err.code === 4002) err = null;\n      return this._rollback(err);\n    }\n    return this.emit('error', err);\n  }\n\n  if (this.inflightOp && message.src === this.inflightOp.src && message.seq === this.inflightOp.seq) {\n    // The op has already been applied locally. Just update the version\n    // and pending state appropriately\n    this._opAcknowledged(message);\n    return;\n  }\n\n  if (this.version == null || message.v > this.version) {\n    // This will happen in normal operation if we become subscribed to a\n    // new document via a query. It can also happen if we get an op for\n    // a future version beyond the version we are expecting next. This\n    // could happen if the server doesn't publish an op for whatever reason\n    // or because of a race condition. In any case, we can send a fetch\n    // command to catch back up.\n    //\n    // Fetch only sends a new fetch command if no fetches are inflight, which\n    // will act as a natural debouncing so we don't send multiple fetch\n    // requests for many ops received at once.\n    this.fetch();\n    return;\n  }\n\n  if (message.v < this.version) {\n    // We can safely ignore the old (duplicate) operation.\n    return;\n  }\n\n  if (this.inflightOp) {\n    var transformErr = transformX(this.inflightOp, message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  for (var i = 0; i < this.pendingOps.length; i++) {\n    var transformErr = transformX(this.pendingOps[i], message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  this.version++;\n  try {\n    this._otApply(message, false);\n  } catch (error) {\n    return this._hardRollback(error);\n  }\n};\n\n// Called whenever (you guessed it!) the connection state changes. This will\n// happen when we get disconnected & reconnect.\nDoc.prototype._onConnectionStateChanged = function () {\n  if (this.connection.canSend) {\n    this.flush();\n    this._resubscribe();\n  } else {\n    if (this.inflightOp) {\n      this.pendingOps.unshift(this.inflightOp);\n      this.inflightOp = null;\n    }\n    this.subscribed = false;\n    if (this.inflightFetch.length || this.inflightSubscribe.length) {\n      this.pendingFetch = this.pendingFetch.concat(this.inflightFetch, this.inflightSubscribe);\n      this.inflightFetch.length = 0;\n      this.inflightSubscribe.length = 0;\n    }\n    if (this.inflightUnsubscribe.length) {\n      var callbacks = this.inflightUnsubscribe;\n      this.inflightUnsubscribe = [];\n      callEach(callbacks);\n    }\n  }\n};\n\nDoc.prototype._resubscribe = function () {\n  var callbacks = this.pendingFetch;\n  this.pendingFetch = [];\n\n  if (this.wantSubscribe) {\n    if (callbacks.length) {\n      this.subscribe(function (err) {\n        callEach(callbacks, err);\n      });\n      return;\n    }\n    this.subscribe();\n    return;\n  }\n\n  if (callbacks.length) {\n    this.fetch(function (err) {\n      callEach(callbacks, err);\n    });\n  }\n};\n\n// Request the current document snapshot or ops that bring us up to date\nDoc.prototype.fetch = function (callback) {\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendFetch(this);\n    pushActionCallback(this.inflightFetch, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Fetch the initial document and keep receiving updates\nDoc.prototype.subscribe = function (callback) {\n  this.wantSubscribe = true;\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendSubscribe(this);\n    pushActionCallback(this.inflightSubscribe, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Unsubscribe. The data will stay around in local memory, but we'll stop\n// receiving updates\nDoc.prototype.unsubscribe = function (callback) {\n  this.wantSubscribe = false;\n  // The subscribed state should be conservative in indicating when we are\n  // subscribed on the server. We'll actually be unsubscribed some time\n  // between sending the message and hearing back, but we cannot know exactly\n  // when. Thus, immediately mark us as not subscribed\n  this.subscribed = false;\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendUnsubscribe(this);\n    pushActionCallback(this.inflightUnsubscribe, isDuplicate, callback);\n    return;\n  }\n  if (callback) process.nextTick(callback);\n};\n\nfunction pushActionCallback(inflight, isDuplicate, callback) {\n  if (isDuplicate) {\n    var lastCallback = inflight.pop();\n    inflight.push(function (err) {\n      lastCallback && lastCallback(err);\n      callback && callback(err);\n    });\n  } else {\n    inflight.push(callback);\n  }\n}\n\n// Operations //\n\n// Send the next pending op to the server, if we can.\n//\n// Only one operation can be in-flight at a time. If an operation is already on\n// its way, or we're not currently connected, this method does nothing.\nDoc.prototype.flush = function () {\n  // Ignore if we can't send or we are already sending an op\n  if (!this.connection.canSend || this.inflightOp) return;\n\n  // Send first pending op unless paused\n  if (!this.paused && this.pendingOps.length) {\n    this._sendOp();\n  }\n};\n\n// Helper function to set op to contain a no-op.\nfunction setNoOp(op) {\n  delete op.op;\n  delete op.create;\n  delete op.del;\n}\n\n// Transform server op data by a client op, and vice versa. Ops are edited in place.\nfunction transformX(client, server) {\n  // Order of statements in this function matters. Be especially careful if\n  // refactoring this function\n\n  // A client delete op should dominate if both the server and the client\n  // delete the document. Thus, any ops following the client delete (such as a\n  // subsequent create) will be maintained, since the server op is transformed\n  // to a no-op\n  if (client.del) return setNoOp(server);\n\n  if (server.del) {\n    return new ShareDBError(4017, 'Document was deleted');\n  }\n  if (server.create) {\n    return new ShareDBError(4018, 'Document alredy created');\n  }\n\n  // Ignore no-op coming from server\n  if (!server.op) return;\n\n  // I believe that this should not occur, but check just in case\n  if (client.create) {\n    return new ShareDBError(4018, 'Document already created');\n  }\n\n  // They both edited the document. This is the normal case for this function -\n  // as in, most of the time we'll end up down here.\n  //\n  // You should be wondering why I'm using client.type instead of this.type.\n  // The reason is, if we get ops at an old version of the document, this.type\n  // might be undefined or a totally different type. By pinning the type to the\n  // op data, we make sure the right type has its transform function called.\n  if (client.type.transformX) {\n    var result = client.type.transformX(client.op, server.op);\n    client.op = result[0];\n    server.op = result[1];\n  } else {\n    var clientOp = client.type.transform(client.op, server.op, 'left');\n    var serverOp = client.type.transform(server.op, client.op, 'right');\n    client.op = clientOp;\n    server.op = serverOp;\n  }\n};\n\n/**\n * Applies the operation to the snapshot\n *\n * If the operation is create or delete it emits `create` or `del`. Then the\n * operation is applied to the snapshot and `op` and `after op` are emitted.\n * If the type supports incremental updates and `this.incremental` is true we\n * fire `op` after every small operation.\n *\n * This is the only function to fire the above mentioned events.\n *\n * @private\n */\nDoc.prototype._otApply = function (op, source) {\n  if (op.op) {\n    if (!this.type) {\n      // Throw here, because all usage of _otApply should be wrapped with a try/catch\n      throw new ShareDBError(4015, 'Cannot apply op to uncreated document. ' + this.collection + '.' + this.id);\n    }\n\n    // Iteratively apply multi-component remote operations and rollback ops\n    // (source === false) for the default JSON0 OT type. It could use\n    // type.shatter(), but since this code is so specific to use cases for the\n    // JSON0 type and ShareDB explicitly bundles the default type, we might as\n    // well write it this way and save needing to iterate through the op\n    // components twice.\n    //\n    // Ideally, we would not need this extra complexity. However, it is\n    // helpful for implementing bindings that update DOM nodes and other\n    // stateful objects by translating op events directly into corresponding\n    // mutations. Such bindings are most easily written as responding to\n    // individual op components one at a time in order, and it is important\n    // that the snapshot only include updates from the particular op component\n    // at the time of emission. Eliminating this would require rethinking how\n    // such external bindings are implemented.\n    if (!source && this.type === types.defaultType && op.op.length > 1) {\n      if (!this.applyStack) this.applyStack = [];\n      var stackLength = this.applyStack.length;\n      for (var i = 0; i < op.op.length; i++) {\n        var component = op.op[i];\n        var componentOp = { op: [component] };\n        // Transform componentOp against any ops that have been submitted\n        // sychronously inside of an op event handler since we began apply of\n        // our operation\n        for (var j = stackLength; j < this.applyStack.length; j++) {\n          var transformErr = transformX(this.applyStack[j], componentOp);\n          if (transformErr) return this._hardRollback(transformErr);\n        }\n        // Apply the individual op component\n        this.emit('before op', componentOp.op, source);\n        this.data = this.type.apply(this.data, componentOp.op);\n        this.emit('op', componentOp.op, source);\n      }\n      // Pop whatever was submitted since we started applying this op\n      this._popApplyStack(stackLength);\n      return;\n    }\n\n    // The 'before op' event enables clients to pull any necessary data out of\n    // the snapshot before it gets changed\n    this.emit('before op', op.op, source);\n    // Apply the operation to the local data, mutating it in place\n    this.data = this.type.apply(this.data, op.op);\n    // Emit an 'op' event once the local data includes the changes from the\n    // op. For locally submitted ops, this will be synchronously with\n    // submission and before the server or other clients have received the op.\n    // For ops from other clients, this will be after the op has been\n    // committed to the database and published\n    this.emit('op', op.op, source);\n    return;\n  }\n\n  if (op.create) {\n    this._setType(op.create.type);\n    this.data = this.type.deserialize ? this.type.createDeserialized ? this.type.createDeserialized(op.create.data) : this.type.deserialize(this.type.create(op.create.data)) : this.type.create(op.create.data);\n    this.emit('create', source);\n    return;\n  }\n\n  if (op.del) {\n    var oldData = this.data;\n    this._setType(null);\n    this.emit('del', oldData, source);\n    return;\n  }\n};\n\n// ***** Sending operations\n\n// Actually send op to the server.\nDoc.prototype._sendOp = function () {\n  // Wait until we have a src id from the server\n  var src = this.connection.id;\n  if (!src) return;\n\n  // When there is no inflightOp, send the first item in pendingOps. If\n  // there is inflightOp, try sending it again\n  if (!this.inflightOp) {\n    // Send first pending op\n    this.inflightOp = this.pendingOps.shift();\n  }\n  var op = this.inflightOp;\n  if (!op) {\n    var err = new ShareDBError(5010, 'No op to send on call to _sendOp');\n    return this.emit('error', err);\n  }\n\n  // Track data for retrying ops\n  op.sentAt = Date.now();\n  op.retries = op.retries == null ? 0 : op.retries + 1;\n\n  // The src + seq number is a unique ID representing this operation. This tuple\n  // is used on the server to detect when ops have been sent multiple times and\n  // on the client to match acknowledgement of an op back to the inflightOp.\n  // Note that the src could be different from this.connection.id after a\n  // reconnect, since an op may still be pending after the reconnection and\n  // this.connection.id will change. In case an op is sent multiple times, we\n  // also need to be careful not to override the original seq value.\n  if (op.seq == null) op.seq = this.connection.seq++;\n\n  this.connection.sendOp(this, op);\n\n  // src isn't needed on the first try, since the server session will have the\n  // same id, but it must be set on the inflightOp in case it is sent again\n  // after a reconnect and the connection's id has changed by then\n  if (op.src == null) op.src = src;\n};\n\n// Queues the operation for submission to the server and applies it locally.\n//\n// Internal method called to do the actual work for submit(), create() and del().\n// @private\n//\n// @param op\n// @param [op.op]\n// @param [op.del]\n// @param [op.create]\n// @param [callback] called when operation is submitted\nDoc.prototype._submit = function (op, source, callback) {\n  // Locally submitted ops must always have a truthy source\n  if (!source) source = true;\n\n  // The op contains either op, create, delete, or none of the above (a no-op).\n  if (op.op) {\n    if (!this.type) {\n      var err = new ShareDBError(4015, 'Cannot submit op. Document has not been created. ' + this.collection + '.' + this.id);\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // Try to normalize the op. This removes trailing skip:0's and things like that.\n    if (this.type.normalize) op.op = this.type.normalize(op.op);\n  }\n\n  try {\n    this._pushOp(op, callback);\n    this._otApply(op, source);\n  } catch (error) {\n    return this._hardRollback(error);\n  }\n\n  // The call to flush is delayed so if submit() is called multiple times\n  // synchronously, all the ops are combined before being sent to the server.\n  var doc = this;\n  process.nextTick(function () {\n    doc.flush();\n  });\n};\n\nDoc.prototype._pushOp = function (op, callback) {\n  if (this.applyStack) {\n    // If we are in the process of incrementally applying an operation, don't\n    // compose the op and push it onto the applyStack so it can be transformed\n    // against other components from the op or ops being applied\n    this.applyStack.push(op);\n  } else {\n    // If the type supports composes, try to compose the operation onto the\n    // end of the last pending operation.\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks.push(callback);\n      return;\n    }\n  }\n  // Push on to the pendingOps queue of ops to submit if we didn't compose\n  op.type = this.type;\n  op.callbacks = [callback];\n  this.pendingOps.push(op);\n};\n\nDoc.prototype._popApplyStack = function (to) {\n  if (to > 0) {\n    this.applyStack.length = to;\n    return;\n  }\n  // Once we have completed the outermost apply loop, reset to null and no\n  // longer add ops to the applyStack as they are submitted\n  var op = this.applyStack[0];\n  this.applyStack = null;\n  if (!op) return;\n  // Compose the ops added since the beginning of the apply stack, since we\n  // had to skip compose when they were originally pushed\n  var i = this.pendingOps.indexOf(op);\n  if (i === -1) return;\n  var ops = this.pendingOps.splice(i);\n  for (var i = 0; i < ops.length; i++) {\n    var op = ops[i];\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks = composed.callbacks.concat(op.callbacks);\n    } else {\n      this.pendingOps.push(op);\n    }\n  }\n};\n\n// Try to compose a submitted op into the last pending op. Returns the\n// composed op if it succeeds, undefined otherwise\nDoc.prototype._tryCompose = function (op) {\n  if (this.preventCompose) return;\n\n  // We can only compose into the last pending op. Inflight ops have already\n  // been sent to the server, so we can't modify them\n  var last = this.pendingOps[this.pendingOps.length - 1];\n  if (!last) return;\n\n  // Compose an op into a create by applying it. This effectively makes the op\n  // invisible, as if the document were created including the op originally\n  if (last.create && op.op) {\n    last.create.data = this.type.apply(last.create.data, op.op);\n    return last;\n  }\n\n  // Compose two ops into a single op if supported by the type. Types that\n  // support compose must be able to compose any two ops together\n  if (last.op && op.op && this.type.compose) {\n    last.op = this.type.compose(last.op, op.op);\n    return last;\n  }\n};\n\n// *** Client OT entrypoints.\n\n// Submit an operation to the document.\n//\n// @param operation handled by the OT type\n// @param options  {source: ...}\n// @param [callback] called after operation submitted\n//\n// @fires before op, op, after op\nDoc.prototype.submitOp = function (component, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  var op = { op: component };\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Create the document, which in ShareJS semantics means to set its type. Every\n// object implicitly exists in the database but has no data and no type. Create\n// sets the type of the object and can optionally set some initial data on the\n// object, depending on the type.\n//\n// @param data  initial\n// @param type  OT type\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.create = function (data, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = null;\n    type = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!type) {\n    type = types.defaultType.uri;\n  }\n  if (this.type) {\n    var err = new ShareDBError(4016, 'Document already exists');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = { create: { type: type, data: data } };\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Delete the document. This creates and submits a delete operation to the\n// server. Deleting resets the object's type to null and deletes its data. The\n// document still exists, and still has the version it used to have before you\n// deleted it (well, old version +1).\n//\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.del = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!this.type) {\n    var err = new ShareDBError(4015, 'Document does not exist');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = { del: true };\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Stops the document from sending any operations to the server.\nDoc.prototype.pause = function () {\n  this.paused = true;\n};\n\n// Continue sending operations to the server\nDoc.prototype.resume = function () {\n  this.paused = false;\n  this.flush();\n};\n\n// *** Receiving operations\n\n// This is called when the server acknowledges an operation from the client.\nDoc.prototype._opAcknowledged = function (message) {\n  if (this.inflightOp.create) {\n    this.version = message.v;\n  } else if (message.v !== this.version) {\n    // We should already be at the same version, because the server should\n    // have sent all the ops that have happened before acknowledging our op\n    logger.warn('Invalid version from server. Expected: ' + this.version + ' Received: ' + message.v, message);\n\n    // Fetching should get us back to a working document state\n    return this.fetch();\n  }\n\n  // The op was committed successfully. Increment the version number\n  this.version++;\n\n  this._clearInflightOp();\n};\n\nDoc.prototype._rollback = function (err) {\n  // The server has rejected submission of the current operation. Invert by\n  // just the inflight op if possible. If not possible to invert, cancel all\n  // pending ops and fetch the latest from the server to get us back into a\n  // working state, then call back\n  var op = this.inflightOp;\n\n  if (op.op && op.type.invert) {\n    op.op = op.type.invert(op.op);\n\n    // Transform the undo operation by any pending ops.\n    for (var i = 0; i < this.pendingOps.length; i++) {\n      var transformErr = transformX(this.pendingOps[i], op);\n      if (transformErr) return this._hardRollback(transformErr);\n    }\n\n    // ... and apply it locally, reverting the changes.\n    //\n    // This operation is applied to look like it comes from a remote source.\n    // I'm still not 100% sure about this functionality, because its really a\n    // local op. Basically, the problem is that if the client's op is rejected\n    // by the server, the editor window should update to reflect the undo.\n    try {\n      this._otApply(op, false);\n    } catch (error) {\n      return this._hardRollback(error);\n    }\n\n    this._clearInflightOp(err);\n    return;\n  }\n\n  this._hardRollback(err);\n};\n\nDoc.prototype._hardRollback = function (err) {\n  // Store pending ops so that we can notify their callbacks of the error.\n  // We combine the inflight op and the pending ops, because it's possible\n  // to hit a condition where we have no inflight op, but we do have pending\n  // ops. This can happen when an invalid op is submitted, which causes us\n  // to hard rollback before the pending op was flushed.\n  var pendingOps = [];\n  if (this.inflightOp) pendingOps.push(this.inflightOp);\n  pendingOps = pendingOps.concat(this.pendingOps);\n\n  // Cancel all pending ops and reset if we can't invert\n  this._setType(null);\n  this.version = null;\n  this.inflightOp = null;\n  this.pendingOps = [];\n\n  // Fetch the latest version from the server to get us back into a working state\n  var doc = this;\n  this.fetch(function () {\n    // We want to check that no errors are swallowed, so we check that:\n    // - there are callbacks to call, and\n    // - that every single pending op called a callback\n    // If there are no ops queued, or one of them didn't handle the error,\n    // then we emit the error.\n    var allOpsHadCallbacks = !!pendingOps.length;\n    for (var i = 0; i < pendingOps.length; i++) {\n      allOpsHadCallbacks = callEach(pendingOps[i].callbacks, err) && allOpsHadCallbacks;\n    }\n    if (err && !allOpsHadCallbacks) return doc.emit('error', err);\n  });\n};\n\nDoc.prototype._clearInflightOp = function (err) {\n  var inflightOp = this.inflightOp;\n\n  this.inflightOp = null;\n\n  var called = callEach(inflightOp.callbacks, err);\n\n  this.flush();\n  this._emitNothingPending();\n\n  if (err && !called) return this.emit('error', err);\n};\n\nfunction callEach(callbacks, err) {\n  var called = false;\n  for (var i = 0; i < callbacks.length; i++) {\n    var callback = callbacks[i];\n    if (callback) {\n      callback(err);\n      called = true;\n    }\n  }\n  return called;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/doc.js\n// module id = 44\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/doc.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar emitter = __webpack_require__(18);\n\n// Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\nmodule.exports = Query;\nfunction Query(action, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this);\n\n  // 'qf' or 'qs'\n  this.action = action;\n\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n\n  // The query itself. For mongo, this should look something like {\"data.x\":5}\n  this.query = query;\n\n  // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. It is possible to pass in an initial results set,\n  // so that a query can be serialized and then re-established\n  this.results = null;\n  if (options && options.results) {\n    this.results = options.results;\n    delete options.results;\n  }\n  this.extra = undefined;\n\n  // Options to pass through with the query\n  this.options = options;\n\n  this.callback = callback;\n  this.ready = false;\n  this.sent = false;\n}\nemitter.mixin(Query);\n\nQuery.prototype.hasPending = function () {\n  return !this.ready;\n};\n\n// Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\nQuery.prototype.send = function () {\n  if (!this.connection.canSend) return;\n\n  var message = {\n    a: this.action,\n    id: this.id,\n    c: this.collection,\n    q: this.query\n  };\n  if (this.options) {\n    message.o = this.options;\n  }\n  if (this.results) {\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    var results = [];\n    for (var i = 0; i < this.results.length; i++) {\n      var doc = this.results[i];\n      results.push([doc.id, doc.version]);\n    }\n    message.r = results;\n  }\n\n  this.connection.send(message);\n  this.sent = true;\n};\n\n// Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection.\nQuery.prototype.destroy = function (callback) {\n  if (this.connection.canSend && this.action === 'qs') {\n    this.connection.send({ a: 'qu', id: this.id });\n  }\n  this.connection._destroyQuery(this);\n  // There is a callback for consistency, but we don't actually wait for the\n  // server's unsubscribe message currently\n  if (callback) process.nextTick(callback);\n};\n\nQuery.prototype._onConnectionStateChanged = function () {\n  if (this.connection.canSend && !this.sent) {\n    this.send();\n  } else {\n    this.sent = false;\n  }\n};\n\nQuery.prototype._handleFetch = function (err, data, extra) {\n  // Once a fetch query gets its data, it is destroyed.\n  this.connection._destroyQuery(this);\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleSubscribe = function (err, data, extra) {\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleResponse = function (err, data, extra) {\n  var callback = this.callback;\n  this.callback = null;\n  if (err) return this._finishResponse(err, callback);\n  if (!data) return this._finishResponse(null, callback);\n\n  var query = this;\n  var wait = 1;\n  var finish = function finish(err) {\n    if (err) return query._finishResponse(err, callback);\n    if (--wait) return;\n    query._finishResponse(null, callback);\n  };\n\n  if (Array.isArray(data)) {\n    wait += data.length;\n    this.results = this._ingestSnapshots(data, finish);\n    this.extra = extra;\n  } else {\n    for (var id in data) {\n      wait++;\n      var snapshot = data[id];\n      var doc = this.connection.get(snapshot.c || this.collection, id);\n      doc.ingestSnapshot(snapshot, finish);\n    }\n  }\n\n  finish();\n};\n\nQuery.prototype._ingestSnapshots = function (snapshots, finish) {\n  var results = [];\n  for (var i = 0; i < snapshots.length; i++) {\n    var snapshot = snapshots[i];\n    var doc = this.connection.get(snapshot.c || this.collection, snapshot.d);\n    doc.ingestSnapshot(snapshot, finish);\n    results.push(doc);\n  }\n  return results;\n};\n\nQuery.prototype._finishResponse = function (err, callback) {\n  this.emit('ready');\n  this.ready = true;\n  if (err) {\n    this.connection._destroyQuery(this);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  if (callback) callback(null, this.results, this.extra);\n};\n\nQuery.prototype._handleError = function (err) {\n  this.emit('error', err);\n};\n\nQuery.prototype._handleDiff = function (diff) {\n  // We need to go through the list twice. First, we'll ingest all the new\n  // documents. After that we'll emit events and actually update our list.\n  // This avoids race conditions around setting documents to be subscribed &\n  // unsubscribing documents in event callbacks.\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    if (d.type === 'insert') d.values = this._ingestSnapshots(d.values);\n  }\n\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    switch (d.type) {\n      case 'insert':\n        var newDocs = d.values;\n        Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n        this.emit('insert', newDocs, d.index);\n        break;\n      case 'remove':\n        var howMany = d.howMany || 1;\n        var removed = this.results.splice(d.index, howMany);\n        this.emit('remove', removed, d.index);\n        break;\n      case 'move':\n        var howMany = d.howMany || 1;\n        var docs = this.results.splice(d.from, howMany);\n        Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n        this.emit('move', docs, d.from, d.to);\n        break;\n    }\n  }\n\n  this.emit('changed', this.results);\n};\n\nQuery.prototype._handleExtra = function (extra) {\n  this.extra = extra;\n  this.emit('extra', extra);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/query.js\n// module id = 45\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/query.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Snapshot = __webpack_require__(61);\nvar emitter = __webpack_require__(18);\n\nmodule.exports = SnapshotRequest;\n\nfunction SnapshotRequest(connection, requestId, collection, id, callback) {\n  emitter.EventEmitter.call(this);\n\n  if (typeof callback !== 'function') {\n    throw new Error('Callback is required for SnapshotRequest');\n  }\n\n  this.requestId = requestId;\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n  this.callback = callback;\n\n  this.sent = false;\n}\nemitter.mixin(SnapshotRequest);\n\nSnapshotRequest.prototype.send = function () {\n  if (!this.connection.canSend) {\n    return;\n  }\n\n  this.connection.send(this._message());\n  this.sent = true;\n};\n\nSnapshotRequest.prototype._onConnectionStateChanged = function () {\n  if (this.connection.canSend) {\n    if (!this.sent) this.send();\n  } else {\n    // If the connection can't send, then we've had a disconnection, and even if we've already sent\n    // the request previously, we need to re-send it over this reconnected client, so reset the\n    // sent flag to false.\n    this.sent = false;\n  }\n};\n\nSnapshotRequest.prototype._handleResponse = function (error, message) {\n  this.emit('ready');\n\n  if (error) {\n    return this.callback(error);\n  }\n\n  var metadata = message.meta ? message.meta : null;\n  var snapshot = new Snapshot(this.id, message.v, message.type, message.data, metadata);\n\n  this.callback(null, snapshot);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/snapshot-request/snapshot-request.js\n// module id = 46\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/snapshot-request/snapshot-request.js?")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 47\n// module chunks = 0\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},function(module,exports,__webpack_require__){eval('var map = {\n\t"./assets": 25,\n\t"./assets.js": 25,\n\t"./clientManager": 26,\n\t"./clientManager.js": 26,\n\t"./connectionEvents": 27,\n\t"./connectionEvents.js": 27,\n\t"./cookies": 28,\n\t"./cookies.js": 28,\n\t"./coreConfig": 16,\n\t"./coreConfig.js": 16,\n\t"./coreDOM": 6,\n\t"./coreDOM.js": 6,\n\t"./coreDatabase": 7,\n\t"./coreDatabase.js": 7,\n\t"./coreEvents": 1,\n\t"./coreEvents.js": 1,\n\t"./coreJsonML": 12,\n\t"./coreJsonML.js": 12,\n\t"./coreMutation": 13,\n\t"./coreMutation.js": 13,\n\t"./coreOpApplier": 19,\n\t"./coreOpApplier.js": 19,\n\t"./coreOpCreator": 14,\n\t"./coreOpCreator.js": 14,\n\t"./corePathTree": 8,\n\t"./corePathTree.js": 8,\n\t"./corePopulator": 15,\n\t"./corePopulator.js": 15,\n\t"./coreUtils": 0,\n\t"./coreUtils.js": 0,\n\t"./coreWebsocket": 3,\n\t"./coreWebsocket.js": 3,\n\t"./dataSavedEvent": 29,\n\t"./dataSavedEvent.js": 29,\n\t"./databaseErrors": 30,\n\t"./databaseErrors.js": 30,\n\t"./domEvents": 31,\n\t"./domEvents.js": 31,\n\t"./globalObject": 2,\n\t"./globalObject.js": 2,\n\t"./keepAlive": 32,\n\t"./keepAlive.js": 32,\n\t"./loadedEvent": 9,\n\t"./loadedEvent.js": 9,\n\t"./messages": 33,\n\t"./messages.js": 33,\n\t"./newWebstrates": 34,\n\t"./newWebstrates.js": 34,\n\t"./nodeObjects": 10,\n\t"./nodeObjects.js": 10,\n\t"./permissions": 35,\n\t"./permissions.js": 35,\n\t"./protectedMode": 36,\n\t"./protectedMode.js": 36,\n\t"./signalStream": 37,\n\t"./signalStream.js": 37,\n\t"./signaling": 20,\n\t"./signaling.js": 20,\n\t"./tagging": 38,\n\t"./tagging.js": 38,\n\t"./transclusionEvent": 39,\n\t"./transclusionEvent.js": 39,\n\t"./userHistory": 40,\n\t"./userHistory.js": 40,\n\t"./userObject": 11,\n\t"./userObject.js": 11,\n\t"./userObjectSignaling": 41,\n\t"./userObjectSignaling.js": 41\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error("Cannot find module \'" + req + "\'.");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 48;\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates ^\\.\\/.*$\n// module id = 48\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/webstrates_^\\.\\/.*$?')},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(config) {\n\nvar coreEvents = __webpack_require__(1);\nvar coreDOM = __webpack_require__(6);\nvar coreDatabase = __webpack_require__(7);\nvar coreMutation = __webpack_require__(13);\nvar coreOpApplier = __webpack_require__(19);\nvar coreOpCreator = __webpack_require__(14);\nvar corePopulator = __webpack_require__(15);\nvar coreUtils = __webpack_require__(0);\nvar coreWebsocket = __webpack_require__(3);\n\n// Create an event that'll be triggered once all modules have been loaded.\ncoreEvents.createEvent('allModulesLoaded');\n\nvar request = coreUtils.getLocationObject();\n\nvar protocol = location.protocol === 'http:' ? 'ws:' : 'wss:';\ncoreWebsocket.setup(protocol + '//' + location.host + '/' + request.webstrateId + '/' + location.search);\n\n// Load optional modules.\nconfig.modules.forEach(function (module) {\n\treturn __webpack_require__(48)(\"./\" + module);\n});\n\n// Send out an event when all modules have been loaded.\ncoreEvents.triggerEvent('allModulesLoaded');\n\nif (request.staticMode) {\n\tcoreDatabase.fetch(request.webstrateId, request.tagOrVersion).then(function (doc) {\n\t\tcorePopulator.populate(coreDOM.externalDocument, doc);\n\t});\n} else {\n\tcoreDatabase.subscribe(request.webstrateId).then(function (doc) {\n\t\tcorePopulator.populate(coreDOM.externalDocument, doc).then(function () {\n\t\t\t// Emits mutations from changes on the coreDOM.externalDocument.\n\t\t\tcoreMutation.emitMutationsFrom(coreDOM.externalDocument);\n\n\t\t\t// Emits ops from the mutations emitted by coreMutation.\n\t\t\tcoreOpCreator.emitOpsFromMutations();\n\n\t\t\t// Apply changes on <html>, not coreDOM.externalDocument.\n\t\t\tvar targetElement = coreDOM.externalDocument.childNodes[0];\n\t\t\tcoreOpApplier.listenForOpsAndApplyOn(targetElement);\n\t\t});\n\t});\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/index.js\n// module id = 49\n// module chunks = 0\n\n//# sourceURL=webpack:///./client/index.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n}\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff_match_patch.Diff;\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function (text1, text2, opt_checklines, opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = new Date().getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function (text1, text2, checklines, deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function (text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop(); // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function (text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = delta % 2 != 0;\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if (new Date().getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function (text1, text2, x, y, deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function (text1, text2) {\n  var lineArray = []; // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {}; // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return { chars1: chars1, chars2: chars2, lineArray: lineArray };\n};\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function (diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function (text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function (text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null; // Pointless.\n  }\n  var dmp = this; // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function (diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0; // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && (pre_ins && pre_del && post_ins && post_del || lastequality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--; // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--; // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function (diffs) {\n  diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function (diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {\n      // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {\n      // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function (diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0]; // Operation (insert, delete, equal)\n    var data = diffs[x][1]; // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;').replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function (diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function (diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function (diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function (diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function (text1, delta) {\n  var diffs = [];\n  var diffsLength = 0; // Keeping our own length var is faster in JS.\n  var pointer = 0; // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n      // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' + tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer + ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function (text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function (text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this; // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + proximity / dmp.Match_Distance;\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << pattern.length - 1;\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {\n        // First pass: exact match.\n        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n      } else {\n        // Subsequent passes: fuzzy match.\n        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function (pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  }\n  return s;\n};\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function (patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix]);\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function (a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' && typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */a;\n    diffs = this.diff_main(text1, /** @type {string} */opt_b, true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && (typeof a === 'undefined' ? 'undefined' : _typeof(a)) == 'object' && typeof opt_b == 'undefined' && typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */a;\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && (typeof opt_b === 'undefined' ? 'undefined' : _typeof(opt_b)) == 'object' && typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */a;\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */opt_b;\n  } else if (typeof a == 'string' && typeof opt_b == 'string' && opt_c && (typeof opt_c === 'undefined' ? 'undefined' : _typeof(opt_c)) == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */a;\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */opt_c;\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return []; // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0; // Keeping our own length var is faster in JS.\n  var char_count1 = 0; // Number of characters into the text1 string.\n  var char_count2 = 0; // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function (patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = patch.diffs[y].slice();\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function (patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {\n              // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {\n              // Deletion\n              text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function (patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\n    patch.start1 -= paddingLength; // Should be 0.\n    patch.start2 -= paddingLength; // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding]);\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function (patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push([DIFF_EQUAL, precontext]);\n      }\n      while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push([diff_type, diff_text]);\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push([diff_type, diff_text]);\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext = precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function (patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function (textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line]);\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line]);\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line]);\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function () {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function () {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = this.start1 + 1 + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = this.start2 + 1 + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/diff-match-patch/index.js\n// module id = 50\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/diff-match-patch/index.js?")},function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar R = (typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }var doError = type === 'error';\n\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) {\n      ReflectApply(listeners[i], this, args);\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)));\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)));\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)));\n  }\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)));\n  }\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n\n    if (list.length === 1) events[type] = list[0];\n\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined) return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) {\n    copy[i] = arr[i];\n  }return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 51\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/events/events.js?")},function(module,exports,__webpack_require__){"use strict";eval("// ISC @ Julien Fontanet\n\n\n\n// ===================================================================\n\nvar construct = typeof Reflect !== 'undefined' ? Reflect.construct : undefined;\nvar defineProperty = Object.defineProperty;\n\n// -------------------------------------------------------------------\n\nvar captureStackTrace = Error.captureStackTrace;\nif (captureStackTrace === undefined) {\n  captureStackTrace = function captureStackTrace(error) {\n    var container = new Error();\n\n    defineProperty(error, 'stack', {\n      configurable: true,\n      get: function getStack() {\n        var stack = container.stack;\n\n        // Replace property with value for faster future accesses.\n        defineProperty(this, 'stack', {\n          configurable: true,\n          value: stack,\n          writable: true\n        });\n\n        return stack;\n      },\n      set: function setStack(stack) {\n        defineProperty(error, 'stack', {\n          configurable: true,\n          value: stack,\n          writable: true\n        });\n      }\n    });\n  };\n}\n\n// -------------------------------------------------------------------\n\nfunction BaseError(message) {\n  if (message !== undefined) {\n    defineProperty(this, 'message', {\n      configurable: true,\n      value: message,\n      writable: true\n    });\n  }\n\n  var cname = this.constructor.name;\n  if (cname !== undefined && cname !== this.name) {\n    defineProperty(this, 'name', {\n      configurable: true,\n      value: cname,\n      writable: true\n    });\n  }\n\n  captureStackTrace(this, this.constructor);\n}\n\nBaseError.prototype = Object.create(Error.prototype, {\n  // See: https://github.com/JsCommunity/make-error/issues/4\n  constructor: {\n    configurable: true,\n    value: BaseError,\n    writable: true\n  }\n});\n\n// -------------------------------------------------------------------\n\n// Sets the name of a function if possible (depends of the JS engine).\nvar setFunctionName = function () {\n  function setFunctionName(fn, name) {\n    return defineProperty(fn, 'name', {\n      configurable: true,\n      value: name\n    });\n  }\n  try {\n    var f = function f() {};\n    setFunctionName(f, 'foo');\n    if (f.name === 'foo') {\n      return setFunctionName;\n    }\n  } catch (_) {}\n}();\n\n// -------------------------------------------------------------------\n\nfunction makeError(constructor, super_) {\n  if (super_ == null || super_ === Error) {\n    super_ = BaseError;\n  } else if (typeof super_ !== 'function') {\n    throw new TypeError('super_ should be a function');\n  }\n\n  var name;\n  if (typeof constructor === 'string') {\n    name = constructor;\n    constructor = construct !== undefined ? function () {\n      return construct(super_, arguments, this.constructor);\n    } : function () {\n      super_.apply(this, arguments);\n    };\n\n    // If the name can be set, do it once and for all.\n    if (setFunctionName !== undefined) {\n      setFunctionName(constructor, name);\n      name = undefined;\n    }\n  } else if (typeof constructor !== 'function') {\n    throw new TypeError('constructor should be either a string or a function');\n  }\n\n  // Also register the super constructor also as `constructor.super_` just\n  // like Node's `util.inherits()`.\n  constructor.super_ = constructor['super'] = super_;\n\n  var properties = {\n    constructor: {\n      configurable: true,\n      value: constructor,\n      writable: true\n    }\n\n    // If the name could not be set on the constructor, set it on the\n    // prototype.\n  };if (name !== undefined) {\n    properties.name = {\n      configurable: true,\n      value: name,\n      writable: true\n    };\n  }\n  constructor.prototype = Object.create(super_.prototype, properties);\n\n  return constructor;\n}\nexports = module.exports = makeError;\nexports.BaseError = BaseError;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/make-error/index.js\n// module id = 52\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/make-error/index.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you're welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: __webpack_require__(43)\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/index.js\n// module id = 53\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/ot-json0/lib/index.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function create(initial) {\n    if (initial != null && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function strInject(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function checkValidComponent(c) {\n  if (typeof c.p !== 'number') throw new Error('component missing position field');\n\n  if (typeof c.i === 'string' === (typeof c.d === 'string')) throw new Error('component needs an i or d field');\n\n  if (c.p < 0) throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function checkValidOp(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function (snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted) throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function (newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = { i: strInject(last.i, c.p - last.p, c.i), p: last.p };\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = { d: strInject(c.d, last.p - c.p, last.d), p: c.p };\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function (op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function (op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function transformPosition(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || c.p === pos && insertAfter) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function (position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function (dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, { i: c.i, p: transformPosition(c.p, otherC, side === 'right') });\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, { d: s.slice(0, otherC.p - c.p), p: c.p });\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '') append(dest, { d: s, p: c.p + otherC.i.length });\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length) append(dest, { d: c.d, p: c.p - otherC.d.length });else if (c.p + c.d.length <= otherC.p) append(dest, c);else {\n        // They overlap somewhere.\n        var newC = { d: '', p: c.p };\n\n        if (c.p < otherC.p) newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length) newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect) throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function invertComponent(c) {\n  return c.i != null ? { d: c.i, p: c.p } : { i: c.d, p: c.p };\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function (op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\n__webpack_require__(42)(text, transformComponent, checkValidOp, append);\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/text0.js\n// module id = 54\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/ot-json0/lib/text0.js?")},function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global, process) {\n\n(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== "function") {\n            callback = new Function("" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47), __webpack_require__(17)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 55\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/setimmediate/setImmediate.js?')},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Doc = __webpack_require__(44);\nvar Query = __webpack_require__(45);\nvar SnapshotVersionRequest = __webpack_require__(59);\nvar SnapshotTimestampRequest = __webpack_require__(58);\nvar emitter = __webpack_require__(18);\nvar ShareDBError = __webpack_require__(21);\nvar types = __webpack_require__(23);\nvar util = __webpack_require__(24);\nvar logger = __webpack_require__(22);\n\nfunction connectionState(socket) {\n  if (socket.readyState === 0 || socket.readyState === 1) return 'connecting';\n  return 'disconnected';\n}\n\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\nmodule.exports = Connection;\nfunction Connection(socket) {\n  emitter.EventEmitter.call(this);\n\n  // Map of collection -> id -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n  this.collections = {};\n\n  // Each query and snapshot request is created with an id that the server uses when it sends us\n  // info about the request (updates, etc)\n  this.nextQueryId = 1;\n  this.nextSnapshotRequestId = 1;\n\n  // Map from query ID -> query object.\n  this.queries = {};\n\n  // Map from snapshot request ID -> snapshot request\n  this._snapshotRequests = {};\n\n  // A unique message number for the given id\n  this.seq = 1;\n\n  // Equals agent.clientId on the server\n  this.id = null;\n\n  // This direct reference from connection to agent is not used internal to\n  // ShareDB, but it is handy for server-side only user code that may cache\n  // state on the agent and read it in middleware\n  this.agent = null;\n\n  this.debug = false;\n\n  this.state = connectionState(socket);\n\n  this.bindToSocket(socket);\n}\nemitter.mixin(Connection);\n\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(message). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\nConnection.prototype.bindToSocket = function (socket) {\n  if (this.socket) {\n    this.socket.close();\n    this.socket.onmessage = null;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n  }\n\n  this.socket = socket;\n\n  // State of the connection. The corresponding events are emitted when this changes\n  //\n  // - 'connecting'   The connection is still being established, or we are still\n  //                    waiting on the server to send us the initialization message\n  // - 'connected'    The connection is open and we have connected to a server\n  //                    and recieved the initialization message\n  // - 'disconnected' Connection is closed, but it will reconnect automatically\n  // - 'closed'       The connection was closed by the client, and will not reconnect\n  // - 'stopped'      The connection was closed by the server, and will not reconnect\n  var newState = connectionState(socket);\n  this._setState(newState);\n\n  // This is a helper variable the document uses to see whether we're\n  // currently in a 'live' state. It is true if and only if we're connected\n  this.canSend = false;\n\n  var connection = this;\n\n  socket.onmessage = function (event) {\n    try {\n      var data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n    } catch (err) {\n      logger.warn('Failed to parse message', event);\n      return;\n    }\n\n    if (connection.debug) logger.info('RECV', JSON.stringify(data));\n\n    var request = { data: data };\n    connection.emit('receive', request);\n    if (!request.data) return;\n\n    try {\n      connection.handleMessage(request.data);\n    } catch (err) {\n      process.nextTick(function () {\n        connection.emit('error', err);\n      });\n    }\n  };\n\n  socket.onopen = function () {\n    connection._setState('connecting');\n  };\n\n  socket.onerror = function (err) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', err);\n  };\n\n  socket.onclose = function (reason) {\n    // node-browserchannel reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n\n    if (reason === 'closed' || reason === 'Closed') {\n      connection._setState('closed', reason);\n    } else if (reason === 'stopped' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n    } else {\n      connection._setState('disconnected', reason);\n    }\n  };\n};\n\n/**\n * @param {object} message\n * @param {String} message.a action\n */\nConnection.prototype.handleMessage = function (message) {\n  var err = null;\n  if (message.error) {\n    // wrap in Error object so can be passed through event emitters\n    err = new Error(message.error.message);\n    err.code = message.error.code;\n    // Add the message data to the error object for more context\n    err.data = message;\n    delete message.error;\n  }\n  // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n  switch (message.a) {\n    case 'init':\n      // Client initialization packet\n      if (message.protocol !== 1) {\n        err = new ShareDBError(4019, 'Invalid protocol version');\n        return this.emit('error', err);\n      }\n      if (types.map[message.type] !== types.defaultType) {\n        err = new ShareDBError(4020, 'Invalid default type');\n        return this.emit('error', err);\n      }\n      if (typeof message.id !== 'string') {\n        err = new ShareDBError(4021, 'Invalid client id');\n        return this.emit('error', err);\n      }\n      this.id = message.id;\n\n      this._setState('connected');\n      return;\n\n    case 'qf':\n      var query = this.queries[message.id];\n      if (query) query._handleFetch(err, message.data, message.extra);\n      return;\n    case 'qs':\n      var query = this.queries[message.id];\n      if (query) query._handleSubscribe(err, message.data, message.extra);\n      return;\n    case 'qu':\n      // Queries are removed immediately on calls to destroy, so we ignore\n      // replies to query unsubscribes. Perhaps there should be a callback for\n      // destroy, but this is currently unimplemented\n      return;\n    case 'q':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[message.id];\n      if (!query) return;\n      if (err) return query._handleError(err);\n      if (message.diff) query._handleDiff(message.diff);\n      if (message.hasOwnProperty('extra')) query._handleExtra(message.extra);\n      return;\n\n    case 'bf':\n      return this._handleBulkMessage(message, '_handleFetch');\n    case 'bs':\n      return this._handleBulkMessage(message, '_handleSubscribe');\n    case 'bu':\n      return this._handleBulkMessage(message, '_handleUnsubscribe');\n\n    case 'nf':\n    case 'nt':\n      return this._handleSnapshotFetch(err, message);\n\n    case 'f':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleFetch(err, message.data);\n      return;\n    case 's':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleSubscribe(err, message.data);\n      return;\n    case 'u':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleUnsubscribe(err);\n      return;\n    case 'op':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleOp(err, message);\n      return;\n\n    default:\n      logger.warn('Ignoring unrecognized message', message);\n  }\n};\n\nConnection.prototype._handleBulkMessage = function (message, method) {\n  if (message.data) {\n    for (var id in message.data) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error, message.data[id]);\n    }\n  } else if (Array.isArray(message.b)) {\n    for (var i = 0; i < message.b.length; i++) {\n      var id = message.b[i];\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error);\n    }\n  } else if (message.b) {\n    for (var id in message.b) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error);\n    }\n  } else {\n    logger.error('Invalid bulk message', message);\n  }\n};\n\nConnection.prototype._reset = function () {\n  this.seq = 1;\n  this.id = null;\n  this.agent = null;\n};\n\n// Set the connection's state. The connection is basically a state machine.\nConnection.prototype._setState = function (newState, reason) {\n  if (this.state === newState) return;\n\n  // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n  if (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped' && this.state !== 'closed' || newState === 'connected' && this.state !== 'connecting') {\n    var err = new ShareDBError(5007, 'Cannot transition directly from ' + this.state + ' to ' + newState);\n    return this.emit('error', err);\n  }\n\n  this.state = newState;\n  this.canSend = newState === 'connected';\n\n  if (newState === 'disconnected' || newState === 'stopped' || newState === 'closed') this._reset();\n\n  // Group subscribes together to help server make more efficient calls\n  this.startBulk();\n  // Emit the event to all queries\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    query._onConnectionStateChanged();\n  }\n  // Emit the event to all documents\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      docs[id]._onConnectionStateChanged();\n    }\n  }\n  // Emit the event to all snapshots\n  for (var id in this._snapshotRequests) {\n    var snapshotRequest = this._snapshotRequests[id];\n    snapshotRequest._onConnectionStateChanged();\n  }\n  this.endBulk();\n\n  this.emit(newState, reason);\n  this.emit('state', newState, reason);\n};\n\nConnection.prototype.startBulk = function () {\n  if (!this.bulk) this.bulk = {};\n};\n\nConnection.prototype.endBulk = function () {\n  if (this.bulk) {\n    for (var collection in this.bulk) {\n      var actions = this.bulk[collection];\n      this._sendBulk('f', collection, actions.f);\n      this._sendBulk('s', collection, actions.s);\n      this._sendBulk('u', collection, actions.u);\n    }\n  }\n  this.bulk = null;\n};\n\nConnection.prototype._sendBulk = function (action, collection, values) {\n  if (!values) return;\n  var ids = [];\n  var versions = {};\n  var versionsCount = 0;\n  var versionId;\n  for (var id in values) {\n    var value = values[id];\n    if (value == null) {\n      ids.push(id);\n    } else {\n      versions[id] = value;\n      versionId = id;\n      versionsCount++;\n    }\n  }\n  if (ids.length === 1) {\n    var id = ids[0];\n    this.send({ a: action, c: collection, d: id });\n  } else if (ids.length) {\n    this.send({ a: 'b' + action, c: collection, b: ids });\n  }\n  if (versionsCount === 1) {\n    var version = versions[versionId];\n    this.send({ a: action, c: collection, d: versionId, v: version });\n  } else if (versionsCount) {\n    this.send({ a: 'b' + action, c: collection, b: versions });\n  }\n};\n\nConnection.prototype._sendAction = function (action, doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  if (this.bulk) {\n    // Bulk subscribe\n    var actions = this.bulk[doc.collection] || (this.bulk[doc.collection] = {});\n    var versions = actions[action] || (actions[action] = {});\n    var isDuplicate = versions.hasOwnProperty(doc.id);\n    versions[doc.id] = version;\n    return isDuplicate;\n  } else {\n    // Send single doc subscribe message\n    var message = { a: action, c: doc.collection, d: doc.id, v: version };\n    this.send(message);\n  }\n};\n\nConnection.prototype.sendFetch = function (doc) {\n  return this._sendAction('f', doc, doc.version);\n};\n\nConnection.prototype.sendSubscribe = function (doc) {\n  return this._sendAction('s', doc, doc.version);\n};\n\nConnection.prototype.sendUnsubscribe = function (doc) {\n  return this._sendAction('u', doc);\n};\n\nConnection.prototype.sendOp = function (doc, op) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var message = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.id,\n    v: doc.version,\n    src: op.src,\n    seq: op.seq\n  };\n  if (op.op) message.op = op.op;\n  if (op.create) message.create = op.create;\n  if (op.del) message.del = op.del;\n  this.send(message);\n};\n\n/**\n * Sends a message down the socket\n */\nConnection.prototype.send = function (message) {\n  if (this.debug) logger.info('SEND', JSON.stringify(message));\n\n  this.emit('send', message);\n  this.socket.send(JSON.stringify(message));\n};\n\n/**\n * Closes the socket and emits 'closed'\n */\nConnection.prototype.close = function () {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function (collection, id) {\n  if (this.collections[collection]) return this.collections[collection][id];\n};\n\n/**\n * Get or create a document.\n *\n * @param collection\n * @param id\n * @return {Doc}\n */\nConnection.prototype.get = function (collection, id) {\n  var docs = this.collections[collection] || (this.collections[collection] = {});\n\n  var doc = docs[id];\n  if (!doc) {\n    doc = docs[id] = new Doc(this, collection, id);\n    this.emit('doc', doc);\n  }\n\n  return doc;\n};\n\n/**\n * Remove document from this.collections\n *\n * @private\n */\nConnection.prototype._destroyDoc = function (doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) return;\n\n  delete docs[doc.id];\n\n  // Delete the collection container if its empty. This could be a source of\n  // memory leaks if you slowly make a billion collections, which you probably\n  // won't do anyway, but whatever.\n  if (!util.hasKeys(docs)) {\n    delete this.collections[doc.collection];\n  }\n};\n\nConnection.prototype._addDoc = function (doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) {\n    docs = this.collections[doc.collection] = {};\n  }\n  if (docs[doc.id] !== doc) {\n    docs[doc.id] = doc;\n  }\n};\n\n// Helper for createFetchQuery and createSubscribeQuery, below.\nConnection.prototype._createQuery = function (action, collection, q, options, callback) {\n  var id = this.nextQueryId++;\n  var query = new Query(action, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query.send();\n  return query;\n};\n\n// Internal function. Use query.destroy() to remove queries.\nConnection.prototype._destroyQuery = function (query) {\n  delete this.queries[query.id];\n};\n\n// The query options object can contain the following fields:\n//\n// db: Name of the db for the query. You can attach extraDbs to ShareDB and\n//   pick which one the query should hit using this parameter.\n\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createFetchQuery = function (collection, q, options, callback) {\n  return this._createQuery('qf', collection, q, options, callback);\n};\n\n// Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createSubscribeQuery = function (collection, q, options, callback) {\n  return this._createQuery('qs', collection, q, options, callback);\n};\n\nConnection.prototype.hasPending = function () {\n  return !!(this._firstDoc(hasPending) || this._firstQuery(hasPending) || this._firstSnapshotRequest());\n};\nfunction hasPending(object) {\n  return object.hasPending();\n}\n\nConnection.prototype.hasWritePending = function () {\n  return !!this._firstDoc(hasWritePending);\n};\nfunction hasWritePending(object) {\n  return object.hasWritePending();\n}\n\nConnection.prototype.whenNothingPending = function (callback) {\n  var doc = this._firstDoc(hasPending);\n  if (doc) {\n    // If a document is found with a pending operation, wait for it to emit\n    // that nothing is pending anymore, and then recheck all documents again.\n    // We have to recheck all documents, just in case another mutation has\n    // been made in the meantime as a result of an event callback\n    doc.once('nothing pending', this._nothingPendingRetry(callback));\n    return;\n  }\n  var query = this._firstQuery(hasPending);\n  if (query) {\n    query.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n  var snapshotRequest = this._firstSnapshotRequest();\n  if (snapshotRequest) {\n    snapshotRequest.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n  // Call back when no pending operations\n  process.nextTick(callback);\n};\nConnection.prototype._nothingPendingRetry = function (callback) {\n  var connection = this;\n  return function () {\n    process.nextTick(function () {\n      connection.whenNothingPending(callback);\n    });\n  };\n};\n\nConnection.prototype._firstDoc = function (fn) {\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      var doc = docs[id];\n      if (fn(doc)) {\n        return doc;\n      }\n    }\n  }\n};\n\nConnection.prototype._firstQuery = function (fn) {\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    if (fn(query)) {\n      return query;\n    }\n  }\n};\n\nConnection.prototype._firstSnapshotRequest = function () {\n  for (var id in this._snapshotRequests) {\n    return this._snapshotRequests[id];\n  }\n};\n\n/**\n * Fetch a read-only snapshot at a given version\n *\n * @param collection - the collection name of the snapshot\n * @param id - the ID of the snapshot\n * @param version (optional) - the version number to fetch. If null, the latest version is fetched.\n * @param callback - (error, snapshot) => void, where snapshot takes the following schema:\n *\n * {\n *   id: string;         // ID of the snapshot\n *   v: number;          // version number of the snapshot\n *   type: string;       // the OT type of the snapshot, or null if it doesn't exist or is deleted\n *   data: any;          // the snapshot\n * }\n *\n */\nConnection.prototype.fetchSnapshot = function (collection, id, version, callback) {\n  if (typeof version === 'function') {\n    callback = version;\n    version = null;\n  }\n\n  var requestId = this.nextSnapshotRequestId++;\n  var snapshotRequest = new SnapshotVersionRequest(this, requestId, collection, id, version, callback);\n  this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;\n  snapshotRequest.send();\n};\n\n/**\n * Fetch a read-only snapshot at a given timestamp\n *\n * @param collection - the collection name of the snapshot\n * @param id - the ID of the snapshot\n * @param timestamp (optional) - the timestamp to fetch. If null, the latest version is fetched.\n * @param callback - (error, snapshot) => void, where snapshot takes the following schema:\n *\n * {\n *   id: string;         // ID of the snapshot\n *   v: number;          // version number of the snapshot\n *   type: string;       // the OT type of the snapshot, or null if it doesn't exist or is deleted\n *   data: any;          // the snapshot\n * }\n *\n */\nConnection.prototype.fetchSnapshotByTimestamp = function (collection, id, timestamp, callback) {\n  if (typeof timestamp === 'function') {\n    callback = timestamp;\n    timestamp = null;\n  }\n\n  var requestId = this.nextSnapshotRequestId++;\n  var snapshotRequest = new SnapshotTimestampRequest(this, requestId, collection, id, timestamp, callback);\n  this._snapshotRequests[snapshotRequest.requestId] = snapshotRequest;\n  snapshotRequest.send();\n};\n\nConnection.prototype._handleSnapshotFetch = function (error, message) {\n  var snapshotRequest = this._snapshotRequests[message.id];\n  if (!snapshotRequest) return;\n  delete this._snapshotRequests[message.id];\n  snapshotRequest._handleResponse(error, message);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/connection.js\n// module id = 56\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/connection.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.Connection = __webpack_require__(56);\nexports.Doc = __webpack_require__(44);\nexports.Error = __webpack_require__(21);\nexports.Query = __webpack_require__(45);\nexports.types = __webpack_require__(23);\nexports.logger = __webpack_require__(22);\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/index.js\n// module id = 57\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/index.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar SnapshotRequest = __webpack_require__(46);\nvar util = __webpack_require__(24);\n\nmodule.exports = SnapshotTimestampRequest;\n\nfunction SnapshotTimestampRequest(connection, requestId, collection, id, timestamp, callback) {\n  SnapshotRequest.call(this, connection, requestId, collection, id, callback);\n\n  if (!util.isValidTimestamp(timestamp)) {\n    throw new Error('Snapshot timestamp must be a positive integer or null');\n  }\n\n  this.timestamp = timestamp;\n}\n\nSnapshotTimestampRequest.prototype = Object.create(SnapshotRequest.prototype);\n\nSnapshotTimestampRequest.prototype._message = function () {\n  return {\n    a: 'nt',\n    id: this.requestId,\n    c: this.collection,\n    d: this.id,\n    ts: this.timestamp\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/snapshot-request/snapshot-timestamp-request.js\n// module id = 58\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/snapshot-request/snapshot-timestamp-request.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar SnapshotRequest = __webpack_require__(46);\nvar util = __webpack_require__(24);\n\nmodule.exports = SnapshotVersionRequest;\n\nfunction SnapshotVersionRequest(connection, requestId, collection, id, version, callback) {\n  SnapshotRequest.call(this, connection, requestId, collection, id, callback);\n\n  if (!util.isValidVersion(version)) {\n    throw new Error('Snapshot version must be a positive integer or null');\n  }\n\n  this.version = version;\n}\n\nSnapshotVersionRequest.prototype = Object.create(SnapshotRequest.prototype);\n\nSnapshotVersionRequest.prototype._message = function () {\n  return {\n    a: 'nf',\n    id: this.requestId,\n    c: this.collection,\n    d: this.id,\n    v: this.version\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/snapshot-request/snapshot-version-request.js\n// module id = 59\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/client/snapshot-request/snapshot-version-request.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar SUPPORTED_METHODS = ['info', 'warn', 'error'];\n\nfunction Logger() {\n  var defaultMethods = {};\n  SUPPORTED_METHODS.forEach(function (method) {\n    // Deal with Chrome issue: https://bugs.chromium.org/p/chromium/issues/detail?id=179628\n    defaultMethods[method] = console[method].bind(console);\n  });\n  this.setMethods(defaultMethods);\n}\nmodule.exports = Logger;\n\nLogger.prototype.setMethods = function (overrides) {\n  overrides = overrides || {};\n  var logger = this;\n\n  SUPPORTED_METHODS.forEach(function (method) {\n    if (typeof overrides[method] === 'function') {\n      logger[method] = overrides[method];\n    }\n  });\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/logger/logger.js\n// module id = 60\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/logger/logger.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = Snapshot;\nfunction Snapshot(id, version, type, data, meta) {\n  this.id = id;\n  this.v = version;\n  this.type = type;\n  this.data = data;\n  this.m = meta;\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/snapshot.js\n// module id = 61\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/sharedb/lib/snapshot.js?")}])}(documentProxy,document,documentProxyObj);